#### Js作用域 作用域链[scope] 闭包closure

* “javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句
* javascript除了全局作用域之外，只有函数可以创建作用域
* 作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的
* 作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突
* 作用域在函数定义时就已经确定了。而不是在函数调用时确定

##### 例子
```
if(true){
    let a = 1;
}
console.log(a)  //1 说明javascript没有块级作用域
```

![image](https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/8.png?raw=true)  
 
##### 变量对象
变量对象，是执行上下文中的一部分，可以抽象为一种 数据作用域，其实也可以理解为就是一个简单的对象，它存储着该执行上下文中的所有 变量和函数声明(不包含函数表达式)。

活动对象 (Activation Object): 当变量对象所处的上下文为 activation EC 时，称为活动对象。

 
##### 自由变量
在A作用域中使用的变量x,却没有在A作用域声明，对于A作用域来说，x就是一个自由变量。
**在fn函数中，取自由变量x的值时，要到哪个作用域中取？要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。**

```
var x =10;
function fn()
{
console.log(x);//10
}
 
function show(f){
var x =30;
f();
}
show(fn);
```

##### 取自由变量时的这个“作用域链”过程：（假设a是自由量）

* 第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；
* 第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；
* 第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；
* 第四步，跳转到第一步。

```
var a =1;
function fn(){
   var b=3;
   function show(){
      console.log(a+b); //4
   };
   return show;
}
var x =fn();
var b=12;
x();
```

##### 闭包
闭包属于一种特殊的作用域，称为**静态作用域**。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。
闭包（closure）就是能够读取其他函数内部变量的函数。
闭包可以简单理解成“定义在一个函数内部的函数”。


**注意：自由变量跨作用域取值时，要去创建这个函数的作用域取值，而不是“父作用域”。**

##### 闭包的好处
* 希望一个变量长期驻扎在内存当中；
* 避免全局变量的污染
* 私有成员的存在


##### 使用闭包存在问题：
* 局部上下文活动对象，作用域没有及时销毁，增加内存开销


##### 闭包的应用

1. 函数作为返回值


```
//函数作为返回值
function fn(){
 var max = 10;
 return function bar(x){
   console.log(max); //10
 }
}
var f1 = fn();
f1();
```
2. 函数作为参数传递
```
//函数作为参数传递
var max = 12;
function fn(){
    console.log(max);//12
}
(function(f){
    var max =100;
    f();
})(fn)
```
3. 模块化代码


```
//立即调用表达式（IIFE）
var test = (function(){
    var a= 1;
    return function(){
        a++;
        console.log(a)
    }
})();

test();//2
test();//3
/*
  类似var test  = function(){}
  test指向指向这个匿名函数里面的一个函数，所以这个匿名函数的内存不能得到释放，a的值也会一直存在。
*/
```

4. 循环闭包

存在问题如下:
每次for循环，虽然都会有不同的i值，但是因为for循环里面有定时器函数，所以本作用域内存没有被销毁，最终i的值会是4，而当定时器执行时候，会先在本函数找i,找不到i时候，向上一级查找，也就是4。


```
//定时器里面的匿名函数要输出i,要会在外层的声明它本身的父作用域找，最后的的i是5。
for(var i=0;i<5;i++){
  setTimeout(()=>{
    console.log(i)
   },1000)
}
```
解决方式：

原理：
1. 作用域链
2. 闭包函数的赋值与运行

利用自执行匿名函数块，可以每次都生成不同的的作用域块，并且将i值传进不同作用域，开辟新的内存存储变量i,执行定时器时候，就会在各自的作用域内获取i值了。

```
(function(){
        // 这里为块级作用域，可以减少闭包的内存占用，因为外部没有对匿名函数进行引用，函数执行完毕，就会被销毁。
 })();
 
 for(var i=0;i<5;i++){
  (function(i){
     setTimeout(()=>{
    console.log(i)
   },1000)
  })(i)
}
```

