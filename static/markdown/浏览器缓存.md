#### 浏览器缓存

##### 什么是缓存？
缓存是一种可以自动保存常见资源副本并且可以在下次请求中直接使用副本而非再次获取的技术。
首次请求资源后，服务器返回资源给客户端的同时，缓存服务器或者本地缓存也会保存一份资源副本（在允许缓存的情况下）当再次请求时，则会直接使用资源副本而不从原始服务器再次请求文档。


##### 缓存的优点
* 以减少冗余的数据传输
* 缓解网络瓶颈的问题
* 降低对原始服务器的要求
* 降低请求距离的时延

##### 数据的冗余传输
当很多客户端访问同一份文档的时候，原始服务器一遍又一遍地返回的不同的客户端相同的内容，这些重复的文档造成了数据的冗余传输

##### 网络瓶颈的问题
客户端访问代理服务器的速度一般比直接访问原始服务器快速（带宽大，延时低）

##### 降低原始服务器的要求
多客户端同时访问原始服务器，容易造成服务器崩溃，缓存可以一定程度降低对原始服务器的压力

##### 降低请求距离时延
物理上的距离，也是降低we性能的一个方面客户端服务器距离越近，请求速度越快


###### 缓存命中
如果某个请求是由已缓存的副本提供的，则成为缓存命中

###### 缓存未命中
缓存没有可用的缓存副本或者缓存已经过期，则会将请求转发至原始的服务器，称为缓存未命中

##### 新鲜度检测
HTTP通过缓存将服务器文档的副本保留一段没时间，在这段时间内，都认为文档是“新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但是一缓存的副本停留时间太长，超过文档的新鲜度限值（Freshness limit),就认为对象“过时”了，在提供该文档之前，缓存要再次与服务器确认，以查看文档是否发生了变化

##### 再验证
缓存检测原始服务器文档是否变化，查看缓存版本是否为最新版本

##### 再验证命中和再验证未命中
缓存对缓存的副本进行再验证时，会向原始服务器发送一个再验证请求，如果内容没有发生变化，服务器会以304 Not Modified进行响应。这被称作是再验证命中或者缓慢命中。如果内容发生了变化，服务器会以200进行响应。这被称作再验证未命中。

##### 缓存的处理步骤
1. 首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。
2. 如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜，如果缓存新鲜，则会直接返回缓存副本给客户端。如果缓存不新鲜了，则表示强缓存失败，将会进入到协商缓存。
3. 协商缓存将判断是否存在Etag和Last-Modified首部，通过这些首部验证资源是否发生过变化，如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端，
4. 否则的话表示协商缓存未命中，服务器会返回新的资源。

#### 强缓存协商和协商缓存
##### 强缓存
![image](https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/cache/4.png?raw=true)
服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。即首次发起请求时，服务端会在Response Headers 中写入缓存新鲜时间。当请求再次发出时，如果缓存新鲜，将直接从缓存获取资源，而不会再与服务器发生通信。
##### 协商缓存

由服务端决定并告知客户端是否使用缓存。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。

##### 强缓存实现原理
强缓存是通过Expires[ɪkˈspaɪr]首部或Cache[kæʃ]-Control: max-age来实现的。

Expires 和 Cache-Control: max-age都是用来标识资源的过期时间的首部。
Expires描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示。
由于expires是一个绝对时间，如果人为的更改时间，会对缓存的有效期造成影响，使缓存有效期的设置失去意义。因此在http1.1中我们有了expires的完全替代首部cache-control：max-age
max-age值是一个相对时间，它定义了文档的最大使用期——从第一次生成文档到文档不再新鲜、无法使用为止，最大的合法生存时间(以秒为单位)。

当我们首次请求资源时，服务器在返回资源的同时，会在Response Headers中写入expires首部或cache-control，标识缓存的过期时间，缓存副本会将该部分信息保存起来。
当再次请求该资源的时候，缓存会对date(Date 是一个通用首部，表示原始服务器消息发出的时间。即表示的是首次请求某个资源的时间。)和expires/cache-control的时间进行对比，从而判断缓存副本是否足够新鲜。


##### 协商缓存实现原理
协商缓存是通过请求头Last-Modified或Etag来实现的。
Last-Modified 标识的是文档最后修改时间，Etag 则是以文档内容来进行编码的。

1. 首次请求资源时，服务器在返回资源的同时，会在Response Headers中写入Last-Modified首部，表示该资源在服务器上的最后修改时间。
2. 当再次请求该资源时，会在Request Headers 中写入If-Modified-Since首部，此时的If-Modified-Since的值是首次请求资源时所返回的Last-Modified的值。
3. 服务器接收到请求后，会根据If-Modified-Since的值判断资源在该日期之后是否发生过变化。
4. 如果没有，则会返回304 Not Modified;如果变化了，则会返回变化过后的资源，同时更新Last-Modified的值。

##### Last-Modified存在的一些问题
有些文档可能会被周期性地重写，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。
有些文档可能被修改了，但所做修改并不重要，不需要让缓存重载数据(比如对拼写或注释的修改)。
有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。
通过这些描述，我们可以总结出一些Last-Modified存在的缺陷：

无法感知文件内容是否真的发生了变化。
不该重新请求的时候，也会重新请求。
在秒以下的内容变化无法感知到。
该重新请求的时候，反而没有重新请求。

对于上述问题，Etag作为Last-Modified的补充而出现，Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，因此 Etag 能够精准地感知文件的变化。

##### Etag 强验证器和弱验证器

ETag 分为强验证器和弱验证器。

* 强验证器：要求文档的每个字节都相等
* 弱验证器：只要求文档的含义相等。


##### Cache-Control请求头常用属性说明
##### max-age/s-maxage
s-maxage指令的功能和max-age是相同的，它们唯一的不同点就在于s-maxage指令只适用于代理服务器缓存。s-maxage的优先级高于max-age。
##### public/private
public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。
如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。
##### no-cache/no-store
no-cache 表示客户端要求缓存在提供其已缓存的副本之前必须先和原始服务器对该文档进行验证。即强制跳过强缓存阶段，直接进行协商缓存。强缓存并不能知道缓存是否真的足够新鲜，使用no-cache就是为了防止从缓存中返回过期的资源，对缓存进行再验证。
no-store表示的是禁止缓存，即每一次都是直接与原服务器进行通信，从原服务器返回资源。一般设置了no-store的资源，都暗示着该资源具有敏感性信息。


