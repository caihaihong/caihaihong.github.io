## Java单态设计模式核心
* 采取一定的方法保证在整个软件系统中,对某个类只能产生一个对象实例,并且该类只提供一个取得其对象的实例方法.
* 在类的内部把构造器私有化,同时在内部产生对象,并通过类.静态方法(static)返回实例化对象的引用

#### 设计模式
设计模式是在大量的实践总结和理论化之后优选的代码结果,编程风格,以及解决问题的思考方式.设计模式就像是经典的棋谱,不同的棋局我们用不同的棋谱.


#### 在java中实现单态模式只需要执行以下三步：  

1. 将类的构造方法的访问权限声明为private.这样就不能用new操作符在类的外部产生类的对象了,但在类内部仍可以产生该类的对象
2. 在类内部生成一个静态的实例
3. 提供一个静态的方法用于外部取得该类的实例.
因为在类的外部无法得到类的对象,所以只能调用该类的某个静态方法以返回类内部创建的对象,又因为静态方法只能访问类中的静态成员变量,所以,指向类内部产生该类对象的变量也必须定义成静态的.
```
class Chinese{
    static Chinese objRef = new Chinese();
    private Chinese(){}
    public static Chinese getInstance(){
        return objRef;
    }
}
class Chinese_opt{
    static Chinese_opt objRef = null;
    private Chinese_opt(){}
    public static Chinese_opt getInstance(){
        if(objRef == null)
            objRef = new Chinese_opt();
        return objRef;
    }
}
class TestChinese{
    public static void main(String[] args){
        Chinese chinese1 = Chinese.getInstance();
        Chinese chinese2 = Chinese.getInstance();
        System.out.println(chinese1 == chinese2);
    }
}
```
#### 单态设计模式的意义

实际上这种模式非常常用，我们大家使用的windows操作系统中就使用了此设计模式，windows中用一个回车站： ，除了桌面以外，其他的每个硬盘中都有一个回车站，其他的回车站和其他硬盘的每个回车站都是同一个，也就是所整个操作系统中有且只有一个回车站，各个地方只是引用此实例。

#### 总结

单态设计模式的核心就是将类的构造函数私有化，在类的内部产生实例对象，并通过类的静态方法返回类的实例对象。

## Ioc—Inversion of Control 控制反转设计模式
* 谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）
* 为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了

#### IOC作用
* IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了
* IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找