webpackJsonp([0],{"6TGM":function(t,n){t.exports='<h4 id="-">数据双向绑定</h4>\n<pre><code>\n&lt;body&gt;\n    &lt;!-- 极简双向绑定 --&gt;\n    &lt;input type=&quot;text&quot; id=&quot;a&quot;&gt;\n    &lt;span id=&quot;b&quot;&gt;&lt;/span&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n&lt;script&gt;\n    //访问器属性\n    // 通过defineProperty方法定义\n    //  Vue 实现双向绑定的基本原理\n    //  model =&gt; view 以及 view =&gt; model 的双向绑定。\n    var obj = {};\n    Object.defineProperty(obj, &quot;hello&quot;, {\n        get: function () {\n            console.log(&quot;get-this→obj&quot;, this)\n            console.log(&quot;get方法被調用&quot;)\n        },\n        set: function (newVal) {\n            console.log(&quot;set-this→obj&quot;, this)\n            console.log(&quot;set方法被調用&quot;, 123)\n            document.getElementById(&#39;a&#39;).value = newVal;\n            document.getElementById(&#39;b&#39;).innerHTML = newVal;\n        }\n    })\n    console.log(&quot;obj&quot;, obj);\n    obj.hello;\n    document.addEventListener(&quot;keyup&quot;, (e) =&gt; {\n        obj.hello = e.target.value;\n    });\n&lt;/script&gt;</code></pre><h4 id="vue-index-js">Vue 源碼入口文件index.js</h4>\n<pre><code>import { initMixin } from &#39;./init&#39;\nimport { stateMixin } from &#39;./state&#39;\nimport { renderMixin } from &#39;./render&#39;\nimport { eventsMixin } from &#39;./events&#39;\nimport { lifecycleMixin } from &#39;./lifecycle&#39;\nimport { warn } from &#39;../util/index&#39;\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;\n    !(this instanceof Vue)) {\n    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n  }\n  this._init(options)  \n}\n\ninitMixin(Vue) \nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue</code></pre><pre><code>&lt;script&gt;\n    //prototype属性:向对象添加属性和方法\n    //给myfunc方法对象添加_init这个方法。（自执行）\n    myfunction.prototype._init = function (param) {\n        console.log(param)\n    }\n    function myfunction() {\n        console.log(this, &quot;当前this指向&quot;)       //myfunction这个方法对象\n        console.log(this instanceof myfunction) //true\n        this._init(&quot;执行_init方法&quot;)             //执行_init方法\n    }\n    var myfunc = new myfunction()\n&lt;/script&gt;</code></pre><h4 id="this-_init-options-">this._init(options)这个方法执行一下内容</h4>\n<pre><code>export function initMixin (Vue: Class&lt;Component&gt;) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options &amp;&amp; options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initState(vm)\n    callHook(vm, &#39;created&#39;)\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}</code></pre>'},ICs6:function(t,n){t.exports='<h2 id="es6-export-import-">ES6 export import (待补充)</h2>\n<ul>\n<li><p>export 模块导出（一个文件看做一个模块）</p>\n</li>\n<li><p>import 模块导入</p>\n<blockquote>\n<p><strong>例子一  单变量</strong>\na.js文件\nexport var name =&#39;hello&#39;;\nb.js文件\nimport {name} from &#39;/a.js&#39;\nalert(name)</p>\n</blockquote>\n<blockquote>\n<p><strong>例子二  多变量</strong>\na.js文件\nvar name1 = &quot;caicai&quot;\nvar name2 = &quot;hehe&quot;\nexport{name1,name2}\nb.js文件\nimport {name1,name2} from &#39;/b.js&#39;          * .js后缀可以省略*\nalert(name1)\nalert(name2)</p>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<p>例子三 <strong>导出函数</strong>\n<em>a.js文件</em>\nfunction add(x,y){\n   alert(x<em>y)\n   //  想一想如果这里是个返回值比如： return x-y，下边的函数怎么引用\n  }\n  export { add }\n*b.js文件</em>\nimport { add } from &quot;/.a.js&quot; //路径根据实际情况填写\n    add(4,6) //弹出来24</p>\n</blockquote>\n<h4 id="export-export-default">export &amp; export default</h4>\n<ul>\n<li>均可导出变量，常量，函数，文件，模块</li>\n<li>通过import{}引入</li>\n<li>可以多个import export,只能有一个export default</li>\n<li><strong>export导出，导入时候要加{}，export default为模块制定默认输出，所以不需要加{}提取变量名</strong><blockquote>\n<p>例子四   <strong>export default</strong>\na.js文件\nvar name =&quot;haha&quot;\nexport default name\nb.js文件\nimport name from &#39;/.js&#39;\nalert(name)</p>\n</blockquote>\n</li>\n</ul>\n<h4 id="es6-promise">ES6 Promise</h4>\n<p>一个<strong>Promise 对象</strong>可以理解为一次将要执行的操作（常常被用于异步操作），使用了 Promise 对象之后可以用一种<strong>链式</strong>调用的方式来组织代码，让代码更加直观。而且由于 Promise.all 这样的方法存在，可以让同时执行多个操作变得简单。</p>\n<ul>\n<li><p>resolve 和 reject</p>\n<p>  function helloWorld (ready) {\n  return new Promise(function (resolve, reject) {</p>\n<pre><code>  if (ready) {\n      resolve(&quot;Hello World!&quot;);\n  } else {\n      reject(&quot;Good bye!&quot;);\n  }\n  });</code></pre><p>  }</p>\n<p>  helloWorld(true).then(function (msg) {</p>\n<pre><code>  alert(msg);     </code></pre><p>  }, function (error) {</p>\n<pre><code>  alert(error);</code></pre><p>  })..catch(function(reason){\n  console.log(reason);\n}););</p>\n</li>\n</ul>\n<p>Promise 对象有三种状态：</p>\n<p>Fulfilled 可以理解为成功的状态\nRejected 可以理解为失败的状态\nPending 既不是 Fulfilld 也不是 Rejected 的状态，可以理解为 Promise 对象实例创建时候的初始状态。</p>\n'},J8US:function(t,n){t.exports='<h3 id="-">浏览器渲染机制</h3>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/9.png?raw=true" alt="image"></p>\n<h4 id="-">基础</h4>\n<ul>\n<li>Web浏览器是一种软件，它从远程服务器（或者本地磁盘）加载文件并将其显示并且用户可以与之交互。</li>\n<li>浏览器引擎：在不同的浏览器中，浏览器的某个部分会根据它接收到的文件确定显示什么，这就是所谓的浏览器引擎。浏览器引擎是每一种主流浏览器的核心软件组件，不同的浏览器开发商用不同的名字来称呼他们的引擎。<ul>\n<li>Firefox：Gecko</li>\n<li>Chrome：Blink，Webkit的一个分支。</li>\n</ul>\n</li>\n<li>发送 &amp; 接收信息：数据是以“数据包”的形式通过互联网发送，而数据包以字节为单位。</li>\n<li>计算机：只懂字节数,浏览器读取的是原始数据字节，而不是编写的实际代码。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/1.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/2.png?raw=true" alt="image"></li>\n<li>DOM：文档树结构，文档随心模型</li>\n<li>CSSOM：CSS树结构，层叠样式表对象模型</li>\n</ul>\n<h4 id="-">过程</h4>\n<p>当浏览器接收到原始数据字节并启动DOM构建解析HTML过程时，它还会发出请求来获取链接的CSS样式表。浏览器还是接收CSS数据的原始字节，从互联网或是本地磁盘。</p>\n<h4 id="-css-">浏览器如何处理这些CSS数据的原始字节</h4>\n<p>从CSS的原始字节到CSSOM，当浏览器接收到CSS的原始字节时，会启动一个和处理HTML原始字节类似的过程。就是说，原始数据字节被转换成字符，然后标记，然后形成节点，最后形成树结构。</p>\n<p>CSS级联是浏览器确定如何在元素上应用样式的机制。</p>\n<p>由于影响元素的样式可能来自父元素，即通过继承，或者已经在元素本身设置。浏览器必须递归遍历CSS树结构并确定影响特定元素的样式。</p>\n<h4 id="-">渲染树</h4>\n<h6 id="-reflow-js-">回流（reflow）：指的是网络浏览器为了重新渲染部分或全部的文档而重新计算文档中元素的位置和几何结构的过程。页面上节点是以树的形式展现的，我们通过js将页面上的一个节点删除，此时为了不让剩下的节点脱节，将断点结合起来重新形成一棵树。而这个重新结合过程就是回流。就是由于某些修改，要将元素回过头来重新“流”一遍。</h6>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/3.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/4.png?raw=true" alt="image"></p>\n<h4 id="-render-blocking-">渲染阻塞资源（render-blocking）</h4>\n<h6 id="-">“有东西阻止了屏幕上节点的实际绘制”。</h6>\n<p>优化网站的第一准则是让最重要的HTML和CSS尽可能快地传递到客户端。在成功绘制之前，必须构造DOM和CSSOM，因此HTML和CSS都是渲染阻塞资源。</p>\n<h4 id="javascript-">JavaScript如何执行</h4>\n<p> <img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/5.png?raw=true" alt="image">\n<strong>当浏览器遇到脚本标签时，DOM 构造就会暂停!</strong> 整个 DOM构建过程都将停止，直到脚本执行完成。这是因为 JavaScript 可以同时修改DOM和CSSOM。由于浏览器不确定特定的JavaScript会做什么，所以它采取的预防措施是停止整个DOM构造。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/6.png?raw=true" alt="image"></p>\n<h4 id="css-">CSS如何执行</h4>\n<p>当解析器遇到一个脚本标签而CSSOM还没有准备好时，Javascript执行将会停止，直到CSSOM就绪。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/7.png?raw=true" alt="image"></p>\n<p>DOM遇到脚本标签时会停止，但CSSOM不会发生这种情况。对于 CSSOM，JS执行会等待。没有CSSOM，就没有JS执行。</p>\n<h4 id="async-">async 属性</h4>\n<p>在默认情况下，每个脚本都是一个解析器阻断器！DOM 的构建总是会被打断。不过，有一种方法可以改变这种默认行为。如果将async关键字添加到脚本标签中，那么DOM构造就不会停止。DOM 构造将继续，脚本将在下载完成并准备就绪后执行。</p>\n<h4 id="-">关键渲染路径</h4>\n<p>从接收HTML、CSS和JS字节到将它们转换为屏幕上的像素之间的所有步骤。这整个过程称为<strong>关键渲染路径</strong>。优化网站性能就是优化关键渲染路径。</p>\n<p>一个经过良好优化的站点应该能够渐进式渲染，而不是让整个过程受阻。</p>\n'},Pt1D:function(t,n,e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var i=e("WK65"),o={render:function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("div",{staticClass:"indexBox"},[t._m(0),t._v(" "),e("div",{staticClass:"indexRight"},[e("div",{staticClass:"topBar"},[e("ul",{staticClass:"topBarUl"},t._l(t.topNav,function(n,i){return e("li",{key:i,class:{selected:t.topNavCurrent==i,topNavOption:!0},on:{click:function(n){t.switchTab(i)}}},[t._v(t._s(n.name))])}))]),t._v(" "),e("div",{staticClass:"leftContent"},[t.showDetails?e("div",{class:{selectedArticle:!0,animated:!0,fadeInRight:t.showDetails,fadeOutRight:!t.showDetails}},[e("div",{staticClass:"closeTap iconfont",on:{click:function(n){t.showDetails=!1}}},[t._v("")]),t._v(" "),e("div",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"content markdown-body",domProps:{innerHTML:t._s(t.currentDetails.route)}})]):t._e(),t._v(" "),t.showDetails?t._e():e("ul",{class:{contentWrtap:!0,animated:!0,fadeOutLeft:t.showDetails},attrs:{id:"contentWrtap"}},t._l(t.currentArrEssay,function(n,i){return e("li",{key:i,ref:"articleBrife",refInFor:!0,on:{click:function(e){t.showDetailsEvent(n)}}},[e("p",{staticClass:"title",domProps:{innerHTML:t._s(i+1+"."+n.titleValue)}}),t._v(" "),e("p",{staticClass:"details"},[t._v(t._s(n.brife))]),t._v(" "),t._m(1,!0)])})),t._v(" "),t.showDetails?t._e():e("div",{staticClass:"copyRight"},[t._v("Powered by GitHub Copyright "),e("br"),t._v("© 2018 - 2019 Haihong Cai All Rights Reserved. ")])]),t._v(" "),e("div",{staticClass:"rightNav"},[e("nav",{staticClass:"navList"},[e("ul",{staticClass:"navListContent"},[e("div",{staticClass:"leftLine"}),t._v(" "),t._l(t.topNavDetailsArr,function(n,i){return e("li",{key:i,staticClass:"smallTitle",on:{click:function(n){t.chooseArea(i)}}},[e("span",{class:{cicle:!0,cicleSelect:t.currentArea!=i}}),e("span",{staticClass:"num"},[t._v(t._s(i+1))]),t._v(" "),e("p",{staticClass:"smallTitleTxt smallTitleTxtActive"},[t._v(t._s(n))])])})],2)])])])])},staticRenderFns:[function(){var t=this,n=t.$createElement,i=t._self._c||n;return i("div",{staticClass:"indexLeft"},[i("div",{staticClass:"personInfor"},[i("img",{staticClass:"headImg",attrs:{src:e("uckV")}}),t._v(" "),i("div",{staticClass:"txtWrap"},[i("p",[i("span",{staticClass:"iconfont"},[t._v("")]),t._v(" 987136196")]),t._v(" "),i("p",[i("span",{staticClass:"iconfont"},[t._v("")]),t._v(" 15602266688")]),t._v(" "),i("p",[i("span",{staticClass:"iconfont"},[t._v("")]),t._v(" caihaihong6083@163.com")]),t._v(" "),i("div",{staticClass:"chatTool"},[i("a",{attrs:{href:"https://github.com/caihaihong"}},[i("span",{staticClass:"iconfont"},[t._v("")])]),t._v(" "),i("span",{staticClass:"iconfont wechat"},[t._v("")])])])]),t._v(" "),i("img",{staticClass:"bottomQoute",attrs:{src:e("qug8")}})])},function(){var t=this.$createElement,n=this._self._c||t;return n("p",{staticClass:"readMore"},[this._v("详细内容"),n("span",[this._v(">>")])])}]};var r=function(t){e("pfKk")},s=e("VU/8")(i.a,o,!1,r,"data-v-46fdd5e1",null);n.default=s.exports},Usms:function(t,n,e){"use strict";var i=e("d2dT"),o=e.n(i),r=e("6TGM"),s=e.n(r),a=e("ICs6"),l=e.n(a),c=e("J8US"),p=e.n(c),u=[{title:"计算机基础",route:o.a},{title:"计算机基础",route:p.a},{title:"计算机基础",route:l.a},{title:"计算机基础",route:p.a}],h=[{title:"算法与数据结构",route:o.a},{title:"算法与数据结构",route:l.a},{title:"算法与数据结构",route:p.a}],m=[{title:"编程语言",route:p.a},{title:"编程语言",route:s.a},{title:"编程语言",route:o.a},{title:"编程语言",route:s.a},{title:"编程语言",route:o.a}],g=(o.a,{title:[{name:"计算机",detailsArr:["计算机基础","算法与数据结构","计算机基础","编程语言"]},{name:"数学",detailsArr:["微积分","高数"]},{name:"读书笔记",detailsArr:["生活","书籍"]}],details:[{title:"计算机",article:[{content:u},{content:h},{content:u},{content:m}]},{title:"数学",article:[{content:u},{content:h}]},{title:"读书笔记",article:[{content:m},{content:h}]}]});n.a={essayContent:g}},WK65:function(t,n,e){"use strict";(function(t){var i=e("Usms"),o=e("HKE2"),r=e.n(o),s=e("h2j0");e.n(s);n.a={data:function(){return{topNav:i.a.essayContent.title,topNavDetailsArr:[],topNavCurrent:0,currentArrEssay:[],showDetails:!1,currentDetails:"",articleLength:{length:0,Arr:[]},isScroll:!1,currentArea:0}},computed:{},components:{showdown:r.a},mounted:function(){this.init(0)},methods:{switchTab:function(t){this.topNavCurrent=t,this.init(t)},showDetailsEvent:function(t){this.showDetails=!0,this.currentDetails=t},init:function(t){var n=this;n.currentArrEssay=[],n.articleLength.Arr=[],n.articleLength.Arr.push(0),n.articleLength.length=0;var e=new r.a.Converter;this.topNavDetailsArr=i.a.essayContent.title[t].detailsArr,i.a.essayContent.details[t].article.forEach(function(t,i){n.articleLength.length=n.articleLength.length+t.content.length,n.articleLength.Arr.push(t.content.length),t.content.forEach(function(n,i){var o=e.makeHtml(n.route.toString()),r=o.match("</(S*?)[^>]*>.*?");t.content[i].titleValue=o.slice(0,r.index)+r[0];var s=o.replace(/(<(\S*?)[^>]*>.*?)|\<.*?\>/g,"");o.slice(0,r.index).replace(/(<(\S*?)[^>]*>.*?)|\<.*?\>/g,"").length;t.content[i].brife=s.slice(7,150)+"..."}),n.currentArrEssay=n.currentArrEssay.concat(t.content)}),this.$nextTick(function(){document.getElementById("contentWrtap").scrollTop=0,document.getElementById("contentWrtap").addEventListener("scroll",n.handleScroll);document.getElementById("contentWrtap").clientHeight;var t=document.getElementById("contentWrtap").scrollHeight/n.articleLength.length;n.articleLength.Arr.forEach(function(e,i){n.articleLength.Arr[i]=0==i?e*t:e*t+n.articleLength.Arr[i-1]})})},handleScroll:function(){if(!this.isScroll){this.isScroll=!0;var t=document.getElementById("contentWrtap").scrollTop,n=this.binarySearch(this.articleLength.Arr,t,0,this.articleLength.Arr.length-1);this.currentArea=n,n<0&&(this.currentArea=0),n>this.articleLength.Arr.length-2&&(this.currentArea=this.articleLength.Arr.length-2),this.isScroll=!1}},binarySearch:function(t,n,e,i){if(console.log("数组",t,n,e,i),console.log("滚动条",n),console.log("坐标",e,i),e>i)return e;var o=Math.floor((e+i)/2),r=t[o];return r>n?this.binarySearch(t,n,e,o-1):r<n?this.binarySearch(t,n,o+1,i):o},chooseArea:function(n){document.getElementById("contentWrtap").scrollTop;console.log(document.getElementById("contentWrtap").scrollTop),console.log(this.articleLength.Arr[n]),t("#contentWrtap").animate({scrollTop:this.articleLength.Arr[n]},500)}}}}).call(n,e("7t+N"))},d2dT:function(t,n){t.exports='<h4 id="-base64-">图片base64编码</h4>\n<p>图片数据编码成一串字符串（图片的所有信息，图片越复杂，字符串越长）</p>\n<h5 id="-">意义</h5>\n<ul>\n<li>减少HTTP请求</li>\n<li>没有跨域问题，无需考虑缓存、文件头或者cookies问题  <h5 id="-">使用</h5>\n</li>\n<li>图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新。<h5 id="-">缺点</h5>\n</li>\n<li>CSS体积变大→CRP关键渲染路径阻塞(Critical Rendering Path)→用户长时间看到白屏</li>\n</ul>\n'},pfKk:function(t,n){},qug8:function(t,n,e){t.exports=e.p+"static/img/qoute.1e11a83.png"},uckV:function(t,n,e){t.exports=e.p+"static/img/headImg.8ffd7ef.jpg"}});
//# sourceMappingURL=0.0d1b184930d758af71e8.js.map