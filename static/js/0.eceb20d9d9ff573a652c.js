webpackJsonp([0],{"+E39":function(n,t,i){n.exports=!i("S82l")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},"+ZMJ":function(n,t,i){var e=i("lOnJ");n.exports=function(n,t,i){if(e(n),void 0===t)return n;switch(i){case 1:return function(i){return n.call(t,i)};case 2:return function(i,e){return n.call(t,i,e)};case 3:return function(i,e,l){return n.call(t,i,e,l)}}return function(){return n.apply(t,arguments)}}},"+rWJ":function(n,t){n.exports='<h4 id="-">回调函数</h4>\n<pre><code>    function fn(b){\n    var a = 1;\n        b(a);\n    };\n    fn(function(b){\n        console.log(b);\n    });</code></pre>'},"+tPU":function(n,t,i){i("xGkn");for(var e=i("7KvD"),l=i("hJx8"),o=i("/bQp"),a=i("dSzd")("toStringTag"),r="CSSRuleList,CSSStyleDeclaration,CSSValueList,ClientRectList,DOMRectList,DOMStringList,DOMTokenList,DataTransferItemList,FileList,HTMLAllCollection,HTMLCollection,HTMLFormElement,HTMLSelectElement,MediaList,MimeTypeArray,NamedNodeMap,NodeList,PaintRequestList,Plugin,PluginArray,SVGLengthList,SVGNumberList,SVGPathSegList,SVGPointList,SVGStringList,SVGTransformList,SourceBufferList,StyleSheetList,TextTrackCueList,TextTrackList,TouchList".split(","),p=0;p<r.length;p++){var s=r[p],c=e[s],u=c&&c.prototype;u&&!u[a]&&l(u,a,s),o[s]=o.Array}},"/+Ud":function(n,t){n.exports='<h2 id="java-">Java 基础语法</h2>\n<p>一个Java程序可以认为是一系列对象的集合，而这些对象通过调用彼此的方法来协同工作。</p>\n<ul>\n<li>对象：对象是类的一个实例，有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</li>\n<li>类：类是一个模板，它描述一类对象的行为和状态。</li>\n<li>方法：方法就是行为，一个类可以有很多方法。逻辑运算、数据修改以及所有动作都是在方法中完成的。</li>\n<li>实例变量：每个对象都有独特的实例变量，对象的状态由这些实例变量的值决定。</li>\n</ul>\n<h3 id="-">基本语法</h3>\n<p>编写Java程序时，应注意以下几点：</p>\n<ul>\n<li>大小写敏感：Java是大小写敏感的，这就意味着标识符Hello与hello是不同的。</li>\n<li>类名：对于所有的类来说，类名的首字母应该大写。如果类名由若干单词组成，那么每个单词的首字母应该大写，例如 MyFirstJavaClass 。</li>\n<li>方法名：所有的方法名都应该以小写字母开头。如果方法名含有若干单词，则后面的每个单词首字母大写。</li>\n<li>源文件名：源文件名必须和类名相同。当保存文件的时候，你应该使用类名作为文件名保存（切记Java是大小写敏感的），文件名的后缀为.java。（如果文件名和类名不相同则会导致编译错误）。</li>\n<li>主方法入口：所有的Java 程序由public static void main(String []args)方法开始执行。</li>\n</ul>\n<h4 id="java-">Java标识符</h4>\n<p>Java所有的组成部分都需要名字。<strong>类名、变量名以及方法名都被称为标识符。</strong></p>\n<p>关于Java标识符，有以下几点需要注意：</p>\n<ul>\n<li>所有的标识符都应该以字母（A-Z或者a-z）,美元符（$）、或者下划线（_）开始</li>\n<li>首字符之后可以是字母（A-Z或者a-z）,美元符（$）、下划线（_）或数字的任何字符组合</li>\n<li>关键字不能用作标识符</li>\n<li>标识符是大小写敏感的</li>\n<li>合法标识符举例：age、$salary、<em>value、__1</em>value</li>\n<li>非法标识符举例：123abc、-salary</li>\n</ul>\n<h4 id="java-">Java修饰符</h4>\n<p>像其他语言一样，Java可以使用修饰符来修饰类中方法和属性。主要有两类修饰符：</p>\n<ul>\n<li>访问控制修饰符 : default, public , protected,private</li>\n<li>非访问控制修饰符 : final, abstract, static, synchronized</li>\n</ul>\n<h4 id="java-">Java变量</h4>\n<p>Java中主要有如下几种类型的变量</p>\n<ul>\n<li>局部变量</li>\n<li>类变量（静态变量）</li>\n<li>成员变量（非静态变量）</li>\n</ul>\n<h4 id="java-">Java数组</h4>\n<p>数组是储存在堆上的对象，可以保存多个同类型变量。</p>\n<h4 id="java-">Java枚举</h4>\n<p>Java 5.0引入了枚举，枚举限制变量只能是预先设定好的值。使用枚举可以减少代码中的bug。</p>\n<p>例如，我们为果汁店设计一个程序，它将限制果汁为小杯、中杯、大杯。这就意味着它不允许顾客点除了这三种尺寸外的果汁。</p>\n<h4 id="java-">Java 关键字</h4>\n<p>下面列出了Java 关键字。这些保留字不能用于常量、变量、和任何标识符的名称。</p>\n<ul>\n<li>访问控制<ul>\n<li>private 私有的</li>\n<li>protected 受保护的</li>\n<li>public 公共的</li>\n</ul>\n</li>\n<li>类、方法、变量修饰符<ul>\n<li>abstract 声明抽象 （继承）</li>\n<li>class 类</li>\n<li>extends 继承（抽象）</li>\n<li>final 不可改变值</li>\n<li>implements 实现（接口）</li>\n<li>interface 接口</li>\n<li>native 本地，原生方法</li>\n<li>new 创建</li>\n<li>static 静态</li>\n<li>strictfp 严格</li>\n<li>synchronized 线程、同步</li>\n<li>translent 短暂</li>\n<li>volatile 易失</li>\n</ul>\n</li>\n<li>程序控制语句<ul>\n<li>break 跳出循环</li>\n<li>case </li>\n<li>continue</li>\n<li>default</li>\n<li>do</li>\n<li>else</li>\n<li>for</li>\n<li>if</li>\n<li>instanceof</li>\n<li>return </li>\n<li>switch</li>\n<li>while</li>\n</ul>\n</li>\n<li>错误处理<ul>\n<li>assert 断言表达式是否为真</li>\n<li>catch 捕捉异常</li>\n<li>finally 有没有异常都执行</li>\n<li>throw 抛出一个异常对象</li>\n<li>throws 声明一个异常可能被抛出</li>\n<li>try 捕获异常</li>\n</ul>\n</li>\n<li>包相关<ul>\n<li>import 引入</li>\n<li>package 包</li>\n</ul>\n</li>\n<li>基本类型<ul>\n<li>boolean</li>\n<li>byte 字节</li>\n<li>char 字符</li>\n<li>double</li>\n<li>float</li>\n<li>int </li>\n<li>long</li>\n<li>short</li>\n</ul>\n</li>\n<li>变量引用<ul>\n<li>super 父类 超类</li>\n<li>this 本类</li>\n<li>void 无返回值</li>\n</ul>\n</li>\n<li>保留关键字<ul>\n<li>goto </li>\n<li>const</li>\n<li>null</li>\n</ul>\n</li>\n</ul>\n<h4 id="-">继承</h4>\n<p>在Java中，一个类可以由其他类派生。如果你要创建一个类，而且已经存在一个类具有你所需要的属性或方法，那么你可以将新创建的类继承该类。</p>\n<p>利用继承的方法，可以重用已存在类的方法和属性，而不用重写这些代码。被继承的类称为超类（super class），派生类称为子类（subclass）。</p>\n<h4 id="-">接口</h4>\n<p>在Java中，接口可理解为对象间相互通信的协议。接口在继承中扮演着很重要的角色。</p>\n<p>接口只定义派生要用到的方法，但是方法的具体实现完全取决于派生类。</p>\n<h4 id="java-">Java 源程序与编译型运行区别</h4>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/1.png?raw=true" alt="image"></p>\n'},"//Fk":function(n,t,i){n.exports={default:i("U5ju"),__esModule:!0}},"/bQp":function(n,t){n.exports={}},"1AS0":function(n,t){n.exports='<h4 id="vue-">Vue源码学习</h4>\n<pre><code>\n&lt;body&gt;\n    &lt;!-- 极简双向绑定 --&gt;\n    &lt;input type=&quot;text&quot; id=&quot;a&quot;&gt;\n    &lt;span id=&quot;b&quot;&gt;&lt;/span&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;\n&lt;script&gt;\n    //访问器属性\n    // 通过defineProperty方法定义\n    //  Vue 实现双向绑定的基本原理\n    //  model =&gt; view 以及 view =&gt; model 的双向绑定。\n    var obj = {};\n    Object.defineProperty(obj, &quot;hello&quot;, {\n        get: function () {\n            console.log(&quot;get-this→obj&quot;, this)\n            console.log(&quot;get方法被調用&quot;)\n        },\n        set: function (newVal) {\n            console.log(&quot;set-this→obj&quot;, this)\n            console.log(&quot;set方法被調用&quot;, 123)\n            document.getElementById(&#39;a&#39;).value = newVal;\n            document.getElementById(&#39;b&#39;).innerHTML = newVal;\n        }\n    })\n    console.log(&quot;obj&quot;, obj);\n    obj.hello;\n    document.addEventListener(&quot;keyup&quot;, (e) =&gt; {\n        obj.hello = e.target.value;\n    });\n&lt;/script&gt;</code></pre><h4 id="vue-index-js">Vue 源碼入口文件index.js</h4>\n<pre><code>import { initMixin } from &#39;./init&#39;\nimport { stateMixin } from &#39;./state&#39;\nimport { renderMixin } from &#39;./render&#39;\nimport { eventsMixin } from &#39;./events&#39;\nimport { lifecycleMixin } from &#39;./lifecycle&#39;\nimport { warn } from &#39;../util/index&#39;\n\nfunction Vue (options) {\n  if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp;\n    !(this instanceof Vue)) {\n    warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;)\n  }\n  this._init(options)  \n}\n\ninitMixin(Vue) \nstateMixin(Vue)\neventsMixin(Vue)\nlifecycleMixin(Vue)\nrenderMixin(Vue)\n\nexport default Vue</code></pre><pre><code>&lt;script&gt;\n    //prototype属性:向对象添加属性和方法\n    //给myfunc方法对象添加_init这个方法。（自执行）\n    myfunction.prototype._init = function (param) {\n        console.log(param)\n    }\n    function myfunction() {\n        console.log(this, &quot;当前this指向&quot;)       //myfunction这个方法对象\n        console.log(this instanceof myfunction) //true\n        this._init(&quot;执行_init方法&quot;)             //执行_init方法\n    }\n    var myfunc = new myfunction()\n&lt;/script&gt;</code></pre><h4 id="this-_init-options-">this._init(options)这个方法执行一下内容</h4>\n<pre><code>export function initMixin (Vue: Class&lt;Component&gt;) {\n  Vue.prototype._init = function (options?: Object) {\n    const vm: Component = this\n    // a uid\n    vm._uid = uid++\n    // a flag to avoid this being observed\n    vm._isVue = true\n    // merge options\n    if (options &amp;&amp; options._isComponent) {\n      // optimize internal component instantiation\n      // since dynamic options merging is pretty slow, and none of the\n      // internal component options needs special treatment.\n      initInternalComponent(vm, options)\n    } else {\n      vm.$options = mergeOptions(\n        resolveConstructorOptions(vm.constructor),\n        options || {},\n        vm\n      )\n    }\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== &#39;production&#39;) {\n      initProxy(vm)\n    } else {\n      vm._renderProxy = vm\n    }\n    // expose real self\n    vm._self = vm\n    initLifecycle(vm)\n    initEvents(vm)\n    initRender(vm)\n    callHook(vm, &#39;beforeCreate&#39;)\n    initState(vm)\n    callHook(vm, &#39;created&#39;)\n    if (vm.$options.el) {\n      vm.$mount(vm.$options.el)\n    }\n  }\n}</code></pre>'},"2KxR":function(n,t){n.exports=function(n,t,i,e){if(!(n instanceof t)||void 0!==e&&e in n)throw TypeError(i+": incorrect invocation!");return n}},"2W1O":function(n,t){n.exports='<h4 id="-">专有名词</h4>\n<ul>\n<li>parameter   美 [pə&#39;ræmɪtər]    参数</li>\n<li>module     美[ˈmɑ:dʒul]    模块</li>\n<li>mutations   美[mjuˈteʃən]   变化</li>\n<li>handler          美[ˈhændlɚ] 处理者</li>\n<li>commit       美[kəˈmɪt]   提交</li>\n<li>navigation 导航 美[ˌnævɪˈɡeʃən]</li>\n<li>guard  守卫</li>\n<li>mode  美[moʊd] 方式; 状况</li>\n<li>Terminal 美[ˈtɜ:rmɪnl]  终端      命令行（终端）；终端也称终端设备，是计算机网络中处于网络最外围的设备，主要用于用户信息的输入以及处理结果的输出等。</li>\n<li>Syntactic sugar   美[sɪnˈtæktɪk]   语法糖  指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。</li>\n<li>slot 美[slɑ:t]   插槽</li>\n<li>compile  美[kəmˈpaɪl]   编译</li>\n<li>identifier     英[aɪˈdentɪfaɪə(r)]   识别符</li>\n<li>CDN </li>\n<li>DNS Domain[&#39;dʌmi:ən] Name System域名系统 “Google Chrome 浏览器”等现代浏览器还采用了一种称为“DNS 预解析”的技术，可以更快地抓取和载入网页。通过 DNS 查找将网址转换为 IP 地址的过程称为“解析”，反之则称为“反向解析”。“Chrome 浏览器”会通过 DNS 预解析同时查找网页上的其他所有链接，并在后台将这些链接预解析为 IP 地址。因此，当您实际点击网页上的某个链接后，浏览器就能立即将您转到新的网页</li>\n<li>GL：Graphics Library</li>\n<li>HTTP HyperText Transfer Protocal 超文本传输协议是一个定义客户端和服务器间交流的==语言==的协议 HTTP是一个位于通信协议之上的应用程序协议。</li>\n<li>server:服务端 存储网页或者应用的计算机</li>\n<li>client：客户端 用户入网的设备或者联网的软件或程序</li>\n<li>TCP/IP：Transmission Control Protocol/Internet Protocol 传输控制协议和因特网互连协议是定义==数据==如何传输的通信协议</li>\n<li>组成文件：代码、资源</li>\n<li>cd change directory 改变目录</li>\n<li>calc calculate 计算</li>\n<li>flex  Flexible Box弹性布局</li>\n<li>reverse [rɪˈvɜ:rs] 反转</li>\n<li>justify [ˈdʒʌstəˌfaɪ] </li>\n<li>device pixels </li>\n<li>CSS pixels</li>\n<li>ppi/dpi pixeld per inch</li>\n<li>dpr (devicepixelRatio) [reɪʃioʊ]</li>\n<li>ul: unordered lists</li>\n<li>ol: ordered lists</li>\n<li>li: list item</li>\n<li>repository：/rɪˈpɑː.zɪ.tɔːr.i/ 知识库</li>\n<li>fragment 片段</li>\n<li>RegEx </li>\n<li>notify:通知</li>\n<li>babel:ˈbebəl</li>\n<li>token：象征，标记</li>\n<li>fundamentals：原理，基本法则</li>\n<li>Symmetric：[sɪ&#39;metrɪk] 相称性的，均衡的;</li>\n<li>cryptography:[krɪpˈɑ:grəfi] 密码使用法</li>\n<li>encryption：[ɪn&#39;krɪpʃn] 加密</li>\n<li>decryption：[di:&#39;krɪpʃn] 解密</li>\n<li>ssh： secure shell </li>\n<li>DNS：Domain Name System 域名系统 </li>\n<li>synchronize /ˈsɪŋ.krə.naɪz/</li>\n<li>enumerate /ɪˈnjuː.mə.reɪt/ </li>\n<li></li>\n</ul>\n'},"3Eo+":function(n,t){var i=0,e=Math.random();n.exports=function(n){return"Symbol(".concat(void 0===n?"":n,")_",(++i+e).toString(36))}},"3fs2":function(n,t,i){var e=i("RY/4"),l=i("dSzd")("iterator"),o=i("/bQp");n.exports=i("FeBl").getIteratorMethod=function(n){if(void 0!=n)return n[l]||n["@@iterator"]||o[e(n)]}},"4mcu":function(n,t){n.exports=function(){}},"52gC":function(n,t){n.exports=function(n){if(void 0==n)throw TypeError("Can't call method on  "+n);return n}},"6JEg":function(n,t){n.exports='<h4 id="-springbootapplication">@SpringBootApplication</h4>\n<ul>\n<li>开启Spring Boot的自动配置</li>\n<li>@SpringBootConfiguration、@EnableAutoConfiguration以及@ComponentScan三个注解的组合<ul>\n<li>@SpringBootConfiguration：配置类</li>\n<li>@EnableAutoConfiguration：根据类路径中的jar包依赖为当前项目进行自动配置</li>\n<li>@ComponentScan：扫描包的类<h4 id="javabean-">javaBean 实体类关系</h4>\nJavaBean就是一种特殊的实体类 \n它有一系列set和get方法对私有变量进行操作 </li>\n</ul>\n</li>\n</ul>\n<h4 id="application-properties-">application.properties使用</h4>\n<pre><code>声明\nbook.author=罗贯中\nbook.name=三国演义\n注入\n@Value(value = &quot;${book.author}&quot;)\n    private String bookAuthor;\n@Value(value = &quot;${book.name}&quot;)\n    private String bookname;\n\n类型安全配置 \n//book.properties\nbook.name=红楼梦\nbook.author=曹雪芹\nbook.price=28\n//BookBean.java\n@Component\n@ConfigurationProperties(prefix = &quot;book&quot;,locations = &quot;classpath:book.properties&quot;)\npublic class BookBean {\n    private String name;\n    private String author;\n    private String price;\n}\n//controller Bean注入\n@Autowired\n    private BookBean bookBean;</code></pre><h4 id="-">日志配置</h4>\n<pre><code>logging.file=/home/sang/workspace/log.log\nlogging.level.org.springframework.web=debug</code></pre>'},"6jaS":function(n,t){n.exports='<h4 id="-">浏览器缓存</h4>\n<h5 id="-">什么是缓存？</h5>\n<p>缓存是一种可以自动保存常见资源副本并且可以在下次请求中直接使用副本而非再次获取的技术。\n首次请求资源后，服务器返回资源给客户端的同时，缓存服务器或者本地缓存也会保存一份资源副本（在允许缓存的情况下）当再次请求时，则会直接使用资源副本而不从原始服务器再次请求文档。</p>\n<h5 id="-">缓存的优点</h5>\n<ul>\n<li>以减少冗余的数据传输</li>\n<li>缓解网络瓶颈的问题</li>\n<li>降低对原始服务器的要求</li>\n<li>降低请求距离的时延</li>\n</ul>\n<h5 id="-">数据的冗余传输</h5>\n<p>当很多客户端访问同一份文档的时候，原始服务器一遍又一遍地返回的不同的客户端相同的内容，这些重复的文档造成了数据的冗余传输</p>\n<h5 id="-">网络瓶颈的问题</h5>\n<p>客户端访问代理服务器的速度一般比直接访问原始服务器快速（带宽大，延时低）</p>\n<h5 id="-">降低原始服务器的要求</h5>\n<p>多客户端同时访问原始服务器，容易造成服务器崩溃，缓存可以一定程度降低对原始服务器的压力</p>\n<h5 id="-">降低请求距离时延</h5>\n<p>物理上的距离，也是降低we性能的一个方面客户端服务器距离越近，请求速度越快</p>\n<h6 id="-">缓存命中</h6>\n<p>如果某个请求是由已缓存的副本提供的，则成为缓存命中</p>\n<h6 id="-">缓存未命中</h6>\n<p>缓存没有可用的缓存副本或者缓存已经过期，则会将请求转发至原始的服务器，称为缓存未命中</p>\n<h5 id="-">新鲜度检测</h5>\n<p>HTTP通过缓存将服务器文档的副本保留一段没时间，在这段时间内，都认为文档是“新鲜的”，缓存可以在不联系服务器的情况下，直接提供该文档。但是一缓存的副本停留时间太长，超过文档的新鲜度限值（Freshness limit),就认为对象“过时”了，在提供该文档之前，缓存要再次与服务器确认，以查看文档是否发生了变化</p>\n<h5 id="-">再验证</h5>\n<p>缓存检测原始服务器文档是否变化，查看缓存版本是否为最新版本</p>\n<h5 id="-">再验证命中和再验证未命中</h5>\n<p>缓存对缓存的副本进行再验证时，会向原始服务器发送一个再验证请求，如果内容没有发生变化，服务器会以304 Not Modified进行响应。这被称作是再验证命中或者缓慢命中。如果内容发生了变化，服务器会以200进行响应。这被称作再验证未命中。</p>\n<h5 id="-">缓存的处理步骤</h5>\n<ol>\n<li>首先是当用户请求资源时，会判断是否有缓存，如果没有，则会向原服务器请求资源。</li>\n<li>如果有缓存，则会进入强缓存的范畴，判断缓存是否新鲜，如果缓存新鲜，则会直接返回缓存副本给客户端。如果缓存不新鲜了，则表示强缓存失败，将会进入到协商缓存。</li>\n<li>协商缓存将判断是否存在Etag和Last-Modified首部，通过这些首部验证资源是否发生过变化，如果未发生变化，则表示命中了协商缓存，会重定向到缓存副本，将资源返回给客户端，</li>\n<li>否则的话表示协商缓存未命中，服务器会返回新的资源。</li>\n</ol>\n<h4 id="-">强缓存协商和协商缓存</h4>\n<h5 id="-">强缓存</h5>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/cache/4.png?raw=true" alt="image">\n服务端告知客户端缓存时间后，由客户端判断并决定是否使用缓存。即首次发起请求时，服务端会在Response Headers 中写入缓存新鲜时间。当请求再次发出时，如果缓存新鲜，将直接从缓存获取资源，而不会再与服务器发生通信。</p>\n<h5 id="-">协商缓存</h5>\n<p>由服务端决定并告知客户端是否使用缓存。协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。</p>\n<h5 id="-">强缓存实现原理</h5>\n<p>强缓存是通过Expires[ɪkˈspaɪr]首部或Cache[kæʃ]-Control: max-age来实现的。</p>\n<p>Expires 和 Cache-Control: max-age都是用来标识资源的过期时间的首部。\nExpires描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示。\n由于expires是一个绝对时间，如果人为的更改时间，会对缓存的有效期造成影响，使缓存有效期的设置失去意义。因此在http1.1中我们有了expires的完全替代首部cache-control：max-age\nmax-age值是一个相对时间，它定义了文档的最大使用期——从第一次生成文档到文档不再新鲜、无法使用为止，最大的合法生存时间(以秒为单位)。</p>\n<p>当我们首次请求资源时，服务器在返回资源的同时，会在Response Headers中写入expires首部或cache-control，标识缓存的过期时间，缓存副本会将该部分信息保存起来。\n当再次请求该资源的时候，缓存会对date(Date 是一个通用首部，表示原始服务器消息发出的时间。即表示的是首次请求某个资源的时间。)和expires/cache-control的时间进行对比，从而判断缓存副本是否足够新鲜。</p>\n<h5 id="-">协商缓存实现原理</h5>\n<p>协商缓存是通过请求头Last-Modified或Etag来实现的。\nLast-Modified 标识的是文档最后修改时间，Etag 则是以文档内容来进行编码的。</p>\n<ol>\n<li>首次请求资源时，服务器在返回资源的同时，会在Response Headers中写入Last-Modified首部，表示该资源在服务器上的最后修改时间。</li>\n<li>当再次请求该资源时，会在Request Headers 中写入If-Modified-Since首部，此时的If-Modified-Since的值是首次请求资源时所返回的Last-Modified的值。</li>\n<li>服务器接收到请求后，会根据If-Modified-Since的值判断资源在该日期之后是否发生过变化。</li>\n<li>如果没有，则会返回304 Not Modified;如果变化了，则会返回变化过后的资源，同时更新Last-Modified的值。</li>\n</ol>\n<h5 id="last-modified-">Last-Modified存在的一些问题</h5>\n<p>有些文档可能会被周期性地重写，但实际包含的数据常常是一样的。尽管内容没有变化，但修改日期会发生变化。\n有些文档可能被修改了，但所做修改并不重要，不需要让缓存重载数据(比如对拼写或注释的修改)。\n有些服务器提供的文档会在亚秒间隙发生变化(比如，实时监视器)，对这些服务器来说，以一秒为粒度的修改日期可能就不够用了。\n通过这些描述，我们可以总结出一些Last-Modified存在的缺陷：</p>\n<p>无法感知文件内容是否真的发生了变化。\n不该重新请求的时候，也会重新请求。\n在秒以下的内容变化无法感知到。\n该重新请求的时候，反而没有重新请求。</p>\n<p>对于上述问题，Etag作为Last-Modified的补充而出现，Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，因此 Etag 能够精准地感知文件的变化。</p>\n<h5 id="etag-">Etag 强验证器和弱验证器</h5>\n<p>ETag 分为强验证器和弱验证器。</p>\n<ul>\n<li>强验证器：要求文档的每个字节都相等</li>\n<li>弱验证器：只要求文档的含义相等。</li>\n</ul>\n<h5 id="cache-control-">Cache-Control请求头常用属性说明</h5>\n<h5 id="max-age-s-maxage">max-age/s-maxage</h5>\n<p>s-maxage指令的功能和max-age是相同的，它们唯一的不同点就在于s-maxage指令只适用于代理服务器缓存。s-maxage的优先级高于max-age。</p>\n<h5 id="public-private">public/private</h5>\n<p>public 与 private 是针对资源是否能够被代理服务缓存而存在的一组对立概念。\n如果我们为资源设置了 public，那么它既可以被浏览器缓存，也可以被代理服务器缓存；如果我们设置了 private，则该资源只能被浏览器缓存。</p>\n<h5 id="no-cache-no-store">no-cache/no-store</h5>\n<p>no-cache 表示客户端要求缓存在提供其已缓存的副本之前必须先和原始服务器对该文档进行验证。即强制跳过强缓存阶段，直接进行协商缓存。强缓存并不能知道缓存是否真的足够新鲜，使用no-cache就是为了防止从缓存中返回过期的资源，对缓存进行再验证。\nno-store表示的是禁止缓存，即每一次都是直接与原服务器进行通信，从原服务器返回资源。一般设置了no-store的资源，都暗示着该资源具有敏感性信息。</p>\n'},"77Pl":function(n,t,i){var e=i("EqjI");n.exports=function(n){if(!e(n))throw TypeError(n+" is not an object!");return n}},"7KvD":function(n,t){var i=n.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=i)},"7MOu":function(n,t){n.exports='<h4 id="link-import-css">link和@import CSS</h4>\n<h5 id="css-">CSS选择器权重</h5>\n<p>!important &gt; 行内样式 &gt; ID &gt; 类、伪类、属性 &gt; 标签名 &gt; 继承 &gt; 通配符</p>\n<h4 id="-">区别</h4>\n<ul>\n<li>@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。</li>\n<li>加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</li>\n<li>@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。</li>\n<li>可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</li>\n<li>在link标签引入的 CSS 文件中使用@import时，相同样式将被该 CSS 文件本身的样式层叠。</li>\n</ul>\n'},"7xGw":function(n,t){n.exports='<h2 id="spring">Spring</h2>\n<p>Spring是分层的javaSE/EE应用full-stack轻量级开源框架，以IOC(Inverse Of Control:控制反转)和AOP(Aspect Oriented Programming:面向切面编程)为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多企业级应用技术，也整合了众多著名的第三方框架和类库。</p>\n<ul>\n<li>IOC（xml、注解）</li>\n<li>AOP</li>\n<li>jdbcTemplate</li>\n<li>SSH整合</li>\n</ul>\n<h4 id="-">依赖</h4>\n<ul>\n<li>开发遵循的原则：编译不依赖，运行才依赖。</li>\n<li>解决依赖关系：使用反射创建类对象</li>\n<li>使用反射类引发的问题：使用配置文件来反射创建对象</li>\n</ul>\n'},"82Mu":function(n,t,i){var e=i("7KvD"),l=i("L42u").set,o=e.MutationObserver||e.WebKitMutationObserver,a=e.process,r=e.Promise,p="process"==i("R9M2")(a);n.exports=function(){var n,t,i,s=function(){var e,l;for(p&&(e=a.domain)&&e.exit();n;){l=n.fn,n=n.next;try{l()}catch(e){throw n?i():t=void 0,e}}t=void 0,e&&e.enter()};if(p)i=function(){a.nextTick(s)};else if(!o||e.navigator&&e.navigator.standalone)if(r&&r.resolve){var c=r.resolve(void 0);i=function(){c.then(s)}}else i=function(){l.call(e,s)};else{var u=!0,h=document.createTextNode("");new o(s).observe(h,{characterData:!0}),i=function(){h.data=u=!u}}return function(e){var l={fn:e,next:void 0};t&&(t.next=l),n||(n=l,i()),t=l}}},"880/":function(n,t,i){n.exports=i("hJx8")},"8JNt":function(n,t){n.exports='<h3 id="java-">Java 简介</h3>\n<p>Java是由Sun Microsystems公司于1995年5月推出的Java面向对象程序设计语言和Java平台的总称。由James Gosling和同事们共同研发，并在1995年正式推出。</p>\n<h5 id="java-">Java分为三个体系：</h5>\n<ul>\n<li>JavaSE（J2SE）（Java2 Platform Standard Edition，java平台标准版）</li>\n<li>JavaEE(J2EE)(Java 2 Platform,Enterprise Edition，java平台企业版)</li>\n<li>JavaME(J2ME)(Java 2 Platform Micro Edition，java平台微型版)。</li>\n</ul>\n<p>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名以取消其中的数字&quot;2&quot;：J2EE更名为Java EE, J2SE更名为Java SE，J2ME更名为Java ME。</p>\n<h4 id="-">主要特性</h4>\n<ul>\n<li>Java语言是简单的：Java语言的语法与C语言和C++语言很接近，使得大多数程序员很容易学习和使用。另一方面，Java丢弃了C++中很少使用的、很难理解的、令人迷惑的那些特性，如操作符重载、多继承、自动的强制类型转换。特别地，Java语言不使用指针，而是引用。并提供了自动的废料收集，使得程序员不必为内存管理而担忧。</li>\n<li>Java语言是面向对象的：Java语言提供类、接口和继承等面向对象的特性，为了简单起见，只支持类之间的单继承，但支持接口之间的多继承，并支持类与接口之间的实现机制（关键字为implements）。Java语言全面支持动态绑定，而C++语言只对虚函数使用动态绑定。总之，Java语言是一个纯的面向对象程序设计语言。</li>\n<li>Java语言是分布式的：Java语言支持Internet应用的开发，在基本的Java应用编程接口中有一个网络应用编程接口（java net），它提供了用于网络应用编程的类库，包括URL、URLConnection、Socket、ServerSocket等。Java的RMI（远程方法激活）机制也是开发分布式应用的重要手段。</li>\n<li>Java语言是健壮的：Java的强类型机制、异常处理、垃圾的自动收集等是Java程序健壮性的重要保证。对指针的丢弃是Java的明智选择。Java的安全检查机制使得Java更具健壮性。</li>\n</ul>\n<p>Java语言是安全的：Java通常被用在网络环境中，为此，Java提供了一个安全机制以防恶意代码的攻击。除了Java语言具有的许多安全特性以外，Java对通过网络下载的类具有一个安全防范机制（类ClassLoader），如分配不同的名字空间以防替代本地的同名类、字节代码检查，并提供安全管理机制（类SecurityManager）让Java应用设置安全哨兵。</p>\n<ul>\n<li>Java语言是体系结构中立的：Java程序（后缀为java的文件）在Java平台上被编译为体系结构中立的字节码格式（后缀为class的文件），然后可以在实现这个Java平台的任何系统中运行。这种途径适合于异构的网络环境和软件的分发。</li>\n<li>Java语言是可移植的：这种可移植性来源于体系结构中立性，另外，Java还严格规定了各个基本数据类型的长度。Java系统本身也具有很强的可移植性，Java编译器是用Java实现的，Java的运行环境是用ANSI C实现的。</li>\n<li>Java语言是解释型的：\n如前所述，Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行，执行过程中需要的类在联接阶段被载入到运行环境中。</li>\n<li>Java是高性能的：与那些解释型的高级脚本语言相比，Java的确是高性能的。事实上，Java的运行速度随着JIT(Just-In-Time）编译器技术的发展越来越接近于C++。</li>\n<li>Java语言是多线程的：\n在Java语言中，线程是一种特殊的对象，它必须由Thread类或其子（孙）类来创建。通常有两种方法来创建线程：其一，使用型构为Thread(Runnable)的构造子将一个实现了Runnable接口的对象包装成一个线程，其二，从Thread类派生出子类并重写run方法，使用该子类创建的对象即为线程。值得注意的是Thread类已经实现了Runnable接口，因此，任何一个线程均有它的run方法，而run方法中包含了线程所要运行的代码。线程的活动由一组方法来控制。Java语言支持多个线程的同时执行，并提供多线程之间的同步机制（关键字为synchronized）。</li>\n<li>Java语言是动态的：Java语言的设计目标之一是适应于动态变化的环境。Java程序需要的类能够动态地被载入到运行环境，也可以通过网络来载入所需要的类。这也有利于软件的升级。另外，Java中的类有一个运行时刻的表示，能进行运行时刻的类型检查。</li>\n</ul>\n<h4 id="-">发展历史</h4>\n<ul>\n<li>1995年5月23日，Java语言诞生</li>\n<li>1996年1月，第一个JDK-JDK1.0诞生</li>\n<li>1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术</li>\n<li>1996年9月，约8.3万个网页应用了JAVA技术来制作</li>\n<li>1997年2月18日，JDK1.1发布</li>\n<li>1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录</li>\n<li>1997年9月，JavaDeveloperConnection社区成员超过十万</li>\n<li>1998年2月，JDK1.1被下载超过2,000,000次</li>\n<li>1998年12月8日，JAVA2企业平台J2EE发布</li>\n<li>1999年6月，SUN公司发布Java的三个版本：标准版（JavaSE,以前是J2SE）、企业版（JavaEE以前是J2EE）和微型版（JavaME，以前是J2ME）</li>\n<li>2000年5月8日，JDK1.3发布</li>\n<li>2000年5月29日，JDK1.4发布</li>\n<li>2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机</li>\n<li>2001年9月24日，J2EE1.3发布</li>\n<li>2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升</li>\n<li>2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0</li>\n<li>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字&quot;2&quot;：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME</li>\n<li>2006年12月，SUN公司发布JRE6.0</li>\n<li>2009年04月20日，甲骨文74亿美元收购Sun。取得java的版权。</li>\n<li>2010年11月，由于甲骨文对于Java社区的不友善，因此Apache扬言将退出JCP[4]。</li>\n<li>2011年7月28日，甲骨文发布java7.0的正式版。</li>\n<li>2014年3月18日，Oracle公司发表Java SE 8。</li>\n</ul>\n<h4 id="java-">Java的专业术语：</h4>\n<ul>\n<li>JDK（Java Development Kit）：编写Java程序的程序员使用的软件</li>\n<li>JRE（ Java Runtime Environment）：运行Java程序的用户使用的软件</li>\n<li>Server JRE （Java SE Runtime Environment）：服务端使用的 Java 运行环境</li>\n<li>SDK（Software Development Kit）：软件开发工具包(广义的概念)，在Java中用于描述1998年~2006年之间的JDK</li>\n<li>DAO（Data Access Object）：数据访问接口，数据访问，顾名思义就是与数据库打交道</li>\n<li>MVC（Model View Controller）：模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用于组织代码用一种业务逻辑和数据显示分离的方法\nJRE 与 Server JRE 区别, 以下是官网中的说明:</li>\n</ul>\n<pre><code>Software Developers: JDK (Java SE Development Kit). For Java Developers. Includes a complete JRE plus tools for developing, debugging, and monitoring Java applications.\n\nAdministrators running applications on a server:  Server JRE (Server Java Runtime Environment) For deploying Java applications on servers. Includes tools for JVM monitoring and tools commonly required for server applications, but does not include browser integration (the Java plug-in), auto-update, nor an installer.</code></pre><h4 id="java-">Java三个主要特征：封装性、继承性、多态性。</h4>\n<ul>\n<li>封装性（encapsulation）：封装是一种信息隐蔽技术，它体现于类的说明，是对象的重要特性。<strong>封装使数据和加工该数据的方法（函数）封装为一个整体</strong>，以实现独立性很强的模块，使得用户只能见到对象的外特性（对象能接受哪些消息，具有哪些处理能力），而对象的内特性（保存内部状态的私有数据和实现加工能力的算法）对用户是隐蔽的。封装的目的在于把对象的设计者和对象的使用者分开，使用者不必知晓其行为实现的细节，只须用设计者提供的消息来访问该对象。</li>\n<li>继承性：继承性是<strong>子类共享其父类数据和方法的机制</strong>。它由类的派生功能体现。一个类直接继承其他类的全部描述，同时可修改和扩充。继承具有传递性。继承分为单继承（一个子类有一父类）和多重继承（一个类有多个父类）。类的对象是各自封闭的，如果没继承性机制，则类的对象中的数据、方法就会出现大量重复。继承不仅支持系统的可重用性，而且还促进系统的可扩充性。</li>\n<li>多态性：<strong>对象根据所接收的消息而做出动作</strong>。<strong>同一消息被不同的对象接受时可产生完全不同的行动，这种现象称为多态性</strong>。利用多态性用户可发送一个通用的信息，而将所有的实现细节都留给接受消息的对象自行决定，如是，同一消息即可调用不同的方法。例如：同样是 run 方法，飞鸟调用时是飞，野兽调用时是奔跑。多态性的实现受到继承性的支持，利用类继承的层次关系，把具有通用功能的协议存放在类层次中尽可能高的地方，而将实现这一功能的不同方法置于较低层次，这样，在这些低层次上生成的对象就能给通用消息以不同的响应。在OOPL中可通过在派生类中重定义基类函数（定义为重载函数或虚函数）来实现多态性。</li>\n</ul>\n'},"94VQ":function(n,t,i){"use strict";var e=i("Yobk"),l=i("X8DO"),o=i("e6n0"),a={};i("hJx8")(a,i("dSzd")("iterator"),function(){return this}),n.exports=function(n,t,i){n.prototype=e(a,{next:l(1,i)}),o(n,t+" Iterator")}},"9v45":function(n,t){n.exports='<h4 id="js-">Js 原型 / 构造函数 / 实例</h4>\n<p>JavaScript 是基于原型的</p>\n<ul>\n<li>JavaScrip只有一种结构：对象</li>\n<li>每一个实例对象都有一个私有属性<code>__proto__</code>，并且该属性指向原型对象（prototype）</li>\n</ul>\n<h5 id="-">普通对象 函数对象</h5>\n<ul>\n<li><p>通过new Function()创建的对象都是<strong>函数对象</strong>，其他都是<strong>普通对象</strong>。</p>\n</li>\n<li><p>每个对象都有 <code>__proto__</code>属性，但只有<strong>函数对象才有 prototype 属性</strong></p>\n</li>\n</ul>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/1.jpg?raw=true" alt="image"></p>\n<h5 id="-">总结:</h5>\n<ul>\n<li>构造函数通过prototype属性获取原型。</li>\n<li>普通对象(例如实例化对象)通过<code>__proto__</code>（非标准）属性获取原型对象。</li>\n<li>原型对象通过constructor属性获取构造函数</li>\n<li>原型对象<code>__proto__</code>（非标准）属性获取上一级原型对象直到Object原型对象。</li>\n</ul>\n<h5 id="-">原型链</h5>\n<ul>\n<li>属性查找机制: 当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象Object.prototype，如还是没找到，则输出undefined。</li>\n<li>属性修改机制: 只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用: b.prototype.x = 2；但是这样会造成所有继承于该对象的实例的属性发生改变。</li>\n</ul>\n'},Alvl:function(n,t){n.exports='<h4 id="dns-">DNS域名解析</h4>\n<h5 id="-">过程：</h5>\n<ol>\n<li>网络客户端打开浏览器，输入一个域名。比如输入<a href="http://www.163.com%EF%BC%8C%E8%BF%99%E6%97%B6%EF%BC%8C%E4%BD%A0%E4%BD%BF%E7%94%A8%E7%9A%84%E7%94%B5%E8%84%91%E4%BC%9A%E5%8F%91%E5%87%BA%E4%B8%80%E4%B8%AADNS%E8%AF%B7%E6%B1%82%E5%88%B0%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%82%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%80%E8%88%AC%E9%83%BD%E6%98%AF%E4%BD%A0%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%85%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%95%86%E6%8F%90%E4%BE%9B%EF%BC%8C%E6%AF%94%E5%A6%82%E4%B8%AD%E5%9B%BD%E7%94%B5%E4%BF%A1%EF%BC%8C%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8%E3%80%82">www.163.com，这时，你使用的电脑会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</a></li>\n<li>查询<a href="http://www.163.com%E7%9A%84DNS%E8%AF%B7%E6%B1%82%E5%88%B0%E8%BE%BE%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%9A%E9%A6%96%E5%85%88%E6%9F%A5%E8%AF%A2%E5%AE%83%E7%9A%84%E7%BC%93%E5%AD%98%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%A6%82%E6%9E%9C%E7%BC%93%E5%AD%98%E4%B8%AD%E6%9C%89%E6%AD%A4%E6%9D%A1%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E7%BB%93%E6%9E%9C%E3%80%82%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%EF%BC%8C%E6%9C%AC%E5%9C%B0DNS%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%98%E8%A6%81%E5%90%91DNS%E6%A0%B9%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%9B%E8%A1%8C%E6%9F%A5%E8%AF%A2%E3%80%82">www.163.com的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</a></li>\n<li>根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。</li>\n<li>本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</li>\n<li>最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</li>\n</ol>\n<h5 id="-dns-ttl-time-to-live-">于DNS解析的TTL参数（Time To Live）：</h5>\n<ol>\n<li>TTL这个参数告诉本地DNS服务器，域名缓存的最长时间。用阿里云解析来举例，阿里云解析默认的TTL是10分钟，10分钟的含义是，本地DNS服务器对于域名的缓存时间是10分钟，10分钟之后，本地DNS服务器就会删除这条记录，删除之后，如果有用户访问这个域名，就要重复一遍上述复杂的流程。</li>\n<li>如果网站已经进入稳定发展的状态，不会轻易更换IP地址，我们完全可以将TTL设置到协议最大值，即24小时。带来的好处是，让域名解析记录能够更长时间的存放在本地DNS服务器中，以加快所有用户的访问。设置成24小时，其实，还解决了Googlebot在全球部署的服务器抓取网站可能带来的问题。</li>\n</ol>\n'},BUxh:function(n,t){n.exports='<h4 id="xml">XML</h4>\n<p>XML 文档构建模块</p>\n<ul>\n<li>元素</li>\n<li>属性</li>\n<li>实体</li>\n<li>PCDATA</li>\n<li>CDATA<h5 id="dtd-document-type-definition-">DTD(document type definition)</h5>\n</li>\n</ul>\n<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE note [\n&lt;!ELEMENT note (to,from,heading,body)&gt;\n&lt;!ELEMENT to (#PCDATA)&gt;\n&lt;!ELEMENT from (#PCDATA)&gt;\n&lt;!ELEMENT heading (#PCDATA)&gt;\n&lt;!ELEMENT body (#PCDATA)&gt;\n]&gt;\n&lt;note&gt;\n&lt;to&gt;Tove&lt;/to&gt;\n&lt;from&gt;Jani&lt;/from&gt;\n&lt;heading&gt;Reminder&lt;/heading&gt;\n&lt;body&gt;Don&#39;t forget me this weekend&lt;/body&gt;\n&lt;/note&gt;</code></pre><ul>\n<li>!DOCTYPE note (第二行)定义此文档是 note 类型的文档。</li>\n<li>!ELEMENT note (第三行)定义 note元素有四个元素：&quot;to、from、heading、body&quot;</li>\n<li>!ELEMENT to (第四行)定义 to 元素为 &quot;#PCDATA&quot; 类型</li>\n<li>!ELEMENT from (第五行)定义 from 元素为 &quot;#PCDATA&quot; 类型</li>\n<li>!ELEMENT heading (第六行)定义 heading 元素为 &quot;#PCDATA&quot; 类型</li>\n<li>!ELEMENT body (第七行)定义 body 元素为 &quot;#PCDATA&quot; 类型<h5 id="note-dtd">note.dtd</h5>\n<pre><code>&lt;!ELEMENT note (to,from,heading,body)&gt;\n&lt;!ELEMENT to (#PCDATA)&gt;\n&lt;!ELEMENT from (#PCDATA)&gt;\n&lt;!ELEMENT heading (#PCDATA)&gt;\n&lt;!ELEMENT body (#PCDATA)&gt;</code></pre>PCDATA:parsed character data被解析的字符数据.\nCDATA:character data不会被解析器解析的文本.</li>\n</ul>\n<h5 id="-">元素（标签）</h5>\n<p>声明一个元素</p>\n<pre><code>&lt;!ELEMENT element-name category(目录)&gt;\n或\n&lt;!ELEMENT element-name (element-content)&gt;</code></pre><p>空元素</p>\n<pre><code>&lt;!ELEMENT element-name EMPTY&gt;</code></pre><p>只有 PCDATA 的元素</p>\n<pre><code>&lt;!ELEMENT element-name (#PCDATA)&gt;\n实例:\n&lt;!ELEMENT from (#PCDATA)&gt;</code></pre><p>通过类别关键词 ANY 声明的元素，可包含任何可解析数据的组合：</p>\n<pre><code>&lt;!ELEMENT element-name ANY&gt;\n实例:\n&lt;!ELEMENT note ANY&gt;</code></pre><p>带有一个或多个子元素的元素通过圆括号中的子元素名进行声明：</p>\n<pre><code>&lt;!ELEMENT element-name (child1)&gt;\n或\n&lt;!ELEMENT element-name (child1,child2,...)&gt;\n实例:\n&lt;!ELEMENT note (to,from,heading,body)&gt;</code></pre><p>声明只出现一次的元素</p>\n<pre><code>&lt;!ELEMENT element-name (child-name)&gt;\n实例:\n&lt;!ELEMENT note (message)&gt;\nmessage 子元素必须出现一次，并且必须只在 &quot;note&quot; 元素中出现一次。</code></pre><p>声明最少出现一次的元素</p>\n<pre><code>&lt;!ELEMENT element-name (child-name+)&gt;\n实例:\n&lt;!ELEMENT note (message+)&gt;</code></pre><p>声明出现零次或多次的元素</p>\n<pre><code>&lt;!ELEMENT element-name (child-name*)&gt;\n实例:\n&lt;!ELEMENT note (message*)&gt;</code></pre><p>声明出现零次或一次的元素</p>\n<pre><code>&lt;!ELEMENT element-name (child-name?)&gt;\n实例:\n&lt;!ELEMENT note (message?)&gt;</code></pre><p>声明&quot;非.../即...&quot;类型的内容</p>\n<pre><code>&lt;!ELEMENT note (to,from,header,(message|body))&gt;</code></pre><p>声明混合型的内容</p>\n<pre><code>&lt;!ELEMENT note (#PCDATA|to|from|header|message)*&gt;</code></pre><h5 id="dtd-">DTD - 属性</h5>\n<p>声明属性</p>\n<pre><code>&lt;!ATTLIST element-name attribute-name attribute-type attribute-value&gt;\nDTD 实例:\n&lt;!ATTLIST payment type CDATA &quot;check&quot;&gt;\nXML 实例:\n&lt;payment type=&quot;check&quot; /&gt;</code></pre><p>#REQUIRED:属性值是必须的required</p>\n<p>#IMPLIED:即该属性不是必须使用。</p>\n<p>#FIXED：固定值</p>\n<h6 id="-">列举属性值</h6>\n<pre><code>&lt;!ATTLIST element-name attribute-name (en1|en2|..) default-value&gt;</code></pre><p>实体</p>\n<pre><code>内部实体\n&lt;!ENTITY entity-name &quot;entity-value&quot;&gt;\nDTD 实例:\n&lt;!ENTITY writer &quot;Donald Duck.&quot;&gt;\n&lt;!ENTITY copyright &quot;Copyright runoob.com&quot;&gt;\nXML 实例：\n&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;\n外部实体\n&lt;!ENTITY writer SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;\n&lt;!ENTITY copyright SYSTEM &quot;http://www.runoob.com/entities.dtd&quot;&gt;\nXML example:\n&lt;author&gt;&amp;writer;&amp;copyright;&lt;/author&gt;</code></pre><p>例子</p>\n<pre><code>&lt;!DOCTYPE TVSCHEDULE [\n\n&lt;!ELEMENT TVSCHEDULE (CHANNEL+)&gt;\n&lt;!ELEMENT CHANNEL (BANNER,DAY+)&gt;\n&lt;!ELEMENT BANNER (#PCDATA)&gt;\n&lt;!ELEMENT DAY (DATE,(HOLIDAY|PROGRAMSLOT+)+)&gt;\n&lt;!ELEMENT HOLIDAY (#PCDATA)&gt;\n&lt;!ELEMENT DATE (#PCDATA)&gt;\n&lt;!ELEMENT PROGRAMSLOT (TIME,TITLE,DESCRIPTION?)&gt;\n&lt;!ELEMENT TIME (#PCDATA)&gt;\n&lt;!ELEMENT TITLE (#PCDATA)&gt; \n&lt;!ELEMENT DESCRIPTION (#PCDATA)&gt;\n\n&lt;!ATTLIST TVSCHEDULE NAME CDATA #REQUIRED&gt;\n&lt;!ATTLIST CHANNEL CHAN CDATA #REQUIRED&gt;\n&lt;!ATTLIST PROGRAMSLOT VTR CDATA #IMPLIED&gt;\n&lt;!ATTLIST TITLE RATING CDATA #IMPLIED&gt;\n&lt;!ATTLIST TITLE LANGUAGE CDATA #IMPLIED&gt;</code></pre>'},CXw9:function(n,t,i){"use strict";var e,l,o,a,r=i("O4g8"),p=i("7KvD"),s=i("+ZMJ"),c=i("RY/4"),u=i("kM2E"),h=i("EqjI"),d=i("lOnJ"),g=i("2KxR"),m=i("NWt+"),v=i("t8x9"),f=i("L42u").set,b=i("82Mu")(),S=i("qARP"),y=i("dNDb"),E=i("iUbK"),x=i("fJUb"),C=p.TypeError,q=p.process,w=q&&q.versions,A=w&&w.v8||"",T=p.Promise,P="process"==c(q),J=function(){},D=l=S.f,j=!!function(){try{var n=T.resolve(1),t=(n.constructor={})[i("dSzd")("species")]=function(n){n(J,J)};return(P||"function"==typeof PromiseRejectionEvent)&&n.then(J)instanceof t&&0!==A.indexOf("6.6")&&-1===E.indexOf("Chrome/66")}catch(n){}}(),I=function(n){var t;return!(!h(n)||"function"!=typeof(t=n.then))&&t},M=function(n,t){if(!n._n){n._n=!0;var i=n._c;b(function(){for(var e=n._v,l=1==n._s,o=0,a=function(t){var i,o,a,r=l?t.ok:t.fail,p=t.resolve,s=t.reject,c=t.domain;try{r?(l||(2==n._h&&L(n),n._h=1),!0===r?i=e:(c&&c.enter(),i=r(e),c&&(c.exit(),a=!0)),i===t.promise?s(C("Promise-chain cycle")):(o=I(i))?o.call(i,p,s):p(i)):s(e)}catch(n){c&&!a&&c.exit(),s(n)}};i.length>o;)a(i[o++]);n._c=[],n._n=!1,t&&!n._h&&B(n)})}},B=function(n){f.call(p,function(){var t,i,e,l=n._v,o=N(n);if(o&&(t=y(function(){P?q.emit("unhandledRejection",l,n):(i=p.onunhandledrejection)?i({promise:n,reason:l}):(e=p.console)&&e.error&&e.error("Unhandled promise rejection",l)}),n._h=P||N(n)?2:1),n._a=void 0,o&&t.e)throw t.v})},N=function(n){return 1!==n._h&&0===(n._a||n._c).length},L=function(n){f.call(p,function(){var t;P?q.emit("rejectionHandled",n):(t=p.onrejectionhandled)&&t({promise:n,reason:n._v})})},O=function(n){var t=this;t._d||(t._d=!0,(t=t._w||t)._v=n,t._s=2,t._a||(t._a=t._c.slice()),M(t,!0))},k=function(n){var t,i=this;if(!i._d){i._d=!0,i=i._w||i;try{if(i===n)throw C("Promise can't be resolved itself");(t=I(n))?b(function(){var e={_w:i,_d:!1};try{t.call(n,s(k,e,1),s(O,e,1))}catch(n){O.call(e,n)}}):(i._v=n,i._s=1,M(i,!1))}catch(n){O.call({_w:i,_d:!1},n)}}};j||(T=function(n){g(this,T,"Promise","_h"),d(n),e.call(this);try{n(s(k,this,1),s(O,this,1))}catch(n){O.call(this,n)}},(e=function(n){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1}).prototype=i("xH/j")(T.prototype,{then:function(n,t){var i=D(v(this,T));return i.ok="function"!=typeof n||n,i.fail="function"==typeof t&&t,i.domain=P?q.domain:void 0,this._c.push(i),this._a&&this._a.push(i),this._s&&M(this,!1),i.promise},catch:function(n){return this.then(void 0,n)}}),o=function(){var n=new e;this.promise=n,this.resolve=s(k,n,1),this.reject=s(O,n,1)},S.f=D=function(n){return n===T||n===a?new o(n):l(n)}),u(u.G+u.W+u.F*!j,{Promise:T}),i("e6n0")(T,"Promise"),i("bRrM")("Promise"),a=i("FeBl").Promise,u(u.S+u.F*!j,"Promise",{reject:function(n){var t=D(this);return(0,t.reject)(n),t.promise}}),u(u.S+u.F*(r||!j),"Promise",{resolve:function(n){return x(r&&this===a?T:this,n)}}),u(u.S+u.F*!(j&&i("dY0y")(function(n){T.all(n).catch(J)})),"Promise",{all:function(n){var t=this,i=D(t),e=i.resolve,l=i.reject,o=y(function(){var i=[],o=0,a=1;m(n,!1,function(n){var r=o++,p=!1;i.push(void 0),a++,t.resolve(n).then(function(n){p||(p=!0,i[r]=n,--a||e(i))},l)}),--a||e(i)});return o.e&&l(o.v),i.promise},race:function(n){var t=this,i=D(t),e=i.reject,l=y(function(){m(n,!1,function(n){t.resolve(n).then(i.resolve,e)})});return l.e&&e(l.v),i.promise}})},D2L2:function(n,t){var i={}.hasOwnProperty;n.exports=function(n,t){return i.call(n,t)}},EGZi:function(n,t){n.exports=function(n,t){return{value:t,done:!!n}}},EqBC:function(n,t,i){"use strict";var e=i("kM2E"),l=i("FeBl"),o=i("7KvD"),a=i("t8x9"),r=i("fJUb");e(e.P+e.R,"Promise",{finally:function(n){var t=a(this,l.Promise||o.Promise),i="function"==typeof n;return this.then(i?function(i){return r(t,n()).then(function(){return i})}:n,i?function(i){return r(t,n()).then(function(){throw i})}:n)}})},EqjI:function(n,t){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},FJVD:function(n,t){n.exports='<h4 id="-">浏览器渲染机制</h4>\n<ul>\n<li>Web浏览器是一种软件，它从远程服务器（或者本地磁盘）加载文件并将其显示并且用户可以与之交互。</li>\n<li>浏览器引擎：在不同的浏览器中，浏览器的某个部分会根据它接收到的文件确定显示什么，这就是所谓的浏览器引擎。浏览器引擎是每一种主流浏览器的核心软件组件，不同的浏览器开发商用不同的名字来称呼他们的引擎。Firefox：Gecko，Chrome：Blink，Webkit的一个分支。</li>\n<li>发送 &amp; 接收信息：数据是以“数据包”的形式通过互联网发送，而数据包以字节为单位。</li>\n<li>计算机：只懂字节数,浏览器读取的是原始数据字节，而不是编写的实际代码。</li>\n<li>DOM：文档树结构，文档模型</li>\n<li>CSSOM：CSS树结构，层叠样式表对象模型</li>\n</ul>\n<h5 id="-">加载过程</h5>\n<p>当浏览器接收到原始数据字节并启动DOM构建解析HTML过程时，它还会发出请求来获取链接的CSS样式表。浏览器还是接收CSS数据的原始字节，从服务器或是本地磁盘。</p>\n<h5 id="-css-">浏览器如何处理这些CSS数据的原始字节</h5>\n<p>从CSS的原始字节到CSSOM，当浏览器接收到CSS的原始字节时，会启动一个和处理HTML原始字节类似的过程。就是说，原始数据字节被转换成字符，然后标记，然后形成节点，最后形成树结构。</p>\n<p>CSS级联是浏览器确定如何在元素上应用样式的机制。</p>\n<p>由于影响元素的样式可能来自父元素，即通过继承，或者已经在元素本身设置。浏览器必须递归遍历CSS树结构并确定影响特定元素的样式。</p>\n<h5 id="-">渲染树</h5>\n<p> 回流（reflow）：指的是网络浏览器为了重新渲染部分或全部的文档而重新计算文档中元素的位置和几何结构的过程。页面上节点是以树的形式展现的，我们通过js将页面上的一个节点删除，此时为了不让剩下的节点脱节，将断点结合起来重新形成一棵树。而这个重新结合过程就是回流。就是由于某些修改，要将元素回过头来重新“流”一遍。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/3.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/4.png?raw=true" alt="image"></p>\n<h5 id="-render-blocking-">渲染阻塞资源（render-blocking）</h5>\n<h6 id="-">“有东西阻止了屏幕上节点的实际绘制”。</h6>\n<p>优化网站的第一准则是让最重要的HTML和CSS尽可能快地传递到客户端。在成功绘制之前，必须构造DOM和CSSOM，因此HTML和CSS都是渲染阻塞资源。</p>\n<h5 id="javascript-">JavaScript如何执行</h5>\n<p><strong>当浏览器遇到脚本标签时，DOM 构造就会暂停!</strong> 整个 DOM构建过程都将停止，直到脚本执行完成。这是因为 JavaScript 可以同时修改DOM和CSSOM。由于浏览器不确定特定的JavaScript会做什么，所以它采取的预防措施是停止整个DOM构造。</p>\n<h4 id="css-">CSS如何执行</h4>\n<p>当解析器遇到一个脚本标签而CSSOM还没有准备好时，Javascript执行将会停止，直到CSSOM就绪。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/broswer/7.png?raw=true" alt="image"></p>\n<p>DOM遇到脚本标签时会停止，但CSSOM不会发生这种情况。对于 CSSOM，JS执行会等待。没有CSSOM，就没有JS执行。</p>\n<h5 id="async-">async 属性</h5>\n<p>在默认情况下，每个脚本都是一个解析器阻断器！DOM 的构建总是会被打断。不过，有一种方法可以改变这种默认行为。如果将async关键字添加到脚本标签中，那么DOM构造就不会停止。DOM 构造将继续，脚本将在下载完成并准备就绪后执行。</p>\n<h5 id="-">关键渲染路径</h5>\n<p>从接收HTML、CSS和JS字节到将它们转换为屏幕上的像素之间的所有步骤。这整个过程称为<strong>关键渲染路径</strong>。优化网站性能就是优化关键渲染路径。</p>\n<p>一个经过良好优化的站点应该能够渐进式渲染，而不是让整个过程受阻。</p>\n'},FaJS:function(n,t){n.exports='<h4 id="object-defineproperty-obj-prop-descriptor-">Object.defineProperty(obj, prop, descriptor)方法</h4>\n<p>参数</p>\n<ul>\n<li>obj 进行属性操作的对象</li>\n<li>pro (property)属性名</li>\n<li>descripter 属性描述符</li>\n</ul>\n<p>返回值</p>\n<p>返回属性被操作的对象</p>\n<h5 id="-">应用</h5>\n<p>确添加或者修改对象的属性，还可以枚举对象属性，设置可否重写，可否删除。</p>\n<h5 id="-">属性描述符</h5>\n<ul>\n<li>数据描述符<ul>\n<li>value</li>\n<li>writable</li>\n<li>configurable</li>\n<li>enumerable</li>\n</ul>\n</li>\n<li>存取描述符<ul>\n<li>get函数</li>\n<li>set函数</li>\n<li>configurable</li>\n<li>enumerable</li>\n</ul>\n</li>\n</ul>\n<h4 id="-">数双向绑定的基本原理</h4>\n<pre><code>    var obj = {\n        pro1: &quot;test&quot;  //这个是无关属性，纯粹为了看看输出obj\n    };\n    Object.defineProperty(obj, &quot;hello&quot;, {\n        get: function () {\n            console.log(&quot;get-this→obj&quot;, this);\n            console.log(&quot;get方法被調用&quot;)\n        },\n        set: function (newVal) {\n            console.log(&quot;set-this→obj&quot;, this);\n            console.log(&quot;set方法被調用&quot;, 123)\n            document.getElementById(&#39;a&#39;).value = newVal; //这里是实现控制台输入obj.helllo,同样可以控制input的value值 \n            document.getElementById(&#39;b&#39;).innerHTML = newVal;\n        }\n    })\n    console.log(&quot;obj&quot;, obj); //输出obj对象，两个属性，一个为空。 \n    obj.hello; //这个会执行obj里面的get方法。 \n    //document添加监听事件，获取用户输入的值，赋值给对象obj属性hello \n    document.addEventListener(&quot;keyup&quot;, (e) =&gt; {\n        obj.hello = e.target.value; //这个赋值语句，将执行obj的set方法，那么可以操作span标签的text,让其内容与输入框内容同步 \n    });</code></pre><h4 id="nodetoframgment">nodeToframgment</h4>\n<p>文档节点对象</p>\n<pre><code>&lt;body&gt;\n    &lt;div id=&quot;origin&quot;&gt;22\n        &lt;input type=&quot;text&quot; id=&quot;a&quot;&gt;\n        &lt;span id=&quot;b&quot;&gt;&lt;/span&gt;22\n    &lt;/div&gt;\n    &lt;div id=&quot;target&quot;&gt;&lt;/div&gt;\n\n&lt;/body&gt;\n\n&lt;/html&gt;\n&lt;script&gt;\n    //Vue进行编译时，就是将挂载目标的所有子节点劫持\n    //通过append方法，DOM 中的节点会被自动删除\n    //到 DocumentFragment中经过一番处理后，再将DocumentFragment整体\n    //返回插入挂载目标。\n    var dom = nodeToframgment(document.getElementById(&quot;origin&quot;));\n\n    function nodeToframgment(node) {\n        var flag = document.createDocumentFragment();\n        //创建节点文档对象\n        var child;\n        while (child = node.firstChild) {\n            flag.appendChild(child);\n        }\n        //遍历原根节点的子节点，全部劫持，源子节点一个一个删除。\n        //DocumentFragment(5) [ #text, input#a, #text, span#b, #text ]\n        return flag;\n    }\n    // 文档节点对象已经有源节点的所有子节点。\n    document.getElementById(&#39;target&#39;).appendChild(dom);\n&lt;/script&gt;\n\n</code></pre><h4 id="-">完整例子</h4>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Two-way-data-binding&lt;/title&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n\n    &lt;div id=&quot;app&quot;&gt;\n        &lt;input type=&quot;text&quot; v-model=&quot;text&quot;&gt; {{ text }}\n    &lt;/div&gt;\n\n    &lt;script&gt;\n        //这个方法，是对Vue实例data对象的每一个属性声明一个defineReactive(vm, key, obj[key])方法\n        function observe(obj, vm) {\n            Object.keys(obj).forEach(function(key) {\n                defineReactive(vm, key, obj[key]);\n            })\n        }\n\n        function defineReactive(obj, key, val) {\n\n            var dep = new Dep();\n            //实例dep对象，两个方法，一个是addsub添加订阅，一个是notify给订阅者发布消息\n            Object.defineProperty(obj, key, {\n                get: function() {\n                    // 在创建Vue实例时，就会同时创建watcher,接下来watcher就会触发Object这个属性拦截器，属性拦截器就触发dep添加watcher订阅者添加订阅者watcher到主题对象Dep\n                    if (Dep.sub)\n                        dep.addSub(Dep.sub);\n                    return val\n                },\n                set: function(newVal) {\n\n                    if (newVal === val) return\n                    val = newVal;\n                    // 作为发布者发出通知\n                    dep.notify();\n                }\n            });\n        }\n\n        function Dep() {\n            this.subs = []\n        }\n        Dep.prototype = {\n\n            addSub: function(sub) {\n                this.subs.push(sub);\n            },\n            notify: function() {\n                this.subs.forEach(function(sub) {\n                    //这里调用各个订阅者也就是watcher的方法\n                    sub.update();\n                });\n            }\n        }\n\n        function nodeToFragment(node, vm) {\n            var flag = document.createDocumentFragment();\n            var child;\n            while (child = node.firstChild) {\n                compile(child, vm);\n                flag.appendChild(child);\n            }\n            return flag\n        }\n\n        function compile(node, vm) {\n            var reg = /\\{\\{(.*)\\}\\}/;\n            // 节点类型为元素\n            if (node.nodeType === 1) {\n                var attr = node.attributes;\n                // 解析属性\n                for (var i = 0; i &lt; attr.length; i++) {\n                    if (attr[i].nodeName == &#39;v-model&#39;) {\n                        var name = attr[i].nodeValue; // 获取 v-model 绑定的属性名\n                        node.addEventListener(&#39;input&#39;, function(e) {\n                            // 给相应的 data 属性赋值，进而触发该属性的 set 方法\n                            vm[name] = e.target.value;\n                            //这里我可以把value值直接赋值给data.text但是，用发布订阅模式，可以通知各个订阅者自己去处理自己的事务\n                        });\n                        node.value = vm[name]; // 将 data 的值赋给该 node\n                        node.removeAttribute(&#39;v-model&#39;);\n                    }\n                };\n\n                new Watcher(vm, node, name, &#39;input&#39;);\n            }\n            // 节点类型为 text\n            if (node.nodeType === 3) {\n                if (reg.test(node.nodeValue)) {\n                    var name = RegExp.$1; // 获取匹配到的字符串\n                    name = name.trim();\n                    new Watcher(vm, node, name, &#39;text&#39;);\n                }\n            }\n        }\n\n        function Watcher(vm, node, name, nodeType) {\n            Dep.sub = this; //这里只是给Dep原型添加属性，并且把watcher作为订阅者。\n            this.name = name;\n            this.node = node;\n            this.vm = vm;\n            this.nodeType = nodeType;\n            this.update();\n            Dep.target = null;\n        }\n\n        Watcher.prototype = {\n            update: function() {\n                this.get();\n                if (this.nodeType == &#39;text&#39;) {\n                    this.node.nodeValue = this.value;\n                }\n                if (this.nodeType == &#39;input&#39;) {\n                    this.node.value = this.value;\n                }\n            },\n            // 获取 data 中的属性值\n            get: function() {\n                this.value = this.vm[this.name]; // 触发相应属性的 get\n            }\n        }\n\n\n        function Vue(options) {\n            this.data = options.data;\n            var data = this.data;\n            observe(data, this);\n            var id = options.el;\n            var dom = nodeToFragment(document.getElementById(id), this);\n            // 编译完成后，将 dom 返回到 app 中\n            document.getElementById(id).appendChild(dom);\n        }\n        var vm = new Vue({\n            el: &#39;app&#39;,\n            data: {\n                text: &#39;hello world&#39;\n            }\n        })\n    &lt;/script&gt;\n&lt;/body&gt;\n\n&lt;/html&gt;</code></pre>'},FeBl:function(n,t){var i=n.exports={version:"2.5.7"};"number"==typeof __e&&(__e=i)},Hhxk:function(n,t){n.exports='<h3 id="servlet-">servlet介绍</h3>\n<p>Java Servlet 是运行在 <strong>Web 服务器或应用服务器</strong>上的<strong>程序</strong>，它是作为来自 Web 浏览器或其他 <strong>HTTP 客户端的请求</strong>和 HTTP 服务器上的数据库或应用程序之间的中间层\n<img src="http://www.runoob.com/wp-content/uploads/2014/07/servlet-arch.jpg" alt="image"></p>\n<h5 id="servlet-">Servlet 任务</h5>\n<ul>\n<li>读取客户端（浏览器）发送的显式的数据。这包括网页上的 HTML 表单。</li>\n<li>读取客户端（浏览器）发送的隐式的 HTTP 请求数据。这包括 cookies。</li>\n<li>处理数据并生成结果</li>\n<li>发送显式的数据（即文档）到客户端（浏览器）</li>\n<li>发送隐式的 HTTP 响应到客户端（浏览器）</li>\n</ul>\n<h5 id="servlet-">Servlet 包</h5>\n<p>Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。</p>\n<h5 id="servlet-">Servlet 生命周期</h5>\n<ul>\n<li>Servlet 通过调用init()方法进行初始化<ul>\n<li>当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法</li>\n<li>init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期<pre><code> public void init() throws ServletException {\n  // 初始化代码...\n}</code></pre></li>\n</ul>\n</li>\n<li>Servlet 调用service()方法来处理客户端的请求<ul>\n<li>service()方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用doGet、doPost、doPut，doDelete 等方法。<pre><code>public void service(ServletRequest request, \n                ServletResponse response) \n  throws ServletException, IOException{\n}</code></pre></li>\n</ul>\n</li>\n<li>Servlet 通过调用destroy()方法终止（结束）</li>\n</ul>\n'},I54Z:function(n,t){n.exports='<h3 id="java-">Java 异常处理</h3>\n<p>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</p>\n<p>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error；如果你用System.out.println(11/0)，那么你是因为你用0做了除数，会抛出 java.lang.ArithmeticException 的异常。</p>\n<h4 id="-">异常发生的原因通常包含以下几大类：</h4>\n<ul>\n<li>用户输入了非法数据。</li>\n<li>要打开的文件不存在。</li>\n<li>网络通信时连接中断，或者JVM内存溢出。</li>\n<li>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</li>\n</ul>\n<h4 id="-java-">要理解Java异常处理是如何工作的，需要掌握以下三种类型的异常：</h4>\n<ul>\n<li>检查性异常：最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</li>\n<li>运行时异常： 运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</li>\n<li>错误： 错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</li>\n</ul>\n<h4 id="exception-">Exception 类的层次</h4>\n<ul>\n<li>所有的异常类是从 java.lang.Exception 类继承的子类。</li>\n<li>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</li>\n<li>Java 程序通常不捕获错误。错误一般发生在严重故障时，它们在Java程序处理的范畴之外。</li>\n<li>Error 用来指示运行时环境发生的错误。</li>\n</ul>\n<p>例如，JVM 内存溢出。一般地，程序不会从错误中恢复。</p>\n<h4 id="-ioexception-runtimeexception-">异常类有两个主要的子类：IOException 类和 RuntimeException 类。</h4>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/16.jpg?raw=true" alt="image"></p>\n<h4 id="java-">Java 内置异常类</h4>\n<p>Java 语言定义了一些异常类在 java.lang 标准包中。</p>\n<p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</p>\n<h5 id="java-java-">Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常。</h5>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/16.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/17.png?raw=true" alt="image"></p>\n<h5 id="-java-java-lang-">下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类。</h5>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/18.png?raw=true" alt="image"> </p>\n<h4 id="-">异常方法</h4>\n<h5 id="-throwable-">下面的列表是 Throwable 类的主要方法:</h5>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/19.png?raw=true" alt="image"> </p>\n<h4 id="-">捕获异常</h4>\n<p>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。</p>\n<p><strong>try/catch代码块中的代码称为保护代码</strong>，使用 try/catch 的语法如下：</p>\n<pre><code>try\n{\n   // 程序代码\n}catch(ExceptionName e1)\n{\n   //Catch 块\n}</code></pre><ul>\n<li><p>Catch 语句包含要捕获异常类型的声明。当保护代码块中发生一个异常时，try 后面的 catch 块就会被检查。</p>\n</li>\n<li><p>如果发生的异常包含在catch块中，异常会被传递到该catch块，这和传递一个参数到方法是一样。</p>\n</li>\n</ul>\n<h4 id="-">多重捕获块</h4>\n<p>一个 try 代码块后面跟随多个 catch 代码块的情况就叫多重捕获。</p>\n<pre><code>try{\n   // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}</code></pre><p>上面的代码段包含了 3 个 catch块。</p>\n<p>可以在 try 语句后面添加任意数量的 catch 块。</p>\n<p>如果保护代码中发生异常，异常被抛给第一个 catch 块。</p>\n<p>如果抛出异常的数据类型与 ExceptionType1 匹配，它在这里就会被捕获。</p>\n<p>如果不匹配，它会被传递给第二个 catch 块。</p>\n<p>如此，直到异常被捕获或者通过所有的 catch 块。</p>\n<h4 id="throws-throw-">throws/throw 关键字：</h4>\n<p>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用throws关键字来声明。throws 关键字放在方法签名的尾部。</p>\n<p>也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的。</p>\n<p>下面方法的声明抛出一个 RemoteException 异常：</p>\n<pre><code>import java.io.*;\npublic class className\n{\n  public void deposit(double amount) throws RemoteException\n  {\n    // Method implementation\n    throw new RemoteException();\n  }\n  //Remainder of class definition\n}</code></pre><p>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</p>\n<p>例如，下面的方法声明抛出 RemoteException 和 InsufficientFundsException：</p>\n<pre><code>import java.io.*;\npublic class className\n{\n   public void withdraw(double amount) throws RemoteException,\n                              InsufficientFundsException\n   {\n       // Method implementation\n   }\n   //Remainder of class definition\n}</code></pre><h4 id="finally-">finally关键字</h4>\n<p>finally 关键字用来创建在 try 代码块后面执行的代码块。</p>\n<p>无论是否发生异常，finally 代码块中的代码总会被执行。</p>\n<p>在 finally 代码块中，可以运行清理类型等收尾善后性质的语句。</p>\n<p>finally 代码块出现在 catch 代码块最后，语法如下：</p>\n<pre><code>try{\n  // 程序代码\n}catch(异常类型1 异常的变量名1){\n  // 程序代码\n}catch(异常类型2 异常的变量名2){\n  // 程序代码\n}finally{\n  // 程序代码\n}</code></pre><h4 id="-">注意下面事项：</h4>\n<ul>\n<li>catch 不能独立于 try 存在。</li>\n<li>在 try/catch 后面添加 finally 块并非强制性要求的。</li>\n<li>try 代码后不能既没 catch 块也没 finally 块。</li>\n<li>try, catch, finally 块之间不能添加任何代码。</li>\n</ul>\n<h4 id="-">声明自定义异常</h4>\n<p>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</p>\n<ul>\n<li>所有异常都必须是 Throwable 的子类。</li>\n<li>如果希望写一个检查性异常类，则需要继承 Exception 类。</li>\n<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</li>\n</ul>\n<pre><code>class MyException extends Exception{\n}</code></pre><p>只继承Exception 类来创建的异常类是检查性异常类。</p>\n<p>下面的 InsufficientFundsException 类是用户定义的异常类，它继承自 Exception。</p>\n<p>一个异常类和其它任何类一样，包含有变量和方法。</p>\n<h4 id="-">通用异常</h4>\n<ul>\n<li>JVM(Java虚拟机) 异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</li>\n<li>程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</li>\n<li></li>\n</ul>\n<h3 id="-">笔记</h3>\n<h4 id="-">名词解释</h4>\n<ul>\n<li>检查性异常: 错误不处理，不能通过编译</li>\n<li>非检查性异常:不处理编译可以通过，如果有抛出直接抛到控制台</li>\n<li>运行时异常: 就是非检查性异常</li>\n<li>非运行时异常: 就是检查性异常</li>\n</ul>\n<h4 id="-">异常使用可遵循下面的原则：</h4>\n<ul>\n<li>在当前方法被覆盖时，覆盖他的方法必须抛出相同的异常或异常的子类；</li>\n<li>在当前方法声明中使用try-catch语句捕获异常；</li>\n<li>如果父类抛出多个异常，则覆盖方法必须抛出那些异常的一个子集，不能抛出新异常。</li>\n</ul>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/20.png?raw=true" alt="image"></p>\n<p>如图可以看出所有的异常跟错误都继承与Throwable类，也就是说所有的异常都是一个对象。</p>\n<h5 id="-">从大体来分异常为两块：</h5>\n<ul>\n<li><p>error---错误 ： 是指程序无法处理的错误，表示应用程序运行时出现的重大错误。例如jvm运行时出现的OutOfMemoryError以及Socket编程时出现的端口占用等程序无法处理的错误。</p>\n</li>\n<li><p>Exception --- 异常 ：</p>\n<ul>\n<li><strong>运行时异常</strong></li>\n<li><strong>编译异常</strong></li>\n</ul>\n</li>\n<li><p>运行时异常：即RuntimeException及其之类的异常。这类异常在代码编写的时候不会被编译器所检测出来，是可以不需要被捕获，但是程序员也可以根据需要进行捕获抛出。常见的RUNtimeException有：NullpointException（空指针异常），ClassCastException（类型转换异常），IndexOutOfBoundsException（数组越界异常）等。</p>\n</li>\n<li><p>编译异常：RuntimeException以外的异常。这类异常在编译时编译器会提示需要捕获，如果不进行捕获则编译错误。常见编译异常有：IOException（流传输异常），SQLException（数据库操作异常）等。</p>\n</li>\n<li><p>java处理异常的机制：抛出异常以及捕获异常，一个方法所能捕捉的异常，一定是Java代码在某处所抛出的异常。简单地说，<strong>异常总是先被抛出，后被捕捉的</strong>。</p>\n</li>\n</ul>\n<h5 id="throw-throws-">throw跟throws的区别:</h5>\n<pre><code>public void test() throws Exception {\n    throw new Exception();\n}</code></pre><p>throws表示一个方法声明可能抛出一个异常，throw表示此处抛出一个已定义的异常（可以是自定义需继承Exception，也可以是java自己给出的异常类）。</p>\n<h4 id="java-">Java看一下如何捕获异常：</h4>\n<p>1）首先java对于异常捕获使用的是try---catch或try --- catch --- finally 代码块，程序会捕获try代码块里面的代码，若捕获到异常则进行catch代码块处理。若有finally则在catch处理后执行finally里面的代码。然而存在这样两个问题：</p>\n<p>a.看如下代码：</p>\n<pre><code>try{\n    //待捕获代码\n}catch（Exception e）{\n    System.out.println(&quot;catch is begin&quot;);\n    return 1 ；\n}finally{\n     System.out.println(&quot;finally is begin&quot;);\n}</code></pre><p>在catch里面有一个return，那么finally会不会被执行呢？答案是肯定的，上面代码的执行结果为：</p>\n<pre><code>catch is begin\nfinally is begin</code></pre><p>也就是说会先执行catch里面的代码后执行finally里面的代码最后才return1 ；</p>\n<p>b.看如下代码：</p>\n<pre><code>try{\n   //待捕获代码    \n}catch（Exception e）{\n    System.out.println(&quot;catch is begin&quot;);\n    return 1 ；\n}finally{\n     System.out.println(&quot;finally is begin&quot;);\n     return 2 ;\n}</code></pre><p>在b代码中输出结果跟a是一样的，然而返回的是return 2 ； 原因很明显，就是执行了finally后已经return了，所以catch里面的return不会被执行到。也就是说finally永远都会在catch的return前被执行。</p>\n<p> <strong>对于异常的捕获不应该觉得方便而将几个异常合成一个Exception进行捕获，比如有IO的异常跟SQL的异常，这样完全不同的两个异常应该分开处理！而且在catch里处理异常的时候不要简单的e.printStackTrace()，而是应该进行详细的处理。比如进行console打印详情或者进行日志记录。</strong></p>\n<p><strong>注意：异常和错误的区别：异常能被程序本身可以处理，错误是无法处理。</strong></p>\n<h4 id="java-java-lang-java-lang-java-">Java 语言定义了一些异常类在 java.lang 标准包中。标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</h4>\n<h4 id="throws-">throws 用在函数上，声明该函数的功能可能会出现问题。</h4>\n<p>将异常抛出，是问题暴露出来，用于处理。</p>\n<p>可以抛给虚拟机处理，或者使用 try....catch... 进行处理。虚拟机的处理方式，就是将异常打印出来，并且将在异常处的代码终止。</p>\n<p>throw 用在代码块中，后面跟着异常的对象，该对象可以是自定义异常，且 throw 使用在方法中。</p>\n<pre><code>class FuShuException extends Exception //getMessage();\n{\n    private int value;\n    FuShuException()\n    {\n        super();\n    }\n    FuShuException(String msg,int value)\n    {\n        super(msg);\n        this.value = value;\n    }\n    public int getValue()\n    {\n        return value;\n    }\n}\n\nclass Demo\n{\n    int div(int a,int b)throws FuShuException\n    {\n        if(b&lt;0) {\n             // 手动通过throw关键字抛出一个自定义异常对象。\n            throw new FuShuException(&quot;出现了除数是负数的情况------ / by fushu&quot;,b);\n        }\n        return a/b;\n    }\n}\n\nclass  ExceptionDemo3\n{\n    public static void main(String[] args)\n    {\n        Demo d = new Demo();\n        try\n        {\n            int x = d.div(4,-9);\n            System.out.println(&quot;x=&quot;+x);\n        }\n        catch (FuShuException e)\n        {\n            System.out.println(e.toString());\n            //System.out.println(&quot;除数出现负数了&quot;);\n            System.out.println(&quot;错误的负数是：&quot;+e.getValue());\n        }\n        System.out.println(&quot;over&quot;);\n    }\n}</code></pre><p>throws 用于方法上，可抛出多个异常，每个异常的类名用逗号隔开。</p>\n<p>try...catch.... 捕获异常时，大的异常(Exception类)放在下方，小的异常放在上方，否则，在异常捕获时，小的异常将不能被捕获，因为全在大的异常类中捕获到。</p>\n<p>即: 如果多个 catch 块中的异常出现继承关系，父类异常 catch 块放在最下面。</p>\n<p>处理异常的方式，不可以直接打印，或者直接输出,正确的处理方式:</p>\n<p> 1.根据异常情况处理对应的逻辑\n 2.使用文件记录异常,便于日后查看</p>\n<pre><code>class FuShuException extends Exception\n{\n    private int value;\n\n    FuShuException() {\n        super();\n    }\n\n    FuShuException(String msg, int value) {\n        super(msg);//调用父类有参构造,获得异常信息\n        this.value = value;\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n}\n\nclass Demo {\n    int div(int a, int b) throws FuShuException {\n        if (b &lt; 0)\n            throw new FuShuException(&quot;出现了除数是负数的情况by fushu&quot;, b);// 手动通过throw关键字抛出一个自定义异常对象。\n        return a / b;\n    }\n}\n\npublic class MyT {\n    public static void main(String[] args) {\n        Demo d = new Demo();\n        try {\n            int x = d.div(4, -9);\n            System.out.println(&quot;x=&quot; + x);\n        } catch (FuShuException e) {\n            System.out.println(e.toString());\n            System.out.println(&quot;错误的负数是：&quot; + e.getValue());\n        }catch (Exception e) {//大的异常放在下方,小的异常放在上方\n            System.out.println(e.getMessage());\n        }\n\n        System.out.println(&quot;end&quot;);\n\n    }\n}</code></pre><p>1.检查型异常（Checked Exception）</p>\n<p>个人理解：所谓检查（Checked）是指编译器要检查这类异常，检查的目的一方面是因为该类异常的发生难以避免，另一方面就是让开发者去解决掉这类异常，所以称为必须处理（try ...catch）的异常。如果不处理这类异常，集成开发环境中的编译器一般会给出错误提示。</p>\n<p>例如：一个读取文件的方法代码逻辑没有错误，但程序运行时可能会因为文件找不到而抛出FileNotFoundException，如果不处理这些异常，程序将来肯定会出错。所以编译器会提示你要去捕获并处理这种可能发生的异常，不处理就不能通过编译。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/21.png?raw=true" alt="image"></p>\n<p>2.非检查型异常（Unchecked Exception）</p>\n<p>个人理解：所谓非检查（Unchecked）是指编译器不会检查这类异常，不检查的则开发者在代码的编辑编译阶段就不是必须处理，这类异常一般可以避免，因此无需处理（try ...catch）。如果不处理这类异常，集成开发环境中的编译器也不会给出错误提示。</p>\n<p>例如：你的程序逻辑本身有问题，比如数组越界、访问null对象，这种错误你自己是可以避免的。编译器不会强制你检查这种异常。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/22.png?raw=true" alt="image"></p>\n'},Ibhu:function(n,t,i){var e=i("D2L2"),l=i("TcQ7"),o=i("vFc/")(!1),a=i("ax3d")("IE_PROTO");n.exports=function(n,t){var i,r=l(n),p=0,s=[];for(i in r)i!=a&&e(r,i)&&s.push(i);for(;t.length>p;)e(r,i=t[p++])&&(~o(s,i)||s.push(i));return s}},IyHp:function(n,t){n.exports='<h4 id="formatting-context-">Formatting context 格式化上下文</h4>\n<h5 id="formatting-context">Formatting context</h5>\n<p>W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</p>\n<h5 id="-formatting-context">常见Formatting context</h5>\n<ul>\n<li>Block fomatting context (BFC)</li>\n<li>Inline formatting context (IFC)。</li>\n</ul>\n<h5 id="box-css-">Box: CSS布局的基本单位</h5>\n<p>Box 是 CSS 布局的对象和基本单位， 一个页面是由多个 Box 组成的。元素的类型和display 属性，决定了这个Box类型。 不同类型的Box，会参与不同的Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。</p>\n<ul>\n<li>block-level box:display属性为block,list-item,table 的元素，会生成block-level box。并且参与 block fomatting context；</li>\n<li>inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 * inline-level box。并且参与 inline formatting context；</li>\n</ul>\n<h5 id="bfc-">BFC定义</h5>\n<p>BFC(Block formatting context):块级元素格式化上下文，独立的渲染区域，只有block-level box参与，它规定内部的Block-level box如何布局，并且与区域之外元素互不相关。</p>\n<h5 id="bfc-">BFC布局规则</h5>\n<ol>\n<li>内部的Box会在垂直方向，一个接一个放置</li>\n<li>box垂直方向的距离由margin决定，相邻的box的margin会重叠</li>\n<li>每个元素的左外边缘（margin-left)， 与父容器（containing box）的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</li>\n<li>BFC的区域不会与float box重叠</li>\n<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。</li>\n<li>计算BFC的高度时，浮动元素也参与计算</li>\n</ol>\n<h5 id="bfc-3">BFC布局规则3</h5>\n<p>每个元素的左外边缘（margin-left)， 与父容器（containing box）的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。除非这个元素自己形成了一个新的BFC。</p>\n<pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;\n        float: left;\n        background: #f66;\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/2.png?raw=true" alt="image"></p>\n<h5 id="bfc-4">BFC布局规则4</h5>\n<p>设置main元素为overflow: hidden;使其成为BFC,BFC的区域不会与float box重叠</p>\n<pre><code>&lt;style&gt;\n    body {\n        width: 300px;\n    }\n\n    .aside {\n        width: 100px;\n        height: 150px;\n        float: left;\n        background: #f66;\n    }\n\n    .main {\n        height: 200px;\n        background: #fcc;\n        overflow: hidden;\n    }\n&lt;/style&gt;\n&lt;body&gt;\n    &lt;div class=&quot;aside&quot;&gt;&lt;/div&gt;\n    &lt;div class=&quot;main&quot;&gt;&lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/3.png?raw=true" alt="image"></p>\n<h5 id="bfc-2">BFC布局规则2</h5>\n<p>box垂直方向的距离由margin决定，相邻的box的margin会重叠</p>\n<pre><code>&lt;style&gt;\n    p {\n        color: #f55;\n        background: #fcc;\n        width: 200px;\n        line-height: 100px;\n        text-align: center;\n        margin: 100px;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;p&gt;Haha&lt;/p&gt;\n    &lt;p&gt;Hehe&lt;/p&gt;\n&lt;/body&gt;\n</code></pre><p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/6.png?raw=true" alt="image"></p>\n<h4 id="-"><a href="https://www.w3.org/TR/CSS2/visuren.html#block-formatting">原文</a>：</h4>\n<p>Floats, absolutely positioned elements, block containers (such as inline-blocks, table-cells, and table-captions) that are not block boxes, and block boxes with &#39;overflow&#39; other than &#39;visible&#39; (except when that value has been propagated to the viewport) establish new block formatting contexts for their contents.</p>\n<p>In a block formatting context, boxes are laid out one after the other, vertically, beginning at the top of a containing block. The vertical distance between two sibling boxes is determined by the &#39;margin&#39; properties. Vertical margins between adjacent block-level boxes in a block formatting context collapse.</p>\n<p>In a block formatting context, each box&#39;s left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box&#39;s line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).</p>\n<h5 id="-">创建块格式化上下文：</h5>\n<ul>\n<li>根元素或包含根元素的元素</li>\n<li>浮动元素（元素的 float 不是 none）</li>\n<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>\n<li>行内块元素（元素的 display 为 inline-block）</li>\n<li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>\n<li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>\n<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</li>\n<li>overflow 值不为 visible 的块级元素</li>\n<li>display 值为 flow-root 的元素</li>\n<li>contain 值为 layout、content或 strict 的元素</li>\n<li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>\n<li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>\n<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>\n<li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>\n</ul>\n<h5 id="-bfc-">利用BFC清除浮动</h5>\n<p>设置main元素为overflow: hidden;使其成为BFC,BFC的区域不会与float box重叠</p>\n<pre><code>&lt;style&gt;\n    .par {\n        border: 5px solid #fcc;\n        width: 300px;\n        overflow: hidden;//成为BFC\n    }\n\n    .child {\n        border: 5px solid #f66;\n        width: 100px;\n        height: 100px;\n        float: left;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;par&quot;&gt;\n        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/4.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/5.png?raw=true" alt="image"></p>\n<h5 id="-bfc-margin-">利用BFC处理margin重叠</h5>\n<p>p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。</p>\n<pre><code>&lt;style&gt;\n    .par {\n        border: 5px solid #fcc;\n        width: 300px;\n        overflow: hidden;//成为BFC\n    }\n\n    .child {\n        border: 5px solid #f66;\n        width: 100px;\n        height: 100px;\n        float: left;\n    }\n&lt;/style&gt;\n\n&lt;body&gt;\n    &lt;div class=&quot;par&quot;&gt;\n        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n        &lt;div class=&quot;child&quot;&gt;&lt;/div&gt;\n    &lt;/div&gt;\n&lt;/body&gt;\n</code></pre><p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/7.png?raw=true" alt="image"></p>\n'},KDwC:function(n,t){n.exports='<h4 id="-">数据链路层基本概念及基本问题</h4>\n<ul>\n<li>链路：一条点到点的物理线路段，中间没有任何其他的交换结点，通俗的将，就是一根线，其中不经过任何东西，这样的就是链路，一条链路只是一条通路的一个组成部分。</li>\n<li>数据链路：除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了<strong>数据链路</strong>。通俗讲，就是经过了一些交换机之类，最终到达目的地，所有路段就是数据链路，而数据链路中就包含了多段链路。</li>\n<li>适配器：也就是网卡，实现数据链路上一些协议。</li>\n<li>帧：数据链路层上传送的就是帧</li>\n</ul>\n<h5 id="-">三个基本问题　　　　</h5>\n<p>封装成帧、透明传输、差错控制</p>\n<ul>\n<li><p>封装成帧：数据链路层就是在ip数据报的前后加了一个首部和尾部来代表ip数据包的开始和结束，首部和尾部都市由8位二进制数表示的，可以一样也可以不一样。</p>\n</li>\n<li><p>透明传输：在ip数据包中如果有一个跟帧尾部一样的8位二进制数，则会提前结束接受数据包，这样数据就被破坏了。解决办法：通过在特殊字符前面增加一个转义字符 ESC，就可以解决上面所遇到的问题，在接收端，将数据包中所有ESC的字符删除，遇到两个ESC的，就删除第一个，这样一开始传输的时候有ESC转义字符，接受完就没了，所以说的是透明传输。</p>\n</li>\n<li><p>差错检测\n问题：传输过程中可能会产生比特差错：1 可能会变成0而0也可能变成1。在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率 BER (Bit Error Rate)。为了检测传送的帧中ip数据包是否完整，是否没有被损坏，所以需要差错检测。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/44.png?raw=true" alt="image"> </p>\n</li>\n</ul>\n<h4 id="-">可靠传输</h4>\n<p>在有些情况下，我们需要数据链路层向上的网络层提供“可靠传输”的服务，就是发送端发送什么，在对应的接收端就收到什么，前面的CRC只能检测出位数的差错，不能正确的检测出更精准的错误。</p>\n<ul>\n<li>停止等待协议：停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组</li>\n<li>超时重传：解决上面如果数据分组或确认分组丢失时，发送方将会一直等待接收方的确认分组的问题，设置一个超时计时器如果到了超时计时器所设置的重传时间，而发送方仍收不到接收方的任何确认分组，则会重传原来的分组。</li>\n<li>重复分组：如果只使用超时重传来解决，不用发送确认分组，那么会出现重复分组的问题，就是当接收方收到分组后，发回确认分组时，确认分组丢失，那么会触发超时重传，则接收方会收到两个重复的分组，这里需要注意的是，是确认分组丢失。第一次发送的分组已经正确接收了。</li>\n<li>回退N步协议：其实跟停止等待协议差不多，只是使用的是流水线传输方式，发送方不间断的发送分组，每次发送的分组大小有限制，如果不限制，可能会使接收方或网络来不及处理这些分组，导致分组的丢失，所以每次发送的分组大小可能是5，6或者更多。这种限制就是回退N步协议。回退N步协议利用发送窗口来限制发送方连续发送分组的个数。要是发送窗口为1就是我们上面所讨论的停止等待协议。</li>\n<li>选择重传协议：也就是改进回退N布协议，方式都是一样，在接受方必须逐一确认，但是出现错误，只需要重传出现错误的那一个分组，不用全部重传，这里的全部，指的是在出现错误的分组之后的所有分组，前提是在同一个发送窗口中。</li>\n</ul>\n<h4 id="-">两种情况下的数据链路层</h4>\n<h5 id="-ppp">点对点协议PPP</h5>\n<p>概述：现在全世界使用的最多的数据链路层协议就是点对点协议PPP(Point to Point Protocol)，我们大多数用户使用的拨号电话线接入因特网时，一般使用的就是PPP协议\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/44.png?raw=true" alt="image"> \nPPP协议的特点：</p>\n<ul>\n<li>简单：接收方每接收一个帧，就进行CRC检验，检验正确，就收下，否则就丢弃，它是不可靠传输</li>\n<li>封装成帧</li>\n<li>多种网络层协议：数据链路层的上一层就是网络层，所以它同时支持多种网络层协议的运行</li>\n<li>多种类型链路：比如，串行的、并行的，（串行：一个比特一个比特发送，只需要一条线路，并行：一次性传输n个比特，所以需要n条线路，所以叫并行）同步的、异步的（同步：以稳定的比特流的形式传输 </li>\n<li>异步：以字节为独立的传输单位，字节跟字节之间的时间间隔不确定，但字节中的每个比特仍是同步的），低速或高速、电或光，等不同类型的链路都能支持</li>\n<li>差错检测：就是用CRC来检验</li>\n<li>透明传输</li>\n<li>检测连接状态：检测点跟点之间的连接状态，也就是在PC机和ISP之间的线路。</li>\n<li>最大传送单位：PPP协议帧有最大的传送单元，发送的分组不能超过这个最大长度</li>\n<li>网络层地址协商：使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址，通俗的讲，就是在分配IP地址时，就现需要这个协商才能解决</li>\n</ul>\n<p>PPP协议的组成</p>\n<ul>\n<li>数据链路层协可以用于异步串行或同步串行介质，通俗讲也就是可以适应多种性质的链路，有这种介质存在</li>\n<li>使用LCP(链路控制协议)建立并维护数据链路连接，也就是上面讲的一些维护链路连接、检测连接状态等功能，就是用它来实现的</li>\n<li>网络控制协议(NCP)允许点到点连接上使用多种网络层协议，也就是因为跟网络层连接在一起，所以需要支持上一层的多种协议，这样才能完成一系列的功能，比如，网络层地址协商\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/45.png?raw=true" alt="image"><br>PPP协议帧格式\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/46.png?raw=true" alt="image">  </li>\n</ul>\n<p>PPP协议帧传输时的透明传输问题</p>\n<ul>\n<li>字节填充：使用的是字节传输，也就是异步，所有的PPP帧的长度都是整数字节，所以会出现IP数据包中有字节跟开始结束标志字节相同的问题</li>\n<li>解决：标志字段 F = 0x7E</li>\n<li>IP数据包中出现0x7E字节：转变为0x7D、0x5E</li>\n<li>IP数据包中出现0x7D：0x7D、0x5D</li>\n<li>IP数据包中出现ASCII码的控制字符，则在该控制字符前面加0x7D</li>\n<li>零比特填充方法：使用的是比特流传输(一连串的比特连续传送)，也就是同步，PPP协议就采用零比特填充方法来实现透明传输</li>\n</ul>\n<p>PPP协议的工作状态\n链路静止、链路建立、鉴别、网络层协议、链路打开、链路终止<br><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/47.png?raw=true" alt="image">  </p>\n<h5 id="-ppp-">具体细节：六步。正好验证了PPP协议的三部分组成</h5>\n<ul>\n<li>链路静止到链路建立：用户拨号接通ISP拨号服务器后，就创建了PC机到ISP服务器的物理连接，这里面的细节就归咎于物理层的功劳了，创建了一条怎么样的信道，通过什么传送数据，都是物理层需要做的事情。</li>\n<li>链路建立到鉴别：建立了物理连接后，PPP中LCP(链路控制协议)就需要做事了，LCP协商一些配置选项(链路上的最大帧长，所使用的鉴别协议，或者不使用PPP帧中的地址和控制字段)，如何跟ISP协商这些呢，就是通过发送LCP的配置请求帧，而ISP也可以发送几种响应，配置确认帧：所有选项都接受配置否认帧：所有选项都理解但不能接受配置拒绝帧：有的选项无法识别或不能接受，需要协商。通过一系列的协商后，此过程就结束了，就到了鉴别状态，如果协商失败，就直接回到链路静止状态。</li>\n<li>鉴别到网络层协议：这里到达网络层协议之间做的事情就是鉴别身份。只允许传送LCP协议的分组、鉴别协议的分组以及检测链路质量的分组。若使用口令鉴别协议PAP(Password Authentication Protocol)，则需要发起通信的一方发送身份标识符和口令。系统可运行用户重试若干次。如果需要有更好的安全性，则可使用更加复杂的口令握手鉴别协议CHAP(Challenge-Handshake Authentication Protocol)。若鉴别身份失败，则转到链路终止状态(Link Dead)。若鉴别成功，则进入网络层协议状态(Network-Layer Protocol)。</li>\n<li>网络层协议到链路打开：前面已经经过了PPP协议的前两层，接下来就是NCP(网络控制协议)做事的时候了，这一阶段就是给PC机分配一个IP地址和对链路层进行网络层协议的设置，让链路层能支持网络层的工作</li>\n<li>链路打开到链路终止：进行传输数据，如果传输完成，就发送终止请求分组，收到终止确认分组后，就到了终止状态</li>\n<li>链路终止到链路静止：当物理层没有载波时，就到静止状态</li>\n</ul>\n<h4 id="ppp-">PPP协议为什么不适用序号和确认机制？</h4>\n<ul>\n<li>在数据链路层出现差错的概率不大时，使用比较简单的PPP协议较为合理。</li>\n<li>在因特网环境下，PPP的信息字段放入的数据是IP数据报。数据链路层的可靠传输并不能够保证网络层的传输也是可靠的。</li>\n<li>帧检验序列 FCS 字段可保证无差错接受。</li>\n</ul>\n<h4 id="-">广播信道的数据链路层</h4>\n<p>以太网和局域网的区别</p>\n<ul>\n<li>以太网是通信协议标准，该标准定义了在局域网（LAN）中采用的电缆类型和信号处理方法，比如有CSMA/CD协议。</li>\n<li>局域网：在较小范围内组件的网络，通过交换器什么的连接各个PC机，比如一个实验室，一栋楼，一个校园内，这都是局域网，拿网线将两台计算机连在一起，这也能算是局域网</li>\n<li>以太网是一种局域网，而局域网却不一定是以太网，大多数局域网就是采用了以太网的这个标准，所以很多人就将局域网默认为以太网，这种说法是有点偏差的。</li>\n<li>在局域网中，就采用的是广播信道，广播信道就是一台PC机发送数据给另一台PC机，在同一个局域网中的计算机都能接收到该数据，这就像广播一样，所以这种就叫做广播信道。</li>\n</ul>\n<h4 id="-">局域网的常用拓扑结构</h4>\n<h5 id="csma-cd-">CSMA/CD：半双工通信</h5>\n<ul>\n<li>多址接入：一种多址接入协议，许多站点以多址接入的方式链接在一根总线上，其实就是局域网中总线网这种形式。</li>\n<li>载波监听：发送前监听，就是在发送数据前监听总线中是否有数据在传播，如果有就不发送。就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li>\n<li>碰撞检测：边发送边监听，在发送数据的中途也会监听总线中是否会有其它数据，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当一个站检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。 所谓“碰撞”就是发生了冲突。因此“碰撞检测”也称为“冲突检测”，检测到碰撞后，在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。</li>\n</ul>\n'},L42u:function(n,t,i){var e,l,o,a=i("+ZMJ"),r=i("knuC"),p=i("RPLV"),s=i("ON07"),c=i("7KvD"),u=c.process,h=c.setImmediate,d=c.clearImmediate,g=c.MessageChannel,m=c.Dispatch,v=0,f={},b=function(){var n=+this;if(f.hasOwnProperty(n)){var t=f[n];delete f[n],t()}},S=function(n){b.call(n.data)};h&&d||(h=function(n){for(var t=[],i=1;arguments.length>i;)t.push(arguments[i++]);return f[++v]=function(){r("function"==typeof n?n:Function(n),t)},e(v),v},d=function(n){delete f[n]},"process"==i("R9M2")(u)?e=function(n){u.nextTick(a(b,n,1))}:m&&m.now?e=function(n){m.now(a(b,n,1))}:g?(o=(l=new g).port2,l.port1.onmessage=S,e=a(o.postMessage,o,1)):c.addEventListener&&"function"==typeof postMessage&&!c.importScripts?(e=function(n){c.postMessage(n+"","*")},c.addEventListener("message",S,!1)):e="onreadystatechange"in s("script")?function(n){p.appendChild(s("script")).onreadystatechange=function(){p.removeChild(this),b.call(n)}}:function(n){setTimeout(a(b,n,1),0)}),n.exports={set:h,clear:d}},LFqA:function(n,t){n.exports='<h3 id="java-">Java 对象和类</h3>\n<p>Java作为一种面向对象语言。支持以下基本概念：</p>\n<ul>\n<li>多态</li>\n<li>继承</li>\n<li>封装</li>\n<li>抽象</li>\n<li>类</li>\n<li>对象</li>\n<li>实例</li>\n<li>方法</li>\n<li>重载</li>\n</ul>\n<h4 id="-">对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。</h4>\n<h4 id="-">类：类是一个模板，它描述一类对象的行为和状态。</h4>\n<p>一个类可以包含以下类型变量：</p>\n<ul>\n<li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。</li>\n<li>成员变量：成员变量是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。</li>\n<li>类变量：类变量也声明在类中，方法体之外，<strong>但必须声明为static类型。</strong><h4 id="-">构造方法</h4>\n每个类都有构造方法。如果没有显式地为类定义构造方法，Java编译器将会为该类提供一个默认构造方法。\n在创建一个对象的时候，至少要调用一个构造方法。构造方法的名称必须与类同名，<strong>一个类可以有多个构造方法</strong></li>\n</ul>\n<h4 id="-">创建对象</h4>\n<p>对象是根据类创建的。在Java中，使用关键字new来创建一个新的对象。创建对象需要以下三步：</p>\n<ul>\n<li>声明：声明一个对象，包括对象名称和对象类型。</li>\n<li>实例化：使用关键字new来创建一个对象。</li>\n<li>**初始化：使用new创建对象时，会调用构造方法初始化对象。</li>\n</ul>\n<h4 id="-">源文件声明规则</h4>\n<p>在本节的最后部分，我们将学习源文件的声明规则。当在一个源文件中定义多个类，并且还有import语句和package语句时，要特别注意这些规则。</p>\n<ul>\n<li>一个源文件中只能有一个public类</li>\n<li>一个源文件可以有多个非public类</li>\n<li><strong>源文件的名称应该和public类的类名保持一致</strong>。</li>\n<li>如果一个类定义在某个包中，那么package语句应该在源文件的首行。</li>\n<li>如果源文件包含import语句，那么应该放在package语句和类定义之间。如果没有package语句，那么import语句应该在源文件中最前面。</li>\n<li>import语句和package语句对源文件中定义的所有类都有效。在同一源文件中，不能给不同的类不同的包声明。</li>\n<li>类有若干种访问级别，并且类也分不同的类型：抽象类和final类等。</li>\n<li>除了上面提到的几种类型，Java还有一些特殊的类，如：内部类、匿名类。</li>\n</ul>\n<h4 id="java-">Java包</h4>\n<p>包主要用来对类和接口进行分类。当开发Java程序时，可能编写成百上千的类，因此很有必要对类和接口进行分类。</p>\n<h4 id="import-">Import语句</h4>\n<p>在Java中，如果给出一个完整的限定名，包括包名、类名，那么Java编译器就可以很容易地定位到源代码或者类。Import语句就是用来提供一个合理的路径，使得编译器可以找到某个类。</p>\n<hr>\n<h3 id="java-">Java 基本数据类型</h3>\n<p><strong>变量就是申请内存来存储值</strong>。内存管理系统根据变量的类型为变量分配存储空间，分配的空间只能用来储存该类型数据。\n内置数据类型\nJava语言提供了八种基本类型。六种数字类型（四个整数型，两个浮点型），一种字符类型，还有一种布尔型。</p>\n<ul>\n<li><p>byte：</p>\n<ul>\n<li>byte 数据类型是8位、有符号的，以二进制补码表示的整数；</li>\n<li>最小值是 -128（-2^7）；</li>\n<li>最大值是 127（2^7-1）；</li>\n<li>默认值是 0；</li>\n<li>byte 类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一；</li>\n<li>例子：byte a = 100，byte b = -50。</li>\n</ul>\n</li>\n<li><p>short：</p>\n<ul>\n<li>short 数据类型是16位、有符号的以二进制补码表示的整数</li>\n<li>最小值是 -32768（-2^15）</li>\n<li>最大值是 32767（2^15 - 1）</li>\n<li>Short 数据类型也可以像byte那样节省空间。一个short变量是int型变量所占空间的二分之一</li>\n<li>默认值是 0；</li>\n<li>例子：short s = 1000，short r = -20000</li>\n</ul>\n</li>\n<li><p>int：</p>\n<ul>\n<li>int 数据类型是32位、有符号的以二进制补码表示的整数；</li>\n<li>最小值是 -2,147,483,648（-2^31）；</li>\n<li>最大值是 2,147,483,647（2^31 - 1）；</li>\n<li>一般地整型变量默认为 int 类型；</li>\n<li>默认值是 0 </li>\n<li>例子：int a = 100000, int b = -200000。</li>\n</ul>\n</li>\n<li><p>long：</p>\n<ul>\n<li>long 数据类型是 64 位、有符号的以二进制补码表示的整数；</li>\n<li>最小值是 -9,223,372,036,854,775,808（-2^63）；</li>\n<li>最大值是 9,223,372,036,854,775,807（2^63 -1）；</li>\n<li>这种类型主要使用在需要比较大整数的系统上</li>\n<li>默认值是 0L；</li>\n<li>例子： long a = 100000L，Long b = -200000L。&quot;L&quot;理论上不分大小写，但是若写成&quot;l&quot;容易与数字&quot;1&quot;混淆，不容易分辩。所以最好大写。</li>\n</ul>\n</li>\n<li><p>float：</p>\n<ul>\n<li>float 数据类型是单精度、32位、符合IEEE 754标准的浮点数；</li>\n<li>float 在储存大型浮点数组的时候可节省内存空间；</li>\n<li>默认值是 0.0f；</li>\n<li>浮点数不能用来表示精确的值，如货币</li>\n<li>例子：float f1 = 234.5f。</li>\n</ul>\n</li>\n<li><p>double：</p>\n<ul>\n<li>double 数据类型是双精度、64 位、符合IEEE 754标准的浮点数；</li>\n<li>浮点数的默认类型为double类型；</li>\n<li>double类型同样不能表示精确的值，如货币</li>\n<li>默认值是 0.0d；</li>\n<li>例子：double d1 = 123.4。</li>\n</ul>\n</li>\n<li><p>boolean：</p>\n<ul>\n<li>boolean数据类型表示一位的信息</li>\n<li>只有两个取值：true 和 false</li>\n<li>这种类型只作为一种标志来记录 true/false 情况</li>\n<li>默认值是 false；</li>\n<li>例子：boolean one = true。</li>\n</ul>\n</li>\n<li><p>char：</p>\n<ul>\n<li>char类型是一个单一的 16 位 Unicode 字符</li>\n<li>最小值是 \\u0000（即为0）；</li>\n<li>最大值是 \\uffff（即为65,535）；</li>\n<li>char 数据类型可以储存任何字符；</li>\n<li>例子：char letter = &#39;A&#39;;。</li>\n</ul>\n</li>\n</ul>\n<h4 id="-">引用类型</h4>\n<ul>\n<li>在Java中，引用类型的变量非常类似于C/C++的指针。引用类型指向一个对象，指向对象的变量是引用变量。这些变量在声明时被指定为一个特定的类型，比如 Employee、Puppy 等。变量一旦声明后，类型就不能被改变了。</li>\n<li>对象、数组都是引用数据类型。</li>\n<li>所有引用类型的默认值都是null。</li>\n<li>一个引用变量可以用来引用任何与之兼容的类型。</li>\n<li>例子：Site site = new Site(&quot;Runoob&quot;)。</li>\n</ul>\n<h4 id="java-">Java 常量</h4>\n<p>常量在程序运行时是不能被修改的。\n在 Java 中使用 final 关键字来修饰常量，声明方式和变量类似：\n虽然常量名也可以用小写，但为了便于识别，通常使用大写字母表示常量。</p>\n<pre><code>final double PI = 3.1415927;</code></pre><h4 id="java-">Java语言支持一些特殊的转义字符序列。</h4>\n<ul>\n<li>\\n 换行</li>\n<li>\\r 回车</li>\n<li>\\ 反斜杠</li>\n</ul>\n<h4 id="-">自动类型转换</h4>\n<p>整型、实型（常量）、字符型数据可以混合运算。运算中，不同类型的数据先转化为同一类型，然后进行运算。转换从低级到高级。</p>\n<pre><code>低  ------------------------------------&gt;  高\n\nbyte,short,char—&gt; int —&gt; long—&gt; float —&gt; double</code></pre><h4 id="-">数据类型转换必须满足如下规则：</h4>\n<ul>\n<li>不能对boolean类型进行类型转换。</li>\n<li>不能把对象类型转换成不相关类的对象。</li>\n<li>在把容量大的类型转换为容量小的类型时必须使用强制类型转换。</li>\n<li>转换过程中可能导致溢出或损失精度</li>\n<li>浮点数到整数的转换是通过舍弃小数得到，而不是四舍五入</li>\n<li>必须满足转换前的数据类型的位数要低于转换后的数据类型</li>\n</ul>\n<h4 id="-">强制类型转换</h4>\n<ul>\n<li>条件是转换的数据类型必须是兼容的。</li>\n<li>格式：(type)value type是要强制类型转换后的数据类型</li>\n</ul>\n<h4 id="-">隐含强制类型转换</h4>\n<ul>\n<li>整数的默认类型是 int。</li>\n<li>浮点型不存在这种情况，因为在定义 float 类型时必须在数字后面跟上F或者f。</li>\n</ul>\n<hr>\n<h3 id="java-">Java 变量类型</h3>\n<p>在Java语言中，所有的变量在使用前必须声明。声明变量的基本格式如下：\ntype identifier [ = value][, identifier [= value] ...] ;</p>\n<h4 id="java-">Java语言支持的变量类型有：</h4>\n<ul>\n<li>类变量：独立于方法之外的变量，用 static 修饰。</li>\n<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。</li>\n<li>局部变量：类的方法中的变量。</li>\n</ul>\n<h4 id="java-">Java 局部变量</h4>\n<ul>\n<li>局部变量声明在方法、构造方法或者语句块中；</li>\n<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>\n<li>访问修饰符不能用于局部变量；</li>\n<li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li>\n<li><strong>局部变量是在栈上分配的</strong>。</li>\n<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>\n</ul>\n<h4 id="-">实例变量</h4>\n<ul>\n<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>\n<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>\n<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>\n<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>\n<li>实例变量可以声明在使用前或者使用后；</li>\n<li>访问修饰符可以修饰实例变量；</li>\n<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>\n<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>\n<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>\n</ul>\n<h4 id="-">类变量（静态变量）</h4>\n<ul>\n<li><strong>类变量也称为静态变量</strong>，在类中以static关键字声明，但必须在方法构造方法和语句块之外。</li>\n<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>\n<li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。</li>\n<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。</li>\n<li>静态变量在第一次被访问时创建，在程序结束时销毁。</li>\n<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。</li>\n<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>\n<li>静态变量可以通过：ClassName.VariableName的方式访问。</li>\n<li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>\n</ul>\n<hr>\n<h3 id="java-">Java 修饰符</h3>\n<p>Java语言提供了很多修饰符，主要分为以下两类：</p>\n<ul>\n<li>访问修饰符</li>\n<li>非访问修饰符</li>\n</ul>\n<p>修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p>\n<pre><code>public class className {\n   // ...\n}\nprivate boolean myFlag;\nstatic final double weeks = 9.5;\nprotected static final int BOXWIDTH = 42;\npublic static void main(String[] arguments) {\n   // 方法体\n}</code></pre><h5 id="-">访问控制修饰符</h5>\n<p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>\n<ul>\n<li>default (即缺省，什么也不写）:在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</li>\n<li>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</li>\n<li>public : 对所有类可见。使用对象：类、接口、变量、方法</li>\n<li>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</li>\n</ul>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/2.png?raw=true" alt="image"></p>\n<h5 id="-private">私有访问修饰符-private</h5>\n<p>私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p>\n<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p>\n<p>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>\n<p>下面的类使用了私有访问修饰符：</p>\n<pre><code>public class Logger {\n   private String format;\n   public String getFormat() {\n      return this.format;\n   }\n   public void setFormat(String format) {\n      this.format = format;\n   }\n}</code></pre><h4 id="-public">公有访问修饰符-public</h4>\n<p>被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p>\n<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>\n<p>以下函数使用了公有访问控制：</p>\n<pre><code>public static void main(String[] arguments) {\n   // ...\n}</code></pre><p>Java 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。</p>\n<h4 id="-protected">受保护的访问修饰符-protected</h4>\n<p>protected 需要从以下两个点来分析说明：</p>\n<ul>\n<li><p>子类与基类在同一包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其他类访问；</p>\n</li>\n<li><p>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法。</p>\n</li>\n<li><p>protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）</p>\n</li>\n</ul>\n<h4 id="-">访问控制和继承</h4>\n<p>请注意以下方法继承的规则：</p>\n<ul>\n<li>父类中声明为 public 的方法在子类中也必须为 public。</li>\n<li>父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不能声明为 private。</li>\n<li>父类中声明为 private 的方法，不能够被继承。</li>\n</ul>\n<h4 id="-">非访问修饰符</h4>\n<p>为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>\n<ul>\n<li>static 修饰符，用来修饰类方法和类变量。</li>\n<li>final 修饰符，用来修饰类、方法和变量，final修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</li>\n<li>abstract 修饰符，用来创建抽象类和抽象方法。</li>\n<li>synchronized 和 volatile 修饰符，主要用于线程的编程。</li>\n</ul>\n<h4 id="static-">static 修饰符</h4>\n<ul>\n<li>静态变量：</li>\n</ul>\n<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>\n<ul>\n<li>静态方法：</li>\n</ul>\n<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>\n<p>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</p>\n<h4 id="final-">final 修饰符</h4>\n<ul>\n<li>final 变量：\nfinal 表示&quot;最后的、最终的&quot;含义，变量一旦赋值后，不能被重新赋值。被final修饰的实例变量必须显式指定初始值。\nfinal 修饰符通常和static修饰符一起使用来创建类常量。</li>\n<li>final 方法\n类中的final方法可以被子类继承，但是不能被子类修改。声明 final 方法的主要目的是防止该方法的内容被修改。</li>\n</ul>\n<h4 id="abstract-">abstract 修饰符</h4>\n<h5 id="-">抽象类：</h5>\n<ul>\n<li>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</li>\n<li>一个类不能同时被abstract和final修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</li>\n<li>抽象类可以包含抽象方法和非抽象方法。</li>\n</ul>\n<h5 id="-">抽象方法：</h5>\n<ul>\n<li>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</li>\n<li>抽象方法不能被声明成 final 和 static。</li>\n<li>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</li>\n<li>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</li>\n<li>抽象方法的声明以分号结尾，例如：public abstract sample();。</li>\n</ul>\n<h5 id="synchronized-">synchronized 修饰符</h5>\n<p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized 修饰符可以应用于四个访问修饰符。</p>\n<p>Java 教程\nJava 教程\nJava 简介\nJava 开发环境配置\nJava 基础语法\nJava 对象和类\nJava 基本数据类型\nJava 变量类型\nJava 修饰符\nJava 运算符\nJava 循环结构\nJava 条件语句\nJava switch case\nJava Number &amp; Math 类\nJava Character 类\nJava String 类\nJava StringBuffer\nJava 数组\nJava 日期时间\nJava 正则表达式\nJava 方法\nJava Stream、File、IO\nJava Scanner 类\nJava 异常处理</p>\n<p>Java 面向对象\nJava 继承\nJava Override/Overload\nJava 多态\nJava 抽象类\nJava 封装\nJava 接口\nJava 包(package)</p>\n<p>Java 高级教程\nJava 数据结构\nJava 集合框架\nJava 泛型\nJava 序列化\nJava 网络编程\nJava 发送邮件\nJava 多线程编程\nJava Applet 基础\nJava 文档注释\nJava 实例\nJava 8 新特性\nJava MySQL 连接\nJava 9 新特性\n Java 变量类型 Java 运算符 \nJava 修饰符\nJava语言提供了很多修饰符，主要分为以下两类：</p>\n<p>访问修饰符\n非访问修饰符\n修饰符用来定义类、方法或者变量，通常放在语句的最前端。我们通过下面的例子来说明：</p>\n<p>public class className {\n   // ...\n}\nprivate boolean myFlag;\nstatic final double weeks = 9.5;\nprotected static final int BOXWIDTH = 42;\npublic static void main(String[] arguments) {\n   // 方法体\n}\n访问控制修饰符\nJava中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。</p>\n<p>default (即缺省，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>\n<p>private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）</p>\n<p>public : 对所有类可见。使用对象：类、接口、变量、方法</p>\n<p>protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）。</p>\n<p>我们可以通过以下表来说明访问权限：</p>\n<p>访问控制\n修饰符    当前类    同一包内    子孙类(同一包)    子孙类(不同包)    其他包\npublic    Y    Y    Y    Y    Y\nprotected    Y    Y    Y    Y/N（说明）    N\ndefault    Y    Y    Y    N    N\nprivate    Y    N    N    N    N\n默认访问修饰符-不使用任何关键字\n使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。接口里的变量都隐式声明为 public static final,而接口里的方法默认情况下访问权限为 public。</p>\n<p>如下例所示，变量和方法的声明可以不使用任何修饰符。</p>\n<p>实例\nString version = &quot;1.5.1&quot;;\nboolean processOrder() {\n   return true;\n}\n私有访问修饰符-private\n私有访问修饰符是最严格的访问级别，所以被声明为 private 的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为 private。</p>\n<p>声明为私有访问类型的变量只能通过类中公共的 getter 方法被外部类访问。</p>\n<p>Private 访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据。</p>\n<p>下面的类使用了私有访问修饰符：</p>\n<p>public class Logger {\n   private String format;\n   public String getFormat() {\n      return this.format;\n   }\n   public void setFormat(String format) {\n      this.format = format;\n   }\n}\n实例中，Logger 类中的 format 变量为私有变量，所以其他类不能直接得到和设置该变量的值。为了使其他类能够操作该变量，定义了两个 public 方法：getFormat() （返回 format的值）和 setFormat(String)（设置 format 的值）</p>\n<p>公有访问修饰符-public\n被声明为 public 的类、方法、构造方法和接口能够被任何其他类访问。</p>\n<p>如果几个相互访问的 public 类分布在不同的包中，则需要导入相应 public 类所在的包。由于类的继承性，类所有的公有方法和变量都能被其子类继承。</p>\n<p>以下函数使用了公有访问控制：</p>\n<p>public static void main(String[] arguments) {\n   // ...\n}\nJava 程序的 main() 方法必须设置成公有的，否则，Java 解释器将不能运行该类。</p>\n<p>受保护的访问修饰符-protected\nprotected 需要从以下两个点来分析说明：</p>\n<p>子类与基类在同一包中：被声明为 protected 的变量、方法和构造器能被同一个包中的任何其他类访问；</p>\n<p>子类与基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的 protected 方法，而不能访问基类实例的protected方法。</p>\n<p>protected 可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）。</p>\n<p>接口及接口的成员变量和成员方法不能声明为 protected。 可以看看下图演示：</p>\n<p>子类能访问 protected 修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量。</p>\n<p>下面的父类使用了 protected 访问修饰符，子类重写了父类的 openSpeaker() 方法。</p>\n<p>class AudioPlayer {\n   protected boolean openSpeaker(Speaker sp) {\n      // 实现细节\n   }\n}</p>\n<p>class StreamingAudioPlayer extends AudioPlayer {\n   protected boolean openSpeaker(Speaker sp) {\n      // 实现细节\n   }\n}\n如果把 openSpeaker() 方法声明为 private，那么除了 AudioPlayer 之外的类将不能访问该方法。</p>\n<p>如果把 openSpeaker() 声明为 public，那么所有的类都能够访问该方法。</p>\n<p>如果我们只想让该方法对其所在类的子类可见，则将该方法声明为 protected。</p>\n<p>protected 是最难理解的一种 Java 类成员访问权限修饰词，更多详细内容请查看 Java protected 关键字详解。</p>\n<p>访问控制和继承\n请注意以下方法继承的规则：</p>\n<p>父类中声明为 public 的方法在子类中也必须为 public。</p>\n<p>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</p>\n<p>父类中声明为 private 的方法，不能够被继承。</p>\n<p>非访问修饰符\n为了实现一些其他的功能，Java 也提供了许多非访问修饰符。</p>\n<p>static 修饰符，用来修饰类方法和类变量。</p>\n<p>final 修饰符，用来修饰类、方法和变量，final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。</p>\n<p>abstract 修饰符，用来创建抽象类和抽象方法。</p>\n<p>synchronized 和 volatile 修饰符，主要用于线程的编程。</p>\n<p>static 修饰符\n静态变量：</p>\n<p>static 关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝。 静态变量也被称为类变量。局部变量不能被声明为 static 变量。</p>\n<p>静态方法：</p>\n<p>static 关键字用来声明独立于对象的静态方法。静态方法不能使用类的非静态变量。静态方法从参数列表得到数据，然后计算这些数据。</p>\n<p>对类变量和方法的访问可以直接使用 classname.variablename 和 classname.methodname 的方式访问。</p>\n<p>如下例所示，static修饰符用来创建类方法和类变量。</p>\n<p>public class InstanceCounter {\n   private static int numInstances = 0;\n   protected static int getCount() {\n      return numInstances;\n   }</p>\n<p>   private static void addInstance() {\n      numInstances++;\n   }</p>\n<p>   InstanceCounter() {\n      InstanceCounter.addInstance();\n   }</p>\n<p>   public static void main(String[] arguments) {\n      System.out.println(&quot;Starting with &quot; +\n      InstanceCounter.getCount() + &quot; instances&quot;);\n      for (int i = 0; i &lt; 500; ++i){\n         new InstanceCounter();\n          }\n      System.out.println(&quot;Created &quot; +\n      InstanceCounter.getCount() + &quot; instances&quot;);\n   }\n}\n以上实例运行编辑结果如下:</p>\n<p>Starting with 0 instances\nCreated 500 instances\nfinal 修饰符\nfinal 变量：</p>\n<p>final 表示&quot;最后的、最终的&quot;含义，变量一旦赋值后，不能被重新赋值。被 final 修饰的实例变量必须显式指定初始值。</p>\n<p>final 修饰符通常和 static 修饰符一起使用来创建类常量。</p>\n<p>实例\npublic class Test{\n  final int value = 10;\n  // 下面是声明常量的实例\n  public static final int BOXWIDTH = 6;\n  static final String TITLE = &quot;Manager&quot;;</p>\n<p>  public void changeValue(){\n     value = 12; //将输出一个错误\n  }\n}\nfinal 方法</p>\n<p>类中的 final 方法可以被子类继承，但是不能被子类修改。</p>\n<p>声明 final 方法的主要目的是防止该方法的内容被修改。</p>\n<p>如下所示，使用 final 修饰符声明方法。</p>\n<p>public class Test{\n    public final void changeName(){\n       // 方法体\n    }\n}\nfinal 类</p>\n<p>final 类不能被继承，没有类能够继承 final 类的任何特性。</p>\n<p>实例\npublic final class Test {\n   // 类体\n}\nabstract 修饰符\n抽象类：</p>\n<p>抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充。</p>\n<p>一个类不能同时被 abstract 和 final 修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误。</p>\n<p>抽象类可以包含抽象方法和非抽象方法。</p>\n<p>实例\nabstract class Caravan{\n   private double price;\n   private String model;\n   private String year;\n   public abstract void goFast(); //抽象方法\n   public abstract void changeColor();\n}\n抽象方法</p>\n<p>抽象方法是一种没有任何实现的方法，该方法的的具体实现由子类提供。</p>\n<p>抽象方法不能被声明成 final 和 static。</p>\n<p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p>\n<p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法。</p>\n<p>抽象方法的声明以分号结尾，例如：public abstract sample();。</p>\n<p>实例\npublic abstract class SuperClass{\n    abstract void m(); //抽象方法\n}</p>\n<p>class SubClass extends SuperClass{\n     //实现抽象方法\n      void m(){\n          .........\n      }\n}</p>\n<h4 id="synchronized-">synchronized 修饰符</h4>\n<p>synchronized 关键字声明的方法同一时间只能被一个线程访问。synchronized修饰符可以应用于四个访问修饰符。</p>\n<p>实例\npublic synchronized void showDetails(){\n.......\n}</p>\n<h4 id="transient-">transient 修饰符</h4>\n<p>序列化的对象包含被 transient 修饰的实例变量时，java 虚拟机(JVM)跳过该特定的变量。</p>\n<p>该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型。</p>\n<h4 id="volatile-">volatile 修饰符</h4>\n<p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</p>\n<hr>\n<h3 id="java-">Java 运算符</h3>\n<ul>\n<li>算术运算符</li>\n<li>关系运算符</li>\n<li>位运算符</li>\n<li>逻辑运算符</li>\n<li>赋值运算符</li>\n<li>其他运算符</li>\n</ul>\n<h4 id="-">算术运算符</h4>\n<h4 id="-">关系运算符</h4>\n<h4 id="-">位运算符</h4>\n<h4 id="-">逻辑运算符</h4>\n<h4 id="-">短路逻辑运算符</h4>\n<h4 id="-">赋值运算符</h4>\n<h4 id="-">条件运算符（?:）</h4>\n<p>条件运算符也被称为三元运算符。</p>\n<h4 id="instanceof-">instanceof 运算符</h4>\n<p>该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。</p>\n<h4 id="java-">Java运算符优先级</h4>\n<p>当多个运算符出现在一个表达式中，谁先谁后呢？这就涉及到运算符的优先级别的问题。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/5.png?raw=true" alt="image"></p>\n<hr>\n<h3 id="java-for-while-do-while">Java 循环结构 - for, while 及 do...while</h3>\n<h4 id="java-for-">Java 增强 for 循环</h4>\n<p>Java5 引入了一种主要用于数组的增强型 for 循环。</p>\n<pre><code>for(声明语句 : 表达式)\n{\n   //代码句子\n}</code></pre><hr>\n<h3 id="java-number-math-">Java Number &amp; Math 类</h3>\n<h4 id="java-math-">Java Math 类</h4>\n<p>所有的包装类（Integer、Long、Byte、Double、Float、Short）都是抽象类 Number 的子类。</p>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/6.png?raw=true" alt="image">\n这种由编译器特别支持的包装称为装箱，所以当内置数据类型被当作对象使用的时候，编译器会把内置类型装箱为包装类。相似的，编译器也可以把一个对象拆箱为内置类型。Number类属于java.lang包。</p>\n<pre><code>public class Test{\n\n   public static void main(String args[]){\n      Integer x = 5;\n      x =  x + 10;\n      System.out.println(x); \n   }\n}\n15</code></pre><p>赋值→装箱  运算→拆箱</p>\n<h4 id="java-math-">Java Math 类</h4>\n<p>Java 的 Math 包含了用于执行基本数学运算的属性和方法，如初等指数、对数、平方根和三角函数。Math 的方法都被定义为 static 形式，通过 Math 类可以在主函数中直接调用。</p>\n<h4 id="number-math-">Number &amp; Math 类方法</h4>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/7.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/8.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/9.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/9.png?raw=true" alt="image">\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/10.png?raw=true" alt="image"> </p>\n<pre><code>/**\n* @author Dale\n* java中的自动装箱与拆箱\n* 简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。\n*/\npublic class Number {\n    public static void main(String[] args) {\n        /**\n        Integer i1 = 128;  // 装箱，相当于 Integer.valueOf(128);\n        int t = i1; //相当于 i1.intValue() 拆箱\n        System.out.println(t);\n        */\n\n        /**\n        对于–128到127（默认是127）之间的值,被装箱后，会被放在内存里进行重用\n        但是如果超出了这个值,系统会重新new 一个对象\n        */\n        Integer i1 = 200;\n        Integer i2 = 200;\n\n        /**\n        注意 == 与 equals的区别\n        == 它比较的是对象的地址\n        equals 比较的是对象的内容\n        */\n        if(i1==i2) {\n            System.out.println(&quot;true&quot;);\n        } else {\n            System.out.println(&quot;false&quot;);\n        }\n    }\n}</code></pre><h4 id="java-character-">Java Character 类</h4>\n<p>Character 类用于对单个字符进行操作。\nCharacter 类在对象中包装一个基本类型 char 的值</p>\n<hr>\n<h4 id="java-string-">Java String 类</h4>\n<p>字符串广泛应用 在Java 编程中，在 Java 中<strong>字符串属于对象</strong>，Java 提供了 String 类来创建和操作字符串。</p>\n<p>tring 类有 11 种构造方法，这些方法提供不同的参数来初始化字符串，比如提供一个字符数组参数:</p>\n<pre><code>public class StringDemo{\n   public static void main(String args[]){\n      char[] helloArray = { &#39;r&#39;, &#39;u&#39;, &#39;n&#39;, &#39;o&#39;, &#39;o&#39;, &#39;b&#39;};\n      String helloString = new String(helloArray);  \n      System.out.println( helloString );\n   }\n}</code></pre><p><strong>注意:String 类是不可改变的，所以你一旦创建了 String 对象，那它的值就无法改变了</strong></p>\n<h4 id="-">字符串长度</h4>\n<p>用于获取有关对象的信息的方法称为访问器方法。\nString 类的一个访问器方法是 length() 方法，它返回字符串对象包含的字符数。</p>\n<h4 id="-">字符串长度</h4>\n<pre><code>string1.concat(string2);\n&quot;我的名字是 &quot;.concat(&quot;Runoob&quot;);\n&quot;Hello,&quot; + &quot; runoob&quot; + &quot;!&quot;</code></pre><h4 id="-">创建格式化字符串</h4>\n<p>创建格式化字符串\n我们知道输出格式化数字可以使用 printf() 和 format() 方法。</p>\n<p>String 类使用静态方法 format() 返回一个String 对象而不是 PrintStream 对象。</p>\n<p>String 类的静态方法 format() 能用来创建可复用的格式化字符串，而不仅仅是用于一次打印输出。</p>\n<pre><code>System.out.printf(&quot;浮点型变量的值为 &quot; +\n                  &quot;%f, 整型变量的值为 &quot; +\n                  &quot; %d, 字符串变量的值为 &quot; +\n                  &quot;is %s&quot;, floatVar, intVar, stringVar);</code></pre><h4 id="string-">String 方法</h4>\n<hr>\n<h3 id="java-stringbuffer-stringbuilder-">Java StringBuffer 和 StringBuilder 类</h3>\n<p>当对字符串进行修改的时候，需要使用StringBuffer和StringBuilder类。</p>\n<p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。</p>\n<p>StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。</p>\n<p>由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。</p>\n<h4 id="stringbuffer-">StringBuffer 方法</h4>\n<hr>\n<h4 id="java-">Java 数组</h4>\n<p>Java 语言中提供的数组是用来存储固定大小的同类型元素。</p>\n<p>你可以声明一个数组变量，如 numbers[100] 来代替直接声明 100 个独立变量 number0，number1，....，number99。</p>\n<h4 id="-">声明数组变量</h4>\n<p>首先必须声明数组变量，才能在程序中使用数组。下面是声明数组变量的语法：</p>\n<pre><code>dataType[] arrayRefVar;   // 首选的方法\n\ndataType arrayRefVar[];  // 效果相同，但不是首选方法</code></pre><h4 id="-">创建数组</h4>\n<p>Java语言使用new操作符来创建数组，语法如下：</p>\n<pre><code>arrayRefVar = new dataType[arraySize];</code></pre><p>上面的语法语句做了两件事：</p>\n<ul>\n<li>使用 dataType[arraySize] 创建了一个数组。</li>\n<li>把新创建的数组的引用赋值给变量arrayRefVar。</li>\n</ul>\n<p>数组变量的声明，和创建数组可以用一条语句完成，如下所示：</p>\n<pre><code>dataType[] arrayRefVar = new dataType[arraySize];</code></pre><p>另外，你还可以使用如下的方式创建数组。</p>\n<pre><code>dataType[] arrayRefVar = {value0, value1, ..., valuek};</code></pre><h4 id="-">处理数组</h4>\n<p>数组的元素类型和数组的大小都是确定的，所以当处理数组元素时候，我们通常使用基本循环或者foreach循环。</p>\n<h4 id="-">数组作为函数的参数</h4>\n<p>数组可以作为参数传递给方法。</p>\n<p>例如，下面的例子就是一个打印 int 数组中元素的方法:</p>\n<pre><code>public static void printArray(int[] array) {\n  for (int i = 0; i &lt; array.length; i++) {\n    System.out.print(array[i] + &quot; &quot;);\n  }\n}\nprintArray(new int[]{3, 1, 2, 6, 4, 2});\n</code></pre><h4 id="-">数组作为函数的返回值</h4>\n<h4 id="-">多维数组</h4>\n<pre><code>String str[][] = new String[3][4];\n</code></pre><h4 id="arrays-">Arrays 类</h4>\n<p>java.util.Arrays 类能方便地操作数组，它提供的所有方法都是静态的。</p>\n<p>具有以下功能：</p>\n<ul>\n<li>给数组赋值：通过 fill 方法。</li>\n<li>对数组排序：通过 sort 方法,按升序。</li>\n<li>比较数组：通过 equals 方法比较数组中元素值是否相等。</li>\n<li>查找数组元素：通过 binarySearch 方法能对排序好的数组进行二分查找法操作。</li>\n</ul>\n<hr>\n<h1 id="java-">Java 日期时间</h1>\n<p>java.util 包提供了 Date 类来封装当前的日期和时间。 Date 类提供两个构造函数来实例化 Date 对象。</p>\n<p>第一个构造函数使用当前日期和时间来初始化对象。</p>\n<pre><code>Date( )</code></pre><p>第二个构造函数接收一个参数，该参数是从1970年1月1日起的毫秒数。</p>\n<pre><code>Date(long millisec)</code></pre><h4 id="java-sleep-">Java 休眠(sleep)</h4>\n<p>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CPU的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会。</p>\n<h4 id="calendar-">Calendar类</h4>\n<h4 id="gregoriancalendar-">GregorianCalendar类</h4>\n<hr>\n<h3 id="java-">Java 正则表达式</h3>\n<p>正则表达式定义了字符串的模式。</p>\n<p><strong>正则表达式可以用来搜索、编辑或处理文本。</strong></p>\n<p>正则表达式并不仅限于某一种语言，但是在每种语言中有细微的差别。</p>\n<hr>\n'},M6a0:function(n,t){},MU5D:function(n,t,i){var e=i("R9M2");n.exports=Object("z").propertyIsEnumerable(0)?Object:function(n){return"String"==e(n)?n.split(""):Object(n)}},Mhyx:function(n,t,i){var e=i("/bQp"),l=i("dSzd")("iterator"),o=Array.prototype;n.exports=function(n){return void 0!==n&&(e.Array===n||o[l]===n)}},MmMw:function(n,t,i){var e=i("EqjI");n.exports=function(n,t){if(!e(n))return n;var i,l;if(t&&"function"==typeof(i=n.toString)&&!e(l=i.call(n)))return l;if("function"==typeof(i=n.valueOf)&&!e(l=i.call(n)))return l;if(!t&&"function"==typeof(i=n.toString)&&!e(l=i.call(n)))return l;throw TypeError("Can't convert object to primitive value")}},NGXQ:function(n,t){n.exports='<h4 id="ajax-">ajax原生请求</h4>\n<h5 id="-web-">传统web缺点</h5>\n<p>传统web请求，用户触发http请求，服务器收到请求，返回一个新的页面，浏览器重新加载页面，每一个请求，都会重新返回一个html页面，浪费了带宽，用户体验糟糕。</p>\n<h5 id="ajax-">AJAX介绍</h5>\n<p>AJAX是一种动态网页实现技术，网页可以实现部分数据进行<strong>异步</strong>更新。</p>\n<h5 id="xmlhttprequest-window-">XMLHttpRequest对象（window）</h5>\n<p>XMLHttpRequest对象是ajax实现的基础，与服务器进行数据交互。</p>\n<h5 id="xmlhttprequest-">XMLHttpRequest对象方法</h5>\n<ul>\n<li>abort():请求终止</li>\n<li>getAllResponseHeaders():获取返回头信息</li>\n<li>open(&quot;method&quot;,&quot;URL&quot;,[asyncFlag],[&quot;userName&quot;],[&quot;password&quot;]</li>\n<li>send(content):发出请求</li>\n<li>setRequestHeader(&quot;header&quot;, &quot;value&quot;)：设置请求头</li>\n</ul>\n<h5 id="-">使用步骤</h5>\n<ol>\n<li>创建XMLHttpRequest异步对象</li>\n<li>设置请求方式，参数</li>\n<li>发出请求</li>\n<li>注册返回监听事件</li>\n</ol>\n<h5 id="-">具体应用</h5>\n<p>index.html</p>\n<pre><code class="language-html">&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;Ajax原生请求&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&lt;script&gt;\n    // get请求\n    // 1.创建异步对象\n    let xmlRequestObj = new XMLHttpRequest();\n    // 2.用于指定发送HTTP请求的参数 \n    xmlRequestObj.open(&#39;get&#39;, &#39;http://localhost:8888/&#39;);\n    // 3.发出请求\n    xmlRequestObj.send();\n    // 4.注册返回监听事件\n    xmlRequestObj.onreadystatechange = function() {\n        if (xmlRequestObj.readyState == 4 &amp;&amp; xmlRequestObj.status == 200) {\n            console.log(xmlRequestObj.responseText)\n        }\n    }\n\n    // post请求\n    // 创建异步对象  \n    var xhr = new XMLHttpRequest();\n    // 设置请求的类型及url true:是否异步\n    xhr.open(&#39;post&#39;, &#39;http://localhost:8888/&#39;, true);\n    // post请求一定要添加请求头\n    xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);\n    // 发送请求\n    xhr.send(&#39;name=fox&amp;age=18&#39;);\n    xhr.onreadystatechange = function() {\n        // 这步为判断服务器是否正确响应\n        if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {\n            console.log(xhr.responseText);\n        }\n    };\n&lt;/script&gt;</code></pre>\n<h5 id="server-js">server.js</h5>\n<p>(cmd启动服务:node server.js)</p>\n<pre><code class="language-js">var http = require(&#39;http&#39;);\nhttp.createServer(function(request, response) {\n\n    // 发送 HTTP 头部 \n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;);\n    response.writeHead(200, { &#39;Content-Type&#39;: &#39;text/plain&#39; });\n    // 发送响应数据 &quot;Hello World&quot;\n    response.end(&#39;Hello World\\n&#39;);\n}).listen(8888);\n\n// 终端打印如下信息\nconsole.log(&#39;Server running at http://localhost:8888/&#39;);</code></pre>\n'},"NWt+":function(n,t,i){var e=i("+ZMJ"),l=i("msXi"),o=i("Mhyx"),a=i("77Pl"),r=i("QRG4"),p=i("3fs2"),s={},c={};(t=n.exports=function(n,t,i,u,h){var d,g,m,v,f=h?function(){return n}:p(n),b=e(i,u,t?2:1),S=0;if("function"!=typeof f)throw TypeError(n+" is not iterable!");if(o(f)){for(d=r(n.length);d>S;S++)if((v=t?b(a(g=n[S])[0],g[1]):b(n[S]))===s||v===c)return v}else for(m=f.call(n);!(g=m.next()).done;)if((v=l(m,b,g.value,t))===s||v===c)return v}).BREAK=s,t.RETURN=c},O4g8:function(n,t){n.exports=!0},ON07:function(n,t,i){var e=i("EqjI"),l=i("7KvD").document,o=e(l)&&e(l.createElement);n.exports=function(n){return o?l.createElement(n):{}}},Pt1D:function(n,t,i){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var e=i("WK65"),l={render:function(){var n=this,t=n.$createElement,i=n._self._c||t;return i("div",{staticClass:"indexBox"},[n.currentBigImg?i("div",{staticClass:"bigImgWrap",on:{click:n.hideBigImg}},[i("img",{attrs:{src:n.currentBigImg,id:"bigImg"}})]):n._e(),n._v(" "),n._m(0),n._v(" "),i("div",{staticClass:"indexRight"},[i("div",{staticClass:"topBar"},[i("ul",{staticClass:"topBarUl"},n._l(n.topNav,function(t,e){return i("li",{key:e,class:{selected:n.topNavCurrent==e,topNavOption:!0},on:{click:function(t){n.switchTab(e)}}},[n._v(n._s(t.name))])})),n._v(" "),i("div",{staticClass:"searchBar"},[i("div",{staticClass:"wrapSearch"},[i("div",{staticClass:"icon iconfont"},[n._v("")]),n._v(" "),i("input",{directives:[{name:"model",rawName:"v-model",value:n.searchValue,expression:"searchValue"}],staticClass:"searchInput",attrs:{type:"text",placeholder:"搜索知识点"},domProps:{value:n.searchValue},on:{input:function(t){t.target.composing||(n.searchValue=t.target.value)}}})])])]),n._v(" "),i("div",{staticClass:"leftContent"},[n.showDetails?i("div",{class:{selectedArticle:!0,animated:!0,fadeInRight:n.showDetails,fadeOutRight:!n.showDetails}},[i("div",{staticClass:"closeTap iconfont",on:{click:function(t){n.closeDetails()}}},[n._v("")]),n._v(" "),i("div",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"content markdown-body",domProps:{innerHTML:n._s(n.currentDetails.route)}})]):n._e(),n._v(" "),n.showDetails?n._e():i("ul",{class:{contentWrtap:!0,animated:!0,fadeOutLeft:n.showDetails},attrs:{id:"contentWrtap"}},n._l(n.currentArrEssay,function(t,e){return i("li",{key:e,ref:"articleBrife",refInFor:!0,on:{click:function(i){n.showDetailsEvent(t)}}},[i("p",{staticClass:"title",domProps:{innerHTML:n._s(e+1+"."+t.titleValue)}}),n._v(" "),i("p",{staticClass:"details"},[n._v(n._s(t.brife))]),n._v(" "),n._m(1,!0)])})),n._v(" "),n.showDetails?n._e():i("div",{staticClass:"copyRight"},[n._v("Powered by GitHub Copyright "),i("br"),n._v("© 2018 - 2019 Haihong Cai All Rights Reserved. ")])]),n._v(" "),i("div",{staticClass:"rightNav"},[i("nav",{staticClass:"navList"},[i("ul",{staticClass:"navListContent"},[i("div",{staticClass:"leftLine"}),n._v(" "),n._l(n.topNavDetailsArr,function(t,e){return i("li",{key:e,staticClass:"smallTitle",on:{click:function(t){n.chooseArea(e)}}},[i("span",{class:{cicle:!0,cicleSelect:n.currentArea!=e}}),i("span",{staticClass:"num"},[n._v(n._s(e+1))]),n._v(" "),i("p",{staticClass:"smallTitleTxt smallTitleTxtActive"},[n._v(n._s(t))])])})],2)])])])])},staticRenderFns:[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"indexLeft"},[e("div",{staticClass:"personInfor"},[e("img",{staticClass:"headImg",attrs:{src:i("uckV")}}),n._v(" "),e("div",{staticClass:"txtWrap"},[e("p",[e("span",{staticClass:"iconfont"},[n._v("")]),n._v(" 987136196")]),n._v(" "),e("p",[e("span",{staticClass:"iconfont"},[n._v("")]),n._v(" 15602266688")]),n._v(" "),e("p",[e("span",{staticClass:"iconfont"},[n._v("")]),n._v(" caihaihong6083@163.com")]),n._v(" "),e("div",{staticClass:"chatTool"},[e("a",{attrs:{href:"https://github.com/caihaihong"}},[e("span",{staticClass:"iconfont"},[n._v("")])]),n._v(" "),e("span",{staticClass:"iconfont wechat"},[n._v("")])])])]),n._v(" "),e("img",{staticClass:"bottomQoute",attrs:{src:i("qug8")}})])},function(){var n=this.$createElement,t=this._self._c||n;return t("p",{staticClass:"readMore"},[this._v("详细内容"),t("span",[this._v(">>")])])}]};var o=function(n){i("qahb")},a=i("VU/8")(e.a,l,!1,o,"data-v-c1b58876",null);t.default=a.exports},PzxK:function(n,t,i){var e=i("D2L2"),l=i("sB3e"),o=i("ax3d")("IE_PROTO"),a=Object.prototype;n.exports=Object.getPrototypeOf||function(n){return n=l(n),e(n,o)?n[o]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?a:null}},QL3l:function(n,t){n.exports='<h4 id="js-this-">JS this指向问题</h4>\n<p>重要的知识点：在函数中this取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p>\n<h5 id="-">全局 &amp; 调用普通函数</h5>\n<p>在全局环境下，this永远是window</p>\n<h5 id="-">构造函数</h5>\n<p>构造函数里面，当new一个对象时候，this指向当前的对象。\n当直接执行函数时候，this指向window对象</p>\n<pre><code>var Fun =function(){\nconsole.log(this)\n/*\nFun:{\n    __proto__: Object\n}\n*/\n/*\nWindow:{\n    __proto__: Object\n}\n*/\n}\nFun.prototype.sayHi=function(){\n console.log(this);\n/*\nFun:{\n    __proto__: Object\n}\n*/\n}\nvar fun = new Fun();\nfun.sayHi();\nFun();</code></pre><h5 id="-">函数作为对象的一个属性</h5>\n<p>当函数作为对象的一个属性被调用时候，函数中的this指向该对象。</p>\n<pre><code>var obj = {\nf1:function(){\nconsole.log(this)\n/*{f1: ƒ}*/\n/*window:{}对象*/\n}}\nobj.f1();\nvar f2 = obj.f1;\nf2();</code></pre><h5 id="-call-apply">函数用call或apply</h5>\n<p>当一个函数被call和apply调用时，this的值就取传入的对象的值。</p>\n<pre><code>var obj = {\n    a:4\n};\nvar fun = function(){\nconsole.log(this);\n/*\n{a: 4}\n*/\n}\nfun.call(obj);</code></pre>'},QRG4:function(n,t,i){var e=i("UuGF"),l=Math.min;n.exports=function(n){return n>0?l(e(n),9007199254740991):0}},R9M2:function(n,t){var i={}.toString;n.exports=function(n){return i.call(n).slice(8,-1)}},RPLV:function(n,t,i){var e=i("7KvD").document;n.exports=e&&e.documentElement},"RY/4":function(n,t,i){var e=i("R9M2"),l=i("dSzd")("toStringTag"),o="Arguments"==e(function(){return arguments}());n.exports=function(n){var t,i,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(i=function(n,t){try{return n[t]}catch(n){}}(t=Object(n),l))?i:o?e(t):"Object"==(a=e(t))&&"function"==typeof t.callee?"Arguments":a}},S82l:function(n,t){n.exports=function(n){try{return!!n()}catch(n){return!0}}},SfB7:function(n,t,i){n.exports=!i("+E39")&&!i("S82l")(function(){return 7!=Object.defineProperty(i("ON07")("div"),"a",{get:function(){return 7}}).a})},SldL:function(n,t){!function(t){"use strict";var i,e=Object.prototype,l=e.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",r=o.asyncIterator||"@@asyncIterator",p=o.toStringTag||"@@toStringTag",s="object"==typeof n,c=t.regeneratorRuntime;if(c)s&&(n.exports=c);else{(c=t.regeneratorRuntime=s?n.exports:{}).wrap=y;var u="suspendedStart",h="suspendedYield",d="executing",g="completed",m={},v={};v[a]=function(){return this};var f=Object.getPrototypeOf,b=f&&f(f(j([])));b&&b!==e&&l.call(b,a)&&(v=b);var S=q.prototype=x.prototype=Object.create(v);C.prototype=S.constructor=q,q.constructor=C,q[p]=C.displayName="GeneratorFunction",c.isGeneratorFunction=function(n){var t="function"==typeof n&&n.constructor;return!!t&&(t===C||"GeneratorFunction"===(t.displayName||t.name))},c.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,q):(n.__proto__=q,p in n||(n[p]="GeneratorFunction")),n.prototype=Object.create(S),n},c.awrap=function(n){return{__await:n}},w(A.prototype),A.prototype[r]=function(){return this},c.AsyncIterator=A,c.async=function(n,t,i,e){var l=new A(y(n,t,i,e));return c.isGeneratorFunction(t)?l:l.next().then(function(n){return n.done?n.value:l.next()})},w(S),S[p]="Generator",S[a]=function(){return this},S.toString=function(){return"[object Generator]"},c.keys=function(n){var t=[];for(var i in n)t.push(i);return t.reverse(),function i(){for(;t.length;){var e=t.pop();if(e in n)return i.value=e,i.done=!1,i}return i.done=!0,i}},c.values=j,D.prototype={constructor:D,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=i,this.done=!1,this.delegate=null,this.method="next",this.arg=i,this.tryEntries.forEach(J),!n)for(var t in this)"t"===t.charAt(0)&&l.call(this,t)&&!isNaN(+t.slice(1))&&(this[t]=i)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var t=this;function e(e,l){return r.type="throw",r.arg=n,t.next=e,l&&(t.method="next",t.arg=i),!!l}for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o],r=a.completion;if("root"===a.tryLoc)return e("end");if(a.tryLoc<=this.prev){var p=l.call(a,"catchLoc"),s=l.call(a,"finallyLoc");if(p&&s){if(this.prev<a.catchLoc)return e(a.catchLoc,!0);if(this.prev<a.finallyLoc)return e(a.finallyLoc)}else if(p){if(this.prev<a.catchLoc)return e(a.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<a.finallyLoc)return e(a.finallyLoc)}}}},abrupt:function(n,t){for(var i=this.tryEntries.length-1;i>=0;--i){var e=this.tryEntries[i];if(e.tryLoc<=this.prev&&l.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var o=e;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=t&&t<=o.finallyLoc&&(o=null);var a=o?o.completion:{};return a.type=n,a.arg=t,o?(this.method="next",this.next=o.finallyLoc,m):this.complete(a)},complete:function(n,t){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&t&&(this.next=t),m},finish:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.finallyLoc===n)return this.complete(i.completion,i.afterLoc),J(i),m}},catch:function(n){for(var t=this.tryEntries.length-1;t>=0;--t){var i=this.tryEntries[t];if(i.tryLoc===n){var e=i.completion;if("throw"===e.type){var l=e.arg;J(i)}return l}}throw new Error("illegal catch attempt")},delegateYield:function(n,t,e){return this.delegate={iterator:j(n),resultName:t,nextLoc:e},"next"===this.method&&(this.arg=i),m}}}function y(n,t,i,e){var l=t&&t.prototype instanceof x?t:x,o=Object.create(l.prototype),a=new D(e||[]);return o._invoke=function(n,t,i){var e=u;return function(l,o){if(e===d)throw new Error("Generator is already running");if(e===g){if("throw"===l)throw o;return I()}for(i.method=l,i.arg=o;;){var a=i.delegate;if(a){var r=T(a,i);if(r){if(r===m)continue;return r}}if("next"===i.method)i.sent=i._sent=i.arg;else if("throw"===i.method){if(e===u)throw e=g,i.arg;i.dispatchException(i.arg)}else"return"===i.method&&i.abrupt("return",i.arg);e=d;var p=E(n,t,i);if("normal"===p.type){if(e=i.done?g:h,p.arg===m)continue;return{value:p.arg,done:i.done}}"throw"===p.type&&(e=g,i.method="throw",i.arg=p.arg)}}}(n,i,a),o}function E(n,t,i){try{return{type:"normal",arg:n.call(t,i)}}catch(n){return{type:"throw",arg:n}}}function x(){}function C(){}function q(){}function w(n){["next","throw","return"].forEach(function(t){n[t]=function(n){return this._invoke(t,n)}})}function A(n){var t;this._invoke=function(i,e){function o(){return new Promise(function(t,o){!function t(i,e,o,a){var r=E(n[i],n,e);if("throw"!==r.type){var p=r.arg,s=p.value;return s&&"object"==typeof s&&l.call(s,"__await")?Promise.resolve(s.__await).then(function(n){t("next",n,o,a)},function(n){t("throw",n,o,a)}):Promise.resolve(s).then(function(n){p.value=n,o(p)},a)}a(r.arg)}(i,e,t,o)})}return t=t?t.then(o,o):o()}}function T(n,t){var e=n.iterator[t.method];if(e===i){if(t.delegate=null,"throw"===t.method){if(n.iterator.return&&(t.method="return",t.arg=i,T(n,t),"throw"===t.method))return m;t.method="throw",t.arg=new TypeError("The iterator does not provide a 'throw' method")}return m}var l=E(e,n.iterator,t.arg);if("throw"===l.type)return t.method="throw",t.arg=l.arg,t.delegate=null,m;var o=l.arg;return o?o.done?(t[n.resultName]=o.value,t.next=n.nextLoc,"return"!==t.method&&(t.method="next",t.arg=i),t.delegate=null,m):o:(t.method="throw",t.arg=new TypeError("iterator result is not an object"),t.delegate=null,m)}function P(n){var t={tryLoc:n[0]};1 in n&&(t.catchLoc=n[1]),2 in n&&(t.finallyLoc=n[2],t.afterLoc=n[3]),this.tryEntries.push(t)}function J(n){var t=n.completion||{};t.type="normal",delete t.arg,n.completion=t}function D(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(P,this),this.reset(!0)}function j(n){if(n){var t=n[a];if(t)return t.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var e=-1,o=function t(){for(;++e<n.length;)if(l.call(n,e))return t.value=n[e],t.done=!1,t;return t.value=i,t.done=!0,t};return o.next=o}}return{next:I}}function I(){return{value:i,done:!0}}}(function(){return this}()||Function("return this")())},"T9/K":function(n,t){n.exports='<h3 id="java-">Java 继承</h3>\n<p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p>\n<p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p>\n<h4 id="-">类的继承格式</h4>\n<p>在 Java 中通过 extends 关键字可以申明一个类是从另外一个类继承而来的，一般形式如下：</p>\n<pre><code>class 父类 {\n}\n\nclass 子类 extends 父类 {\n}</code></pre><h4 id="-">为什么需要继承</h4>\n<p>开发动物类，其中动物分别为企鹅以及老鼠，要求如下：</p>\n<p>企鹅：属性（姓名，id），方法（吃，睡，自我介绍）\n老鼠：属性（姓名，id），方法（吃，睡，自我介绍）</p>\n<pre><code>* 企鹅类\npublic class Penguin { \n    private String name; \n    private int id; \n    public Penguin(String myName, int  myid) { \n        name = myName; \n        id = myid; \n    } \n    public void eat(){ \n        System.out.println(name+&quot;正在吃&quot;); \n    }\n    public void sleep(){\n        System.out.println(name+&quot;正在睡&quot;);\n    }\n    public void introduction() { \n        System.out.println(&quot;大家好！我是&quot;         + id + &quot;号&quot; + name + &quot;.&quot;); \n    } \n}</code></pre><pre><code>老鼠类：\npublic class Mouse { \n    private String name; \n    private int id; \n    public Mouse(String myName, int  myid) { \n        name = myName; \n        id = myid; \n    } \n    public void eat(){ \n        System.out.println(name+&quot;正在吃&quot;); \n    }\n    public void sleep(){\n        System.out.println(name+&quot;正在睡&quot;);\n    }\n    public void introduction() { \n        System.out.println(&quot;大家好！我是&quot;         + id + &quot;号&quot; + name + &quot;.&quot;); \n    } \n}</code></pre><p>从这两段代码可以看出来，代码存在重复了，导致后果就是代码量大且臃肿，而且维护性不高(维护性主要是后期需要修改的时候，就需要修改很多的代码，容易出错)，所以要从根本上解决这两段代码的问题，就需要继承，将两段代码中相同的部分提取出来组成 一个父类：</p>\n<pre><code>公共父类：\npublic class Animal { \n    private String name;  \n    private int id; \n    public Animal(String myName, int myid) { \n        name = myName; \n        id = myid;\n    } \n    public void eat(){ \n        System.out.println(name+&quot;正在吃&quot;); \n    }\n    public void sleep(){\n        System.out.println(name+&quot;正在睡&quot;);\n    }\n    public void introduction() { \n        System.out.println(&quot;大家好！我是&quot;         + id + &quot;号&quot; + name + &quot;.&quot;); \n    } \n}</code></pre><p>这个Animal类就可以作为一个父类，然后企鹅类和老鼠类继承这个类之后，就具有父类当中的属性和方法，子类就不会存在重复的代码，维护性也提高，代码也更加简洁，提高代码的复用性（复用性主要是可以多次使用，不用再多次写同样的代码） 继承之后的代码：</p>\n<pre><code>企鹅类：\npublic class Penguin extends Animal { \n    public Penguin(String myName, int myid) { \n        super(myName, myid); \n    } \n}</code></pre><pre><code>老鼠类：\npublic class Mouse extends Animal { \n    public Mouse(String myName, int myid) { \n        super(myName, myid); \n    } \n}</code></pre><h4 id="-">继承类型</h4>\n<p> Java 不支持多继承，但支持多重继承。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/23.png?raw=true" alt="image"></p>\n<h5 id="-">继承的特性</h5>\n<ul>\n<li>子类拥有父类<strong>非private</strong>的属性，方法。</li>\n<li>子类可以拥有自己的属性和方法，即<strong>子类可以对父类进行扩展</strong>。</li>\n<li>子类可以用自己的方式实现父类的方法。</li>\n<li>Java的继承是单继承，但是可以多重继承</li>\n<li>提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）。</li>\n</ul>\n<h5 id="-">继承关键字</h5>\n<p>继承可以使用 extends 和 implements 这两个关键字来实现继承，而且所有的类都是<strong>继承于 java.lang.Object</strong>，当一个类没有继承的两个关键字，则默认继承object（这个类在 java.lang 包中，所以不需要 import）祖先类。</p>\n<h5 id="extends-">extends关键字</h5>\n<p>在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。</p>\n<pre><code>public class Animal { \n    private String name;   \n    private int id; \n    public Animal(String myName, String myid) { \n        //初始化属性值\n    } \n    public void eat() {  //吃东西方法的具体实现  } \n    public void sleep() { //睡觉方法的具体实现  } \n} \n\npublic class Penguin  extends  Animal{ \n}</code></pre><h5 id="implements-">implements关键字</h5>\n<p>使用 <strong>implements 关键字可以变相的使java具有多继承的特性</strong>，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。</p>\n<pre><code>implements 关键字\npublic interface A {\n    public void eat();\n    public void sleep();\n}\n\npublic interface B {\n    public void show();\n}\n\npublic class C implements A,B {\n}</code></pre><h5 id="super">super</h5>\n<p>我们可以通过super关键字来实现对父类成员的访问，用来引用当前对象的父类。</p>\n<p>this关键字：指向自己的引用。</p>\n<pre><code>实例\nclass Animal {\n  void eat() {\n    System.out.println(&quot;animal : eat&quot;);\n  }\n}\n\nclass Dog extends Animal {\n  void eat() {\n    System.out.println(&quot;dog : eat&quot;);\n  }\n  void eatTest() {\n    this.eat();   // this 调用自己的方法\n    super.eat();  // super 调用父类方法\n  }\n}\n\npublic class Test {\n  public static void main(String[] args) {\n    Animal a = new Animal();\n    a.eat();\n    Dog d = new Dog();\n    d.eatTest();\n  }\n}\n输出结果为：\n\nanimal : eat\ndog : eat\nanimal : eat</code></pre><h5 id="final">final</h5>\n<p>final关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：</p>\n<pre><code>声明类：\n\nfinal class 类名 {\n   //类体\n}\n\n声明方法：\n\n修饰符(public/private/default/protected) final 返回值类型 方法名(){\n    //方法体\n}</code></pre><p>注:</p>\n<ul>\n<li>实例变量也可以被定义为final，被定义为final的变量不能被修改。</li>\n<li>被声明为final 类的方法自动地声明为final，但是实例变量并不是final</li>\n</ul>\n<h5 id="-">构造器</h5>\n<p>子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。</p>\n<p>如果父类构造器没有参数，则在子类的构造器中不需要使用super关键字调用父类构造器，系统会自动调用父类的无参构造器。</p>\n<p>参构造器。</p>\n<p>实例</p>\n<pre><code>class SuperClass {\n  private int n;\n  SuperClass(){\n    System.out.println(&quot;SuperClass()&quot;);\n  }\n  SuperClass(int n) {\n    System.out.println(&quot;SuperClass(int n)&quot;);\n    this.n = n;\n  }\n}\nclass SubClass extends SuperClass{\n  private int n;\n\n  SubClass(){\n    super(300);\n    System.out.println(&quot;SubClass&quot;);\n  }  \n\n  public SubClass(int n){\n    System.out.println(&quot;SubClass(int n):&quot;+n);\n    this.n = n;\n  }\n}\npublic class TestSuperSub{\n  public static void main (String args[]){\n    SubClass sc = new SubClass();\n    SubClass sc2 = new SubClass(200); \n  }\n}\nSuperClass(int n)\nSubClass\nSuperClass()\nSubClass(int n):200</code></pre><h5 id="java-super-">java 中若要在子类调用父类的方法，需使用关键字super。</h5>\n<pre><code>实例\nclass Animal{\n    void go(){\n        System.out.println(&quot;animal go&quot;);\n    }\n}\n\nclass Dog extends Animal{\n    void go(){\n        //调用父类方法\n        super.go();\n    }\n}\n\n//驱动函数\npublic static void  main(String[] args){\n    Dog dog=new Dog();\n    dog.go();\n}\n输出结果：\n\nanimal go</code></pre><h5 id="-">面向对象编程——继承和多态</h5>\n<p>1、为什么使用继承</p>\n<p>从已有的类派生出新的类，称为继承。在不同的类中也可能会有共同的特征和动作，可以<strong>把这些共同的特征和动作放在一个类中，让其它类共享</strong>。因此可以定义一个通用类，然后将其扩展为其它多个特定类，这些特定类继承通用类中的特征和动作。继承是Java中实现软件重用的重要手段，避免重复，易于维护，易于理解。</p>\n<p>2、父类和子类</p>\n<p>如果类 B 从类 A 派生，或者说类 B 扩展自类 A，或者说类 B 继承类 A，则称类A为&quot;父类&quot;，也称为超类、基类；称类B为&quot;子类&quot;，也称为次类、扩展类、派生类。子类从它的父类中继承可访问的数据域和方法，也可以添加新的数据域和新的方法。</p>\n<p>3、继承的注意点：</p>\n<p>子类不是父类的子集，子类一般比父类包含更多的数据域和方法。父类中的 private 数据域在子类中是不可见的，因此在子类中不能直接使用它们。继承是为&quot;是一个&quot;的关系建模的，父类和其子类间必须存在&quot;是一个&quot;的关系，否则不能用继承。</p>\n<p>但也并不是所有&quot;是一个&quot;的关系都应该用继承。例如，正方形是一个矩形，但不能让 Square 类来继承 Rectangle 类，因为正方形不能从矩形扩展得到任何东西。正确的继承关系是 Square 类继承 Shape 类\nJava 只允许单一继承（即一个子类只能有一个直接父类），C++ 可以多继承（即一个子类有多个直接父类）。</p>\n<p>3、super 关键字</p>\n<p>super 表示使用它的类的父类。super 可用于：</p>\n<ul>\n<li>调用父类的构造方法；</li>\n<li>调用父类的方法（子类覆盖了父类的方法时）；</li>\n<li>访问父类的数据域（可以这样用但没有必要这样用）。</li>\n<li>调用父类的构造方法语法：</li>\n</ul>\n<pre><code>super();  \n或   \nsuper(参数列表);</code></pre><p>注意：</p>\n<ul>\n<li>super 语句必须是子类构造方法的第一条语句。</li>\n<li>不能在子类中使用父类构造方法名来调用父类构造方法。</li>\n<li>父类的构造方法不被子类继承。调用父类的构造方法的唯一途径是使用super关键字，如果子类中没显式调用，则编译器自动将super();作为子类构造方法的第一条语句。这会形成一个<strong>构造方法链</strong>。</li>\n<li>静态方法中不能使用 super 关键字。</li>\n</ul>\n<pre><code>调用父类的方法语法：\nsuper.方法名(参数列表);</code></pre><p>如果是继承的方法，是没有必要使用super来调用，直接即可调用。但如果子类覆盖或重写了父类的方法，则只有使用super才能在子类中调用父类中的被重写的方法。</p>\n<p>4、this 关键字</p>\n<p>this 关键字表示当前对象。可用于：调用当前类的构造方法，并且必须是方法的第一条语句。如：this(); 调用默认构造方法。this(参数); 调用带参构造方法。\n限定当前对象的数据域变量。一般用于方法内的局部变量与对象的数据域变量同名的情况。如 this.num = num。this.num 表示当前对象的数据域变量 num，而 num 表示方法中的局部变量。</p>\n<p>5、final 的作用随着所修饰的类型而不同</p>\n<ul>\n<li>final 修饰类中的属性或者变量，无论属性是基本类型还是引用类型，final所起的作用都是变量里面存放的&quot;值&quot;不能变。这个值，对于基本类型来说，变量里面放的就是实实在在的值，如 1，&quot;abc&quot; 等。</li>\n<li>而引用类型变量里面放的是个地址，所以用final修饰引用类型变量指的是它里面的地址不能变，并不是说这个地址所指向的对象或数组的内容不可以变，这个一定要注意。</li>\n</ul>\n<p>例如：类中有一个属性是</p>\n<pre><code>final Person p=new Person(&quot;name&quot;);</code></pre><p>那么你不能对 p 进行重新赋值，但是可以改变 p 里面属性的值 p.setName(&#39;newName&#39;);</p>\n<p>final 修饰属性，声明变量时可以不赋值，而且一旦赋值就不能被修改了。对 final 属性可以在三个地方赋值：声明时、初始化块中、构造方法中，总之一定要赋值。</p>\n<ul>\n<li>final修饰类中的方法可以被继承，但继承后不能被重写。</li>\n<li>final修饰类，类不可以被继承。</li>\n<li></li>\n</ul>\n<p>6、java文件被编译成class文件时，在子类的所有构造函数中的第一行（第一个语句）会默认自动添加 super() 语句，在执行子类的构造函数前，总是会先执行父类中的构造函数。</p>\n<p>在编写代码要注意：</p>\n<ul>\n<li>如果父类中不含 默认构造函数（就是 类名() ），那么子类中的super()语句就会执行失败，系统就会报错。一般 默认构造函数 编译时会自动添加，但如果类中已经有一个构造函数时，就不会添加。</li>\n<li>执行父类构造函数的语句只能放在函数内语句的首句，不然会报错。\n在继承关系中，在调用函数（方法）或者类中的成员变量时，JVM（JAVA虚拟机）会先检测当前的类（也就是子类）是否含有该函数或者成员变量，如果有，就执行子类中的，如果没有才会执行父类中的。如下：</li>\n</ul>\n<pre><code>public class Start\n{\n    public static void main(String[] args)\n    {\n        Cat cat=new Cat(&quot;Jack&quot;,&quot;黑色&quot;);\n        cat.eat();\n        cat.run();\n        cat.sleep();\n    }\n\n}\n\nclass Animal \n{\n    String name;\n\n    public Animal(){}//必须要写这个构造函数，不然Cat类的代码会出错\n\n    public Animal(String name)\n    {\n        this.name=name;\n    }\n\n    void eat()\n    {\n        System.out.println(name+&quot;正在吃&quot;);\n    }\n\n    void run()\n    {\n        System.out.println(name+&quot;正在奔跑&quot;);\n    }\n\n    void sleep()\n    {\n        System.out.println(name+&quot;正在睡觉&quot;);\n    }\n}\n\nclass Cat extends Animal\n{\n    String color;\n    public Cat(String name,String color)\n    {\n        this.name=name;\n        this.color=color;\n    }\n    void eat()\n    {\n        System.out.println(color+&quot;的&quot;+name+&quot;正在吃鱼&quot;);\n        }\n}\n运行结果如下：\n\n黑色的Jack正在吃鱼\nJack正在奔跑\nJack正在睡觉</code></pre><p>当子类出现与父类一样的函数时，这个被称为 重写 也叫 覆盖</p>\n<p>Object类是所有类的直接父类或间接父类，也就是说是所有类的根父类，这个可以运用于参数的传递</p>\n<p>如下：</p>\n<pre><code>public class Start\n{\n    public static void main(String[] args)\n    {\n        A a=new A();\n        B b=new B();\n        C c=new C();\n        D d=new D();\n        speak(a);\n        speak(b);\n        speak(c);\n        speak(d);\n    }\n// instanceof 关键字是用于比较类与类是否相同，相同返回true，不同返回false\n//当你不清楚你需要的参数是什么类型的，可以用Object来代替，Object可以代替任何类\n    static void speak(Object obj)\n    {\n        if(obj instanceof A)//意思是：如果参数是 A 类，那么就执行一下语句\n        {\n            A aobj=(A)obj;//这里是向下转换，需要强制转换\n            aobj.axx();\n        }\n        else if(obj instanceof B)\n        {\n            B bobj=(B)obj;\n            bobj.bxx();\n        }\n        else if(obj instanceof C)\n        {\n            C cobj=(C)obj;\n            cobj.cxx();\n        }\n    }\n}\n//这里举了四个类，他们的函数都不同，但都是 Object 类的子类\nclass A\n{\n    void axx()\n    {\n        System.out.println(&quot;Good morning!&quot;);\n        System.out.println(&quot;This is A&quot;);\n    }\n}\n\nclass B\n{\n    void bxx()\n    {\n        System.out.println(&quot;Holle!&quot;);\n        System.out.println(&quot;This is B&quot;);        \n    }\n}\n\nclass C\n{\n    void cxx()\n    {\n        System.out.println(&quot;Look!&quot;);\n        System.out.println(&quot;This is C&quot;);        \n    }\n}\n\nclass D\n{\n    void dxx()\n    {\n        System.out.println(&quot;Oh!Bad!&quot;);\n        System.out.println(&quot;This is D&quot;);        \n    }\n}\n运行结果：\n\nGood morning!\nThis is A\nHolle!\nThis is B\nLook!\nThis is C</code></pre><p>子类的所有构造方法内部， 第一行会（隐式）自动先调用父类的无参构造函数super()；\n如果子类构造方法第一行显式调用了父类构造方法，系统就不再调用无参的super()了。\n实例：</p>\n<pre><code>class Base {\n    public Base() {\n        System.out.println(&quot;Base--默认构造方法&quot;);\n    }\n\n    public Base(int c){\n        System.out.println(&quot;Base--有参构造方法--&quot; + c);\n    }\n}\n\npublic class Derived extends Base {\n    public Derived() {\n        // super(); //系统会自动隐式先调用父类的无参构造函数 super(); //必须是第一行，否则不能编译 \n        System.out.println(&quot;Derived--默认构造方法&quot;);\n    }\n\n    public Derived(int c) {\n        // super(); //系统会自动隐式先调用父类的无参构造函数 super(); //必须是第一行，否则不能编译\n        System.out.println(&quot;Derived--有参构造方法&quot; + c);\n    }\n\n    public Derived(int a, int b) {\n        super(a); //如果子类构造方法第一行显式调用了父类构造方法，系统就不再调用无参的super()了。\n        System.out.println(&quot;Derived--有参构造方法--&quot; + b);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(&quot;============子类无参============&quot;);\n        Derived no = new Derived();\n        System.out.println(&quot;============子类有参============&quot;);\n        Derived have = new Derived(33);\n        System.out.println(&quot;============子类有参============&quot;);\n        Derived have2 = new Derived(33, 55);\n    }\n}\n运行结果如下：\n\n============子类无参============\nBase--默认构造方法\nDerived--默认构造方法\n============子类有参============\nBase--默认构造方法\nDerived--有参构造方法33\n============子类有参============\nBase--有参构造方法--33\nDerived--有参构造方法--55\n注意：如果父类没有无参构造函数，创建子类时，不能编译，除非在构造函数代码体中的第一行显式调用父类有参构造函数。</code></pre><p>子类不能直接继承父类中的 private 属性和方法。</p>\n<pre><code>/**建立一个公共动物父类*/\npublic class Animal {\n    private String name;\n    private int id;\n    /*由于name和id都是私有的，所以子类不能直接继承，\n    需要通过有参构造函数进行继承*/\n    public Animal(String myname,int myid) {\n        name = myname;\n        id = myid;\n    }\n    public void eat() {\n        System.out.println(name+&quot;正在吃&quot;);\n    }\n    public void sleep() {\n        System.out.println(name+&quot;正在睡&quot;);\n    }\n    public void introduction() {\n        System.out.println(&quot;大家好！我是&quot;  +id+&quot;号&quot;+name +&quot;.&quot;);\n    }\n\n}\n子类 Penguin 需要通过关键字 super 进行声明\n\npublic class Penguin extends Animal {\n    public Penguin(String myname,int myid) {\n        super(myname,myid); // 声明继承父类中的两个属性\n    }\n}\n具体通过有参构造函数进行继承。\n\npublic class PenguinQQ {\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        Penguin QQ = new Penguin(&quot;小冰&quot;,10086);\n        //调用一个有参构造方法\n        QQ.eat();\n        QQ.sleep();\n        QQ.introduction();\n    }\n}\n运行结果:\n\n小冰正在吃\n小冰正在睡\n大家好！我是10086号小冰.</code></pre><p>Java 转型问题其实并不复杂，只要记住一句话：<strong>父类引用指向子类对象</strong>。</p>\n<p>向上转型(upcasting) 、向下转型(downcasting)。</p>\n<p>举个例子：有2个类，Father 是父类，Son 类继承自 Father。</p>\n<pre><code>Father f1 = new Son();   // 这就叫 upcasting （向上转型)\n// 现在 f1 引用指向一个Son对象\n\nSon s1 = (Son)f1;   // 这就叫 downcasting (向下转型)\n// 现在f1 还是指向 Son对象</code></pre><p>第2个例子：</p>\n<p>Father f2 = new Father();\nSon s2 = (Son)f2;       // 出错，子类引用不能指向父类对象\n你或许会问，第1个例子中：Son s1 = (Son)f1; 问什是正确的呢。</p>\n<p>很简单因为 f1 指向一个子类对象，Father f1 = new Son(); 子类 s1 引用当然可以指向子类对象了。</p>\n<p>而 f2 被传给了一个 Father 对象，Father f2 = new Father(); 子类 s1 引用不能指向父类对象。</p>\n<p>总结：</p>\n<p>1、父类引用指向子类对象，而子类引用不能指向父类对象。</p>\n<p>2、把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转换吗，如：</p>\n<p>Father f1 = new Son();\n3、把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转换，如：</p>\n<p>f1 就是一个指向子类对象的父类引用。把f1赋给子类引用 s1 即 Son s1 = (Son)f1;</p>\n<p>其中 f1 前面的(Son)必须加上，进行强制转换。</p>\n<p>对理解继承来说，最重要的事情是，知道哪些东西被继承了，或者说，子类从父类那里得到了什么。答案是：所有的东西，所有的父类的成员，包括变量和方法，都成为了子类的成员，除了构造方法。构造方法是父类所独有的，因为它们的名字就是类的名字，所以父类的构造方法在子类中不存在。除此之外，子类继承得到了父类所有的成员。</p>\n<p>但是得到不等于可以随便使用。每个成员有不同的访问属性，子类继承得到了父类所有的成员，但是不同的访问属性使得子类在使用这些成员时有所不同：有些父类的成员直接成为子类的对外的界面，有些则被深深地隐藏起来，即使子类自己也不能直接访问。下表列出了不同访问属性的父类成员在子类中的访问属性。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/24.png?raw=true" alt="image"></p>\n<p>public的成员直接成为子类的public的成员，protected的成员也直接成为子类的protected的成员。Java的protected的意思是包内和子类可访问，所以它比缺省的访问属性要宽一些。而对于父类的缺省的未定义访问属性的成员来说，他们是在父类所在的包内可见，如果子类不属于父类的包，那么在子类里面，这些缺省属性的成员和private的成员是一样的：不可见。父类的private的成员在子类里仍然是存在的，只是子类中不能直接访问。我们不可以在子类中重新定义继承得到的成员的访问属性。如果我们试图重新定义一个在父类中已经存在的成员变量，那么我们是在定义一个与父类的成员变量完全无关的变量，在子类中我们可以访问这个定义在子类中的变量，在父类的方法中访问父类的那个。尽管它们同名但是互不影响。</p>\n<p>在构造一个子类的对象时，父类的构造方法也是会被调用的，而且父类的构造方法在子类的构造方法之前被调用。在程序运行过程中，子类对象的一部分空间存放的是父类对象。因为子类从父类得到继承，在子类对象初始化过程中可能会使用到父类的成员。所以父类的空间正是要先被初始化的，然后子类的空间才得到初始化。在这个过程中，如果父类的构造方法需要参数，如何传递参数就很重要了。</p>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/25.png?raw=true" alt="image"></p>\n<h3 id="java-override-overload-">Java 重写(Override)与重载(Overload)</h3>\n<h4 id="-override-">重写(Override)</h4>\n<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！</p>\n<p>重写的好处在于子类可以根据需要，定义特定于自己的行为。 也就是说子类能够根据需要实现父类的方法。</p>\n<p><strong>重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常</strong>。</p>\n<p>例如：父类的一个方法申明了一个检查异常IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为Exception是IOException的父类，只能抛出IOException的子类异常。</p>\n<h4 id="-">方法的重写规则</h4>\n<ul>\n<li>参数列表必须完全与被重写方法的相同；</li>\n<li>返回类型必须完全与被重写方法的返回类型相同；</li>\n<li>访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。</li>\n<li>父类的成员方法只能被它的子类重写。</li>\n<li>声明为final的方法不能被重写。</li>\n<li>声明为static的方法不能被重写，但是能够被再次声明。</li>\n<li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li>\n<li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li>\n<li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。构造方法不能被重写。</li>\n<li>如果不能继承一个方法，则不能重写这个方法。</li>\n</ul>\n<h4 id="-overload-">重载(Overload)</h4>\n<p>重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。</p>\n<p>每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。</p>\n<p>最常用的地方就是构造器的重载。</p>\n<p>重载规则:</p>\n<ul>\n<li>被重载的方法必须改变参数列表(参数个数或类型不一样)；</li>\n<li>被重载的方法可以改变返回类型；</li>\n<li>被重载的方法可以改变访问修饰符；</li>\n<li>被重载的方法可以声明新的或更广的检查异常；</li>\n<li>方法能够在同一个类中或者在一个子类中被重载。</li>\n<li>无法以返回值类型作为重载函数的区分标准。</li>\n</ul>\n<h4 id="java-">Java 多态</h4>\n<p>多态是同一个行为具有多个不同表现形式或形态的能力。</p>\n<p>多态就是同一个接口，使用不同的实例而执行不同操作，如图所示：\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/26.png?raw=true" alt="image"></p>\n<p>多态性是对象多种表现形式的体现。</p>\n<p>现实中，比如我们按下 F1 键这个动作：</p>\n<p>如果当前在 Flash 界面下弹出的就是 AS 3 的帮助文档；\n如果当前在 Word 下弹出的就是 Word 帮助；\n在 Windows 下弹出的就是 Windows 帮助和支持。\n同一个事件发生在不同的对象上会产生不同的结果。</p>\n<p>多态的优点</p>\n<ol>\n<li>消除类型之间的耦合关系</li>\n<li>可替换性</li>\n<li>可扩充性</li>\n<li>接口性</li>\n<li>灵活性</li>\n<li>简化性\n多态存在的三个必要条件\n继承\n重写\n<strong>父类引用指向子类对象</strong></li>\n</ol>\n<pre><code>Parent p = new Child();</code></pre><p>使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，再去调用子类的同名方法。</p>\n<p>多态的好处：可以使程序有良好的扩展，并可以对所有类的对象进行通用处理。</p>\n<p>多态的实现方式</p>\n<ul>\n<li>方式一：重写</li>\n<li>方式二：接口</li>\n<li>方式三：抽象类和抽象方法</li>\n</ul>\n<p>多态，可以总结以下几点：</p>\n<p>一、使用父类类型的引用指向子类的对象；</p>\n<p>二、该引用只能调用父类中定义的方法和变量；</p>\n<p>三、如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）;</p>\n<p>四、变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</p>\n<p>多态引用时，构造子类对象时的构造方法的调用顺序</p>\n<p>1，先调用超类的构造方法，多重超类首先调用最远超类的方法；</p>\n<p>2，然后再执行当前子类的构造方法；</p>\n<p>调用时需要谨慎处理调用方法。</p>\n<h4 id="java-">Java抽象类</h4>\n<p>一个类中没有包含足够的信息来描绘一个具体的对象，这样的类就是抽象类。</p>\n<p><strong>抽象类除了不能实例化对象之外</strong>，类的其它功能依然存在，成员变量、成员方法和构造方法的访问方式和普通类一样。</p>\n<p>由于抽象类不能实例化对象，所以抽象类必须被继承，才能被使用。也是因为这个原因，通常在设计阶段决定要不要设计抽象类。</p>\n<p>父类包含了子类集合的常见的方法，但是由于父类本身是抽象的，所以不能使用这些方法。</p>\n<p>在Java中抽象类表示的是一种继承关系，一个类只能继承一个抽象类，而一个类却可以实现多个接口。</p>\n<h5 id="-">抽象方法</h5>\n<p>如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。</p>\n<p>Abstract关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。</p>\n<p>抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。</p>\n<p>声明抽象方法会造成以下两个结果：</p>\n<p><strong>如果一个类包含抽象方法，那么该类必须是抽象类</strong>。\n任何子类必须重写父类的抽象方法，或者声明自身为抽象类。\n继承抽象方法的子类必须重写该方法。否则，该子类也必须声明为抽象类。最终，必须有子类实现该抽象方法，否则，从最初的父类到最终的子类都不能用来实例化对象。</p>\n<h5 id="-">抽象类总结规定</h5>\n<ol>\n<li><p>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。</p>\n</li>\n<li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。</p>\n</li>\n<li><p>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。</p>\n</li>\n<li><p>构造方法，类方法（用static修饰的方法）不能声明为抽象方法。</p>\n</li>\n<li><p>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。</p>\n</li>\n</ol>\n<h4 id="java-">Java 封装</h4>\n<p>在面向对象程式设计方法中，封装（英语：Encapsulation）是指一种将抽象性函式接口的实现细节部份包装、隐藏起来的方法。</p>\n<p>封装可以被认为是一个保护屏障，防止该类的代码和数据被外部类定义的代码随机访问。</p>\n<p>要访问该类的代码和数据，必须通过严格的接口控制。</p>\n<p>封装最主要的功能在于我们能修改自己的实现代码，而不用修改那些调用我们代码的程序片段。</p>\n<p>适当的封装可以让程式码更容易理解与维护，也加强了程式码的安全性。</p>\n<p>封装的优点</p>\n<ol>\n<li><p>良好的封装能够减少耦合。</p>\n</li>\n<li><p>类内部的结构可以自由修改。</p>\n</li>\n<li><p>可以对成员变量进行更精确的控制。</p>\n</li>\n<li><p>隐藏信息，实现细节。</p>\n</li>\n</ol>\n<h5 id="-java-">实现Java封装的步骤</h5>\n<ol>\n<li>修改属性的可见性来限制对属性的访问（一般限制为private），例如：</li>\n</ol>\n<p>public class Person {\n    private String name;\n    private int age;\n}\n这段代码中，将name和age属性设置为私有的，只能本类才能访问，其他类都访问不了，如此就对信息进行了隐藏。</p>\n<ol start="2">\n<li>对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问，例如：</li>\n</ol>\n<pre><code>public class Person{\n    private String name;\n    private int age;\n​\n    public int getAge(){\n      return age;\n    }\n​\n    public String getName(){\n      return name;\n    }\n​\n    public void setAge(int age){\n      this.age = age;\n    }\n​\n    public void setName(String name){\n      this.name = name;\n    }\n}</code></pre><h4 id="java-">Java 接口</h4>\n<p>接口（英文：Interface），在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。</p>\n<p>接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。</p>\n<p>除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。</p>\n<p>接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。</p>\n<p>接口与类相似点：</p>\n<ul>\n<li>一个接口可以有多个方法。</li>\n<li>接口文件保存在 .java 结尾的文件中，文件名使用接口名。</li>\n<li>接口的字节码文件保存在 .class 结尾的文件中。</li>\n<li>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</li>\n</ul>\n<p>接口与类的区别：</p>\n<ul>\n<li>接口不能用于实例化对象。</li>\n<li>接口没有构造方法。</li>\n<li>接口中所有的方法必须是抽象方法。</li>\n<li>接口不能包含成员变量，除了 static 和 final 变量。</li>\n<li>接口不是被类继承了，而是要被类实现。接口支持多继承。</li>\n</ul>\n<p>接口特性</p>\n<ul>\n<li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。</li>\n<li>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。</li>\n<li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。</li>\n</ul>\n<p>抽象类和接口的区别</p>\n<ol>\n<li>抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。</li>\n<li>抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。</li>\n<li>接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。</li>\n<li>一个类只能继承一个抽象类，而一个类却可以实现多个接口。</li>\n</ol>\n<pre><code>public interface NameOfInterface\n{\n   //任何类型 final, static 字段\n   //抽象方法\n}</code></pre><p>接口有以下特性：</p>\n<ul>\n<li>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。</li>\n<li>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。</li>\n<li>接口中的方法都是公有的。</li>\n</ul>\n<p>接口的实现</p>\n<ul>\n<li>当类实现接口的时候，类要实现接口中所有的方法。否则，类必须声明为抽象的类。</li>\n<li>类使用implements关键字实现接口。在类声明中，Implements关键字放在class声明后面。</li>\n<li>实现一个接口的语法，可以使用这个公式：</li>\n</ul>\n<pre><code>...implements 接口名称[, 其他接口名称, 其他接口名称..., ...] ...</code></pre><p>重写接口中声明的方法时，需要注意以下规则：</p>\n<ul>\n<li>类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。</li>\n<li>类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。</li>\n<li>如果实现接口的类是抽象类，那么就没必要实现该接口的方法。</li>\n</ul>\n<p>在实现接口的时候，也要注意一些规则：</p>\n<ul>\n<li>一个类可以同时实现多个接口。</li>\n<li>一个类只能继承一个类，但是能实现多个接口。</li>\n<li>一个接口能继承另一个接口，这和类之间的继承比较相似。</li>\n</ul>\n<p>接口的继承\n一个接口能继承另一个接口，和类之间的继承方式比较相似。接口的继承使用extends关键字，子接口继承父接口的方法。</p>\n<p>标记接口</p>\n<ul>\n<li><p>最常用的继承接口是没有包含任何方法的接口。</p>\n</li>\n<li><p>标记接口是没有任何方法和属性的接口.它仅仅表明它的类属于一个特定的类型,供其他代码来测试允许做一些事情。</p>\n</li>\n<li><p>标记接口作用：简单形象的说就是给某个对象打个标（盖个戳），使对象拥有某个或某些特权。</p>\n</li>\n<li><p>建立一个公共的父接口：\n正如EventListener接口，这是由几十个其他接口扩展的Java API，你可以使用一个标记接口来建立一组接口的父接口。例如：当一个接口继承了EventListener接口，Java虚拟机(JVM)就知道该接口将要被用于一个事件的代理方案。</p>\n</li>\n</ul>\n<h4 id="-">向一个类添加数据类型：</h4>\n<p>这种情况是标记接口最初的目的，实现标记接口的类不需要定义任何接口方法(因为标记接口根本就没有方法)，但是该类通过多态性变成一个接口类型。</p>\n<p>1.接口可以多继承</p>\n<p>2.接口的方法声明必须是 public abstract 即便不写默认也是</p>\n<p>3.接口里面不能包含方法具体实现</p>\n<p>4.类实继承接口必须实现接口里申明的全部方法，除非该类是抽象类</p>\n<p>5.类里面可以声明 public static final 修饰的变量</p>\n<p>6.接口不能被实例化，但是可以被实现类创建</p>\n<h4 id="-">什么时候使用抽象类和接口</h4>\n<p>如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。\n如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。\n如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。</p>\n<p>在 JDK1.8，允许我们给接口添加两种非抽象的方法实现：</p>\n<p>1、默认方法，添加 default 修饰即可；</p>\n<p>2、静态方法，使用 static 修饰；示例如下：</p>\n<pre><code>interface Test{\n    //这个是默认方法\n    default String get(String aa){\n        System.out.println(&quot;我是jdk1.8默认实现方法...&quot;);\n        return &quot;&quot;;\n    }   \n    //这个是静态方法    \n    static void staticmethod(){\n        System.out.println(&quot;我是静态方法&quot;);\n    }\n}</code></pre><p>调用得话，静态方法只能通过接口名调用，不可以通过实现类的类名或者实现类的对象调用，default 方法只能通过接口实现类的对象来调用。</p>\n<p>接口的含义理解</p>\n<p>接口可以理解成统一的协议, 而接口中的属性也属于协议中的内容。但是接口的属性都是公共的，静态的，最终的。</p>\n<p>接口的成员特点：</p>\n<p> 1、成员变量只能是常量，<strong>默认修饰符 public static final</strong></p>\n<p> 2、成员方法只能是抽象方法。默认修饰符 public abstract\n所以，Java 接口中，使用变量的时候，变量必须被赋值。</p>\n<p>//所以接口定义属性</p>\n<pre><code>public interface People {\n    int age=10;\n    String name=&quot;输出名字&quot;; // 接口里面定义的成员变量都是  public static final 修饰\n    public void eat();　　\n}</code></pre><p>所有的变量必须给出初始值，且绝对不会被修改，因为隐藏的修饰符为 public static final。</p>\n<p>Java 标识接口</p>\n<p>标识接口是没有任何方法和属性的接口，它仅仅表明它的类属于一个特定的类型，供其他代码来测试允许做一些事情。</p>\n<p>使用标记接口的唯一目的是使得可以用 instanceof 进行类型查询，例如：</p>\n<p>if(obj instanceof Cloneable) {………} \n一些容器例如 Ejb 容器，servlet 容器或运行时环境依赖标记接口识别类是否需要进行某种处理，比如 serialialbe 接口标记类需要进行序列化操作。</p>\n<p> java.io.Serializable：未实现此接口的类将无法使其任何状态序列化或反序列化。为保证 serialVersionUID 值跨不同 java 编译器实现的一致性，序列化类必须声明一个明确的 serialVersionUID 值。\n java.lang.Cloneable：表明 Object.clone() 方法可以合法地对该类实例进行按字段复制.实现此接口的类应该使用公共方法重写 Object.clone（它是受保护的）。如果在没有实现 Cloneable 接口的实例上调用 Object 的 clone 方法，则会导致抛出 CloneNotSupportedException 异常。\n java.util.RandomAccess：用来表明其支持快速（通常是固定时间）随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。\n java.rmi.Remote：Remote 接口用于标识其方法可以从非本地虚拟机上调用的接口。任何远程对象都必须直接或间接实现此接口。只有在“远程接口”（扩展 java.rmi.Remote 的接口）中指定的这些方法才可远程使用。</p>\n<h4 id="-">接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。这其实是通过接口实现多态的关键。</h4>\n<pre><code>interface Fu {\n    public abstract void method();\n}\nclass Zi implements Fu {\n    public void method(){\n        System.out.println(“重写接口抽象方法”);\n    }\n}\n//接口的多态使用\nFu fu = new Zi();</code></pre><h4 id="java-">Java 抽象类和接口总结</h4>\n<p> 1.abstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个 interface。</p>\n<p> 2.在 abstract class 中可以有自己的数据成员，也可以有非 abstarct 的成员方法，而在 interface 中，只能够有静态的不能被修改的数据成员（也就是必须是 static final 的，不过在 interface 中一般不定义数据成员），所有的成员方法都是 abstract 的。</p>\n<p> 3.abstract class 和 interface 所反映出的设计理念不同。其实 abstract class 表示的是 &quot;is-a&quot; 关系，interface 表示的是 &quot;like-a&quot; 关系。</p>\n<p> 4.实现抽象类和接口的类必须实现其中的所有方法。抽象类中可以有非抽象方法。接口中则不能有实现方法。</p>\n<p> 5.接口中定义的变量默认是 public static final 型，且必须给其初值，所以实现类中不能重新定义，也不能改变其值。</p>\n<p> 6.抽象类中的变量默认是 friendly 型，其值可以在子类中重新定义，也可以重新赋值。</p>\n<p> 7.接口中的方法默认都是 public,abstract 类型的。</p>\n<p>结论: abstract class 和 interface 是 Java 语言中的两种定义抽象类的方式，它们之间有很大的相似性。但是对于它们的选择却又往往反映出对于问题领域中的概念本质的理解、对于设计意图的反映是否正确、合理，因为它们表现了概念间的不同的关系（虽然都能够实现需求的功能）。这其实也是语言的一种的惯用法，希望读者朋友能够细细体会。</p>\n<h4 id="java-package-">Java 包(package)</h4>\n<p>为了更好地组织类，Java提供了包机制，用于区别类名的命名空间。</p>\n<p>包的作用\n1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</p>\n<p>2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，<strong>当同时调用两个不同包中相同类名的类时，应该加上包名加以区别</strong>。因此，包可以避免名字冲突。</p>\n<p>3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p>\n<p>Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。</p>\n<h3 id="java-">Java 方法</h3>\n<p>println() 是一个方法。\nSystem 是系统类。\nout 是标准输出对象。\n这句话的用法是调用系统类 System 中的标准输出对象 out 中的方法 println()。</p>\n<h4 id="-">什么是方法呢？</h4>\n<ul>\n<li>Java方法是语句的集合，它们在一起执行一个功能。</li>\n<li>方法是解决一类问题的步骤的有序组合</li>\n<li>方法包含于类或对象中</li>\n<li>方法在程序中被创建，在其他地方被引用<h4 id="-">方法的优点</h4>\n</li>\n<li>使程序变得更简短而清晰。</li>\n<li>有利于程序维护。</li>\n<li>可以提高程序开发的效率。</li>\n<li>提高了代码的重用性。<h4 id="-">方法的命名规则</h4>\n</li>\n<li>方法的名字的第一个单词应以小写字母作为开头，后面的单词则用大写字母开头写，不使用连接符。例如：addPerson。</li>\n<li>下划线可能出现在JUnit测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：test<MethodUnderTest><em><state>，例如 testPop</em>emptyStack。</li>\n</ul>\n<h4 id="-">方法的定义</h4>\n<p>一般情况下，定义一个方法包含以下语法：</p>\n<pre><code>修饰符 返回值类型 方法名(参数类型 参数名){\n    ...\n    方法体\n    ...\n    return 返回值;\n}</code></pre><p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分：</p>\n<ul>\n<li>修饰符：修饰符，这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型。</li>\n<li>返回值类型 ：方法可能会返回值。returnValueType是方法返回值的数据类型。有些方法执行所需的操作，但没有返回值。在这种情况下，returnValueType 是关键字void。</li>\n<li>方法名：是方法的实际名称。方法名和参数表共同构成方法签名。</li>\n<li>参数类型：参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数。</li>\n<li>方法体：方法体包含具体的语句，定义该方法的功能。</li>\n</ul>\n<p><strong>注意： 在一些其它语言中方法指过程和函数。一个返回非void类型返回值的方法称为函数；一个返回void类型返回值的方法叫做过程。</strong></p>\n<h4 id="-">方法调用</h4>\n<p>Java 支持两种调用方法的方式，根据方法是否返回值来选择。</p>\n<p>当程序调用一个方法时，程序的控制权交给了被调用的方法。当被调用方法的返回语句执行或者到达方法体闭括号时候交还控制权给程序。</p>\n<p>当方法返回一个值的时候，方法调用通常被当做一个值。</p>\n<h4 id="void-">void 关键字</h4>\n<h4 id="-">通过值传递参数</h4>\n<p>调用一个方法时候需要提供参数，你必须按照参数列表指定的顺序提供。</p>\n<h4 id="-">方法的重载</h4>\n<h4 id="-">变量作用域</h4>\n<ul>\n<li>变量的范围是程序中该变量可以被引用的部分。</li>\n<li>方法内定义的变量被称为局部变量。</li>\n<li>局部变量的作用范围从声明开始，直到包含它的块结束。</li>\n<li>局部变量必须声明才可以使用。</li>\n<li>方法的参数范围涵盖整个方法。参数实际上是一个局部变量。</li>\n<li>for循环的初始化部分声明的变量，其作用范围在整个循环。</li>\n<li>但循环体内声明的变量其适用范围是从它声明到循环体结束。</li>\n<li>你可以在一个方法里，不同的非嵌套块中多次声明一个具有相同的名称局部变量，但你不能在嵌套块内两次声明局部变量。\n*<h4 id="-">命令行参数的使用</h4>\n有时候你希望运行一个程序时候再传递给它消息。这要靠传递命令行参数给main()函数实现。\n命令行参数是在执行程序时候紧跟在程序名字后面的信息。</li>\n</ul>\n<h4 id="-">构造方法</h4>\n<p>当一个对象被创建时候，构造方法用来初始化该对象。构造方法和它所在类的名字相同，但构造方法没有返回值。</p>\n<p>通常会使用构造方法给一个类的实例变量赋初值，或者执行其它必要的步骤来创建一个完整的对象。</p>\n<p>不管你是否自定义构造方法，所有的类都有构造方法，因为Java自动提供了一个默认构造方法，它把所有成员初始化为0。</p>\n<p>一旦你定义了自己的构造方法，默认构造方法就会失效。</p>\n<h4 id="-">可变参数（参数的个数没有确定）扩展运算符</h4>\n<p>JDK 1.5 开始，Java支持传递同类型的可变参数给一个方法。</p>\n<p>方法的可变参数的声明如下所示：</p>\n<pre><code>typeName... parameterName\n</code></pre><h4 id="finalize-">finalize() 方法</h4>\n<p>Java 允许定义这样的方法，它在对象被垃圾收集器析构(回收)之前调用，这个方法叫做 finalize( )，它用来清除回收对象。</p>\n<p>例如，你可以使用 finalize() 来确保一个对象打开的文件被关闭了。</p>\n<p>在 finalize() 方法里，你必须指定在对象销毁时候要执行的操作。\nfinalize() 一般格式是：</p>\n<pre><code>protected void finalize()\n{\n   // 在这里终结代码\n}</code></pre><p>Java 的内存回收可以由 JVM 来自动完成。如果你手动使用，则可以使用上面的方法。</p>\n<hr>\n<h4 id="java-stream-file-io">Java 流(Stream)、文件(File)和IO</h4>\n<ul>\n<li>Java.io 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。</li>\n<li>Java.io 包中的流支持很多种格式，比如：基本类型、对象、本地化字符集等等。</li>\n<li>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。</li>\n<li>Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</li>\n</ul>\n<h4 id="-">读取控制台输入</h4>\n<p>Java 的控制台输入由 System.in 完成。</p>\n<p>为了获得一个绑定到控制台的字符流，你可以把System.in包装在一个BufferedReader对象中来创建一个字符流。</p>\n<p>下面是创建 BufferedReader 的基本语法：</p>\n<pre><code>BufferedReader br = new BufferedReader(new \n                      InputStreamReader(System.in));</code></pre><p>BufferedReader 对象创建后，我们便可以使用 read() 方法从控制台读取一个字符，或者用 readLine() 方法读取一个字符串。</p>\n<h4 id="-">从控制台读取多字符输入</h4>\n<p>从 BufferedReader 对象读取一个字符要使用 read() 方法，它的语法如下：</p>\n<pre><code>int read( ) throws IOException</code></pre><p>每次调用 read() 方法，它从输入流读取一个字符并把该字符作为整数值返回。 当流结束的时候返回 -1。该方法抛出 IOException。</p>\n<h4 id="-">从控制台读取字符串</h4>\n<p>从标准输入读取一个字符串需要使用 BufferedReader 的 readLine() 方法。</p>\n<p>它的一般格式是：</p>\n<pre><code>String readLine( ) throws IOException</code></pre><h4 id="-">控制台输出</h4>\n<p>此前已经介绍过，控制台的输出由 print( ) 和 println() 完成。这些方法都由类 PrintStream 定义，System.out 是该类对象的一个引用。</p>\n<p>PrintStream 继承了 OutputStream类，并且实现了方法 write()。这样，write() 也可以用来往控制台写操作。</p>\n<p>PrintStream 定义 write() 的最简单格式如下所示：</p>\n<pre><code>void write(int byteval)</code></pre><p>该方法将 byteval 的低八位字节写到流中。</p>\n<h4 id="-">读写文件</h4>\n<p>如前所述，一个流被定义为一个数据序列。输入流用于从源读取数据，输出流用于向目标写数据。</p>\n<p>下图是一个描述输入流和输出流的类层次图。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/12.png?raw=true" alt="image"></p>\n<h4 id="fileinputstream">FileInputStream</h4>\n<p>该流用于从文件读取数据，它的对象可以用关键字 new 来创建。</p>\n<p>有多种构造方法可用来创建对象。</p>\n<p>可以使用字符串类型的文件名来创建一个输入流对象来读取文件：</p>\n<pre><code>InputStream f = new FileInputStream(&quot;C:/java/hello&quot;);</code></pre><p>也可以使用一个文件对象来创建一个输入流对象来读取文件。我们首先得使用 File() 方法来创建一个文件对象：</p>\n<pre><code>File f = new File(&quot;C:/java/hello&quot;);\nInputStream out = new FileInputStream(f);</code></pre><p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/13.png?raw=true" alt="image"></p>\n<h4 id="fileoutputstream">FileOutputStream</h4>\n<ul>\n<li>该类用来创建一个文件并向文件中写数据。</li>\n<li>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</li>\n<li>有两个构造方法可以用来创建 FileOutputStream 对象。</li>\n<li>使用字符串类型的文件名来创建一个输出流对象：</li>\n</ul>\n<pre><code>OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</code></pre><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p>\n<pre><code>File f = new File(&quot;C:/java/hello&quot;);\nInputStream out = new FileInputStream(f);</code></pre><p>创建了InputStream对象，就可以使用下面的方法来读取流或者进行其他的流操作。</p>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/13.png?raw=true" alt="image"></p>\n<h4 id="fileoutputstream">FileOutputStream</h4>\n<ul>\n<li>该类用来创建一个文件并向文件中写数据。</li>\n<li>如果该流在打开文件进行输出前，目标文件不存在，那么该流会创建该文件。</li>\n<li>有两个构造方法可以用来创建 FileOutputStream 对象。</li>\n<li>使用字符串类型的文件名来创建一个输出流对象：</li>\n</ul>\n<pre><code>OutputStream f = new FileOutputStream(&quot;C:/java/hello&quot;)</code></pre><p>也可以使用一个文件对象来创建一个输出流来写文件。我们首先得使用File()方法来创建一个文件对象：</p>\n<pre><code>File f = new File(&quot;C:/java/hello&quot;);\nOutputStream f = new FileOutputStream(f);</code></pre><p>创建OutputStream对象完成后，就可以使用下面的方法来写入流或者进行其他的流操作。</p>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/java/15.png?raw=true" alt="image"></p>\n<h4 id="-i-o">文件和I/O</h4>\n<p>还有一些关于文件和I/O的类，我们也需要知道：</p>\n<ul>\n<li>File Class(类)</li>\n<li>FileReader Class(类)</li>\n<li>FileWriter Class(类)</li>\n</ul>\n<h4 id="java-">Java中的目录</h4>\n<p>创建目录：\nFile类中有两个方法可以用来创建文件夹：</p>\n<ul>\n<li>mkdir( )方法创建一个文件夹，成功则返回true，失败则返回false。失败表明File对象指定的路径已经存在，或者由于整个路径还不存在，该文件夹不能被创建。</li>\n<li>mkdirs()方法创建一个文件夹和它的所有父文件夹。</li>\n</ul>\n<p><strong>注意： Java 在 UNIX 和 Windows 自动按约定分辨文件路径分隔符。如果你在 Windows 版本的 Java 中使用分隔符 (/) ，路径依然能够被正确解析。</strong></p>\n<h4 id="-">读取目录</h4>\n<ul>\n<li>一个目录其实就是一个 File 对象，它包含其他文件和文件夹。</li>\n<li>如果创建一个 File 对象并且它是一个目录，那么调用 isDirectory() 方法会返回 true。</li>\n<li>可以通过调用该对象上的 list() 方法，来提取它包含的文件和文件夹的列表。</li>\n</ul>\n<h4 id="-">删除目录或文件</h4>\n<p>删除文件可以使用 java.io.File.delete() 方法。</p>\n<hr>\n<h3 id="java-scanner-">Java Scanner 类</h3>\n<p>java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。</p>\n<p>下面是创建 Scanner 对象的基本语法：</p>\n<pre><code>Scanner s = new Scanner(System.in);</code></pre><p>next() 与 nextLine() 区别</p>\n<ul>\n<li>next():<ul>\n<li>一定要读取到有效字符后才可以结束输入。</li>\n<li>对输入有效字符之前遇到的空白，next() 方法会自动将其去掉</li>\n<li>只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</li>\n<li>next() 不能得到带有空格的字符串。</li>\n</ul>\n</li>\n<li>nextLine()：<ul>\n<li>以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。</li>\n<li>可以获得空白。</li>\n</ul>\n</li>\n</ul>\n'},TTo3:function(n,t){n.exports='<h4 id="-base64-">图片base64编码</h4>\n<p>图片数据编码成一串字符串（图片的所有信息，图片越复杂，字符串越长）</p>\n<h5 id="-">意义</h5>\n<p>减少HTTP请求，没有跨域问题，无需考虑缓存、文件头或者cookies问题  </p>\n<h5 id="-">使用</h5>\n<p>图片足够小且因为用处的特殊性无法被制作成雪碧图（CssSprites），在整个网站的复用性很高且基本不会被更新。</p>\n<h5 id="-">缺点</h5>\n<p> CSS体积变大→CRP关键渲染路径阻塞(Critical Rendering Path)→用户长时间看到白屏</p>\n'},TcQ7:function(n,t,i){var e=i("MU5D"),l=i("52gC");n.exports=function(n){return e(l(n))}},Tt9q:function(n,t){n.exports='<h4 id="vue-">Vue脚手架</h4>\n<p>将html、js、css写到一个后缀名.vue的文件中，区分这三种类型是通过<template>、<script>、<style>来区分，这个.vue文件在打包的过程中会被转换成浏览器能识别的传统html、js、css。</p>\n<p><img src="https://images2015.cnblogs.com/blog/1127793/201705/1127793-20170508205435738-759749042.png" alt="enter image description here">\n2.使用vue.js官方提供的命令行工具，可以让我们把关注点放在项目功能的实现上。</p>\n<p>3.需要安装依赖（cnpm install），可进入package.json中查看。比如vue-loader，其作用就是解析vue文件使浏览器能识别。</p>\n<p>4.页面的生成，通过webpack打包工具将.vue文件打包成html、js、css，其中js就是一个新的vue对象。</p>\n'},U5ju:function(n,t,i){i("M6a0"),i("zQR9"),i("+tPU"),i("CXw9"),i("EqBC"),i("jKW+"),n.exports=i("FeBl").Promise},UhiW:function(n,t){n.exports='<h4 id="css-">CSS盒模型</h4>\n<p>元素内容：content、padding、border、margin</p>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/box.png?raw=true" alt="image"></p>\n<h5 id="-ie-">概念：标准模型、IE模型（怪异模式）</h5>\n<pre><code>* box—sizing：border-box; IE盒模型，border和padding计算入width之内\n* box—sizing：content-box; W3C标准盒模型，default\n* box—sizing：padding-box; 包括padding\n* box—sizing：margin-box; 不支持，margin重叠合并。</code></pre><h5 id="margin-">margin合并叠加（取大值）</h5>\n<p>注意：标准流块级元素才会合并margin,行内元素、浮动或绝对定位之间的外边距不会合并。</p>\n<h5 id="js-">JS获取元素宽高</h5>\n<ol>\n<li>dom.style.width/height:获取内联样式宽高。</li>\n<li>dom.currentStyle.width/height：当前元素的宽高，IE支持</li>\n<li>window.getComputedStyle(dom元素).width/height：当前元素的宽高</li>\n<li>dom.getBoundingClientRect().width/height：返回值是一个 DOMRect 对象，这个对象是由该元素的 getClientRects() 方法返回的一组矩形的集合, 即：是与该元素相关的CSS 边框集合 。DOMRect 对象包含了一组用于描述边框的只读属性——left、top、right和bottom，单位为像素。除了 width 和 height 外的属性都是相对于视口的左上角位置而言的。</li>\n<li>dom.offsetWidth/offsetHeight：border+padding+content</li>\n</ol>\n<pre><code>.box {\n    width: 100px;\n    height: 100px;\n    border: solid 10px red;\n    padding: 10px;\n    margin: 10px;\n    box-sizing: border-box;\n}\n\n&lt;script&gt;\n    var getBoundingClientRectWidth = document.getElementById(&#39;box&#39;).getBoundingClientRect().width;\n    //border-box:100  content + padding + border \n    //content-box:140 + padding + border \n\n    var getComputedStyleWidth = window.getComputedStyle(document.getElementById(&#39;box&#39;)).width;\n    //border-box:100px   content+padding+border\n    //content-box:100px content\n\n    var DomoffsetHeight = document.getElementById(&#39;box&#39;).offsetHeight;\n    //border-box:100  content\n    //content-box:140 content+padding+border\n\n    var domClientHreight = document.getElementById(&#39;box&#39;).clientHeight;\n    //border-box:80  content+padding\n    //content-box:120 content+padding+border\n    console.log(getBoundingClientRectWidth)\n&lt;/script&gt;</code></pre><pre><code>scrollHeight = clientHeight + scrollTop</code></pre>'},Usms:function(n,t,i){"use strict";var e=i("rkWq"),l=i.n(e),o=i("zw+M"),a=i.n(o),r=i("XW/L"),p=i.n(r),s=i("uvu+"),c=i.n(s),u=i("Alvl"),h=i.n(u),d=i("rOXT"),g=i.n(d),m=i("KDwC"),v=i.n(m),f=i("p2BM"),b=i.n(f),S=i("jVyS"),y=i.n(S),E=i("ieyX"),x=i.n(E),C=i("dybF"),q=i.n(C),w=i("rX3V"),A=i.n(w),T=i("sV8p"),P=i.n(T),J=i("Xzoj"),D=i.n(J),j=i("TTo3"),I=i.n(j),M=i("VVe7"),B=i.n(M),N=i("+rWJ"),L=i.n(N),O=i("vC40"),k=i.n(O),F=i("VXql"),R=i.n(F),_=i("9v45"),V=i.n(_),H=i("NGXQ"),U=i.n(H),G=i("kxdT"),W=i.n(G),z=i("QL3l"),K=i.n(z),Y=i("ZAS4"),X=i.n(Y),Q=i("6jaS"),Z=i.n(Q),$=i("FJVD"),nn=i.n($),tn=i("Z80C"),en=i.n(tn),ln=i("Tt9q"),on=i.n(ln),an=i("FaJS"),rn=i.n(an),pn=i("1AS0"),sn=i.n(pn),cn=i("LFqA"),un=i.n(cn),hn=i("WON3"),dn=i.n(hn),gn=i("noGn"),mn=i.n(gn),vn=i("aJAk"),fn=i.n(vn),bn=i("/+Ud"),Sn=i.n(bn),yn=i("8JNt"),En=i.n(yn),xn=i("T9/K"),Cn=i.n(xn),qn=i("nM7a"),wn=i.n(qn),An=i("I54Z"),Tn=i.n(An),Pn=i("Hhxk"),Jn=i.n(Pn),Dn=i("fyb8"),jn=i.n(Dn),In=i("fbjH"),Mn=i.n(In),Bn=i("u2Ox"),Nn=i.n(Bn),Ln=i("dN4I"),On=i.n(Ln),kn=i("7xGw"),Fn=i.n(kn),Rn=i("6JEg"),_n=i.n(Rn),Vn=i("kaAU"),Hn=i.n(Vn),Un=i("BUxh"),Gn=i.n(Un),Wn=i("UhiW"),zn=i.n(Wn),Kn=i("IyHp"),Yn=i.n(Kn),Xn=i("meAt"),Qn=i.n(Xn),Zn=i("uBZ9"),$n=i.n(Zn),nt=i("7MOu"),tt=i.n(nt),it=i("2W1O"),et=i.n(it),lt=[{title:"计算机基础",route:l.a},{title:"计算机基础",route:a.a},{title:"计算机基础",route:p.a},{title:"计算机基础",route:c.a},{title:"计算机基础",route:h.a},{title:"计算机基础",route:g.a},{title:"计算机基础",route:v.a},{title:"计算机基础",route:b.a},{title:"计算机基础",route:y.a},{title:"计算机基础",route:b.a},{title:"计算机基础",route:x.a},{title:"计算机基础",route:q.a},{title:"计算机基础",route:A.a},{title:"计算机基础",route:P.a},{title:"计算机基础",route:D.a},{title:"计算机基础",route:I.a}],ot=[{title:"XML",route:Gn.a}],at=[{title:"CSS",route:en.a},{title:"CSS",route:zn.a},{title:"CSS",route:Yn.a},{title:"CSS",route:Qn.a},{title:"CSS",route:$n.a},{title:"CSS",route:tt.a}],rt=[{title:"Java",route:un.a},{title:"Java",route:dn.a},{title:"Java",route:mn.a},{title:"Java",route:fn.a},{title:"Java",route:Sn.a},{title:"Java",route:En.a},{title:"Java",route:Cn.a},{title:"Java",route:wn.a},{title:"Java",route:Tn.a},{title:"Java",route:Jn.a},{title:"Java",route:jn.a},{title:"Java",route:Mn.a},{title:"Java",route:Nn.a},{title:"Java",route:On.a},{title:"Java",route:Fn.a},{title:"Java",route:_n.a},{title:"Java",route:Hn.a}],pt=[{title:"JavaScript",route:B.a},{title:"JavaScript",route:L.a},{title:"JavaScript",route:k.a},{title:"JavaScript",route:R.a},{title:"JavaScript",route:V.a},{title:"JavaScript",route:U.a},{title:"JavaScript",route:W.a},{title:"JavaScript",route:K.a},{title:"JavaScript",route:X.a}],st=[{title:"Vue",route:on.a},{title:"Vue",route:rn.a},{title:"Vue",route:sn.a}],ct={title:[{name:"计算机",detailsArr:["计算机基础","XML","浏览器","CSS","JavaScript","Vue","Java"]},{name:"英语",detailsArr:["单词"]}],details:[{title:"计算机",article:[{content:lt},{content:ot},{content:[{title:"浏览器",route:Z.a},{title:"浏览器",route:nn.a}]},{content:at},{content:pt},{content:st},{content:rt}]},{title:"英语",article:[{content:[{title:"单词",route:et.a}]}]}]};t.a={essayContent:ct}},UuGF:function(n,t){var i=Math.ceil,e=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?e:i)(n)}},VVe7:function(n,t){n.exports='<h4 id="async-await">async await</h4>\n<h5 id="demo1">demo1</h5>\n<pre><code>    //await 只能等待一个promise对象\n    &quot;use strict&quot;;\n    (async function() {\n        console.log(1);\n        await new Promise((resolve) =&gt; {\n            setTimeout(function() {\n                console.log(2);\n                resolve();\n            }, 1000);\n        });\n        console.log(3);\n    }())</code></pre><h5 id="demo2">demo2</h5>\n<h5 id="async">async</h5>\n<p>When an async function is called, it returns a Promise. When the async function returns a value, the Promise will be resolved with the returned value. When the async function throws an exception or some value, the Promise will be rejected with the thrown value.</p>\n<pre><code>  async function imAsync(num) {\n        if (num &gt; 0) {\n            return num // 这里相当于resolve(num)\n        } else {\n            throw num // 这里相当于reject(num)\n        }\n    }\n    imAsync(1).then(function(v) {\n        console.log(v); // 1\n    });\n    // 注意这里是catch\n    imAsync(0).catch(function(v) {\n        console.log(v); // 0\n    })\n\n</code></pre><pre><code>function imPromise(num) {\n\n  return new Promise(function (resolve, reject) {\n    if (num &gt; 0) {\n      resolve(num);\n    } else {\n      reject(num);\n    }\n  })\n}\n\nimPromise(1).then(function (v) {\n  console.log(v); // 1\n})\n\nimPromise(0).then(function (v) {\n  console.log(v); // 0\n})\n</code></pre><h5 id="await">await</h5>\n<p>An async function can contain an await expression, that pauses the execution of the async function and watis for the passed Promise&#39;s resolution, and then resumes the async function&#39;s execution and returns the resolved value.</p>\n<p>The purpose of async/await functions is to simplify the behavior of using promises synchronously and to perform some behavior on a group of Promises. Just like Promises are similar to structured callbacks, async/await is similar to combining generators and promises.</p>\n'},VXql:function(n,t){n.exports='<h4 id="js-call-apply-">JS call() apply()调用</h4>\n<p>在特定的作用域内调用某函数函数，等于改变了该函数体this的指向</p>\n<pre><code>// 调用apply方法传入一个数组\n(function callSum(a, b) {\n    sum.apply(this, [a, b]);\n    sum.apply(this, arguments);\n})(1, 1);\n// 声明一个方法sum作为调用apply和call方法的函数\nfunction sum(a, b) {\n    console.log(this) //this.window\n    console.log(a + b); //2\n}\n//可以理解为在callSum方法，添加一个属性，值为sum方法。\n// function callSum() {\n//     var sum = function() {}\n// }</code></pre><pre><code>// 调用apply方法传入一个数组, 和一个对象myObj\nvar myObj = {\n    a: &#39;hi&#39;\n};\nfunction testObj() {\n    console.log(this) //输出myObj\n    console.log(this.a) //输出hi\n}\ntestObj.apply(myObj);\n// callmyObj\n// 可以理解为：在myObj添加一个属性，值为testObj方法。\n// var myObj = {\n//     name: &#39;hi&#39;,\n//     testObj = function testObj() {\n//         console.log(this) //输出myObj\n//         console.log(this.name) //输出hi\n//     }\n// }</code></pre><pre><code>var myfunc = function() {\n    this.name = &#39;hello&#39;\n};\nvar testFunc = function() {\n    console.log(this.name)\n};\n// 调用apply方法传入一个数组,和一个对象myObj\n(function callTestFunc() {\n    testFunc.apply(new myfunc());\n})();</code></pre>'},WK65:function(n,t,i){"use strict";(function(n){var e=i("Xxa5"),l=i.n(e),o=i("exGp"),a=i.n(o),r=i("Usms"),p=i("HKE2"),s=i.n(p);t.a={data:function(){return{topNav:r.a.essayContent.title,topNavDetailsArr:[],topNavCurrent:0,currentArrEssay:[],showDetails:!1,currentDetails:"",articleLength:{length:0,Arr:[]},isScroll:!1,currentArea:0,currentScrollTop:0,allArticleArr:[],searchArticle:[],searchValue:"",isSearching:!1,currentBigImg:""}},computed:{},watch:{searchValue:function(n){""==n||this.isSearching||(this.isSearching=!0,this.findArtilce(n))}},components:{showdown:s.a},mounted:function(){this.getAllArticle(),this.init(0)},methods:{hideBigImg:function(){this.currentBigImg=!1},closeDetails:function(){var n=this;this.showDetails=!1,this.$nextTick(function(){console.log(n.currentScrollTop),document.getElementById("contentWrtap").scrollTop=n.currentScrollTop,document.getElementById("contentWrtap").addEventListener("scroll",n.handleScroll)})},switchTab:function(n){this.topNavCurrent=n,this.init(n)},showDetailsEvent:function(t){var i=this;console.log(this.currentScrollTop),this.showDetails=!0,this.currentDetails=t,this.$nextTick(function(){n("img").click(function(n){console.log(n.currentTarget.currentSrc),i.currentBigImg=n.currentTarget.currentSrc})})},getAllArticle:function(){var n=this;r.a.essayContent.details.forEach(function(t,i){t.article.forEach(function(t,i){t.content.forEach(function(t){n.allArticleArr.push(t)})})})},findArtilce:function(n){if(" "!=n){this.searchArticle=[];var t=this;this.allArticleArr.forEach(function(i,e){i.route.indexOf(n)>-1&&t.searchArticle.push(i)}),console.log(this.searchArticle),t.currentArrEssay=this.searchArticle,this.isSearching=!1}else this.init(0)},init:function(n){this.showDetails=!1;var t=this;t.currentArrEssay=[],t.articleLength.Arr=[],t.articleLength.Arr.push(0),t.articleLength.length=0;var i=new s.a.Converter;this.topNavDetailsArr=r.a.essayContent.title[n].detailsArr,r.a.essayContent.details[n].article.forEach(function(n,e){t.articleLength.length=t.articleLength.length+n.content.length,t.articleLength.Arr.push(n.content.length),n.content.forEach(function(t,e){var l=i.makeHtml(t.route.toString()),o=l.match("</(S*?)[^>]*>.*?");n.content[e].titleValue=l.slice(0,o.index)+o[0];var a=l.replace(/(<(\S*?)[^>]*>.*?)|\<.*?\>/g,"");l.slice(0,o.index).replace(/(<(\S*?)[^>]*>.*?)|\<.*?\>/g,"").length;n.content[e].brife=a.slice(7,150)+"..."}),t.currentArrEssay=t.currentArrEssay.concat(n.content)}),this.$nextTick(function(){document.getElementById("contentWrtap").scrollTop=this.currentScrollTop,document.getElementById("contentWrtap").addEventListener("scroll",t.handleScroll);document.getElementById("contentWrtap").clientHeight;var n=document.getElementById("contentWrtap").scrollHeight/t.articleLength.length;t.articleLength.Arr.forEach(function(i,e){t.articleLength.Arr[e]=0==e?i*n:i*n+t.articleLength.Arr[e-1]})})},handleScroll:function(){if(!this.isScroll){this.isScroll=!0;var n=document.getElementById("contentWrtap").scrollTop;this.currentScrollTop=n;var t=this.binarySearch(this.articleLength.Arr,n,0,this.articleLength.Arr.length-1);console.log("进入滚动区域",t),this.currentArea=t,t<0&&(this.currentArea=0),t>this.articleLength.Arr.length-2&&(this.currentArea=this.articleLength.Arr.length-2),this.isScroll=!1}},binarySearch:function(n,t,i,e){if(i>e)return i-1;var l=Math.floor((i+e)/2),o=n[l];return o>t?this.binarySearch(n,t,i,l-1):o<t?this.binarySearch(n,t,l+1,e):l},chooseArea:function(t){var i=this;return a()(l.a.mark(function e(){var o;return l.a.wrap(function(e){for(;;)switch(e.prev=e.next){case 0:if(!i.showDetails&&!i.searchValue){e.next=4;break}return i.searchValue="",e.next=4,i.init(i.topNavCurrent);case 4:o=i,document.getElementById("contentWrtap").scrollTop,n("#contentWrtap").animate({scrollTop:o.articleLength.Arr[t]},500);case 7:case"end":return e.stop()}},e,i)}))()}}}}).call(t,i("7t+N"))},WON3:function(n,t){n.exports='<h4 id="java-view-controller-service-dao">java层的概念关系 View、Controller、Service、DAO</h4>\n<p>前提：没有这人为规定的这几层，也是可以开发的，那为什么要分层？</p>\n<h5 id="-">分层的意义</h5>\n<ul>\n<li>高内聚，低耦合</li>\n<li>代码可扩展性和适应性更强</li>\n<li>维护简单</li>\n</ul>\n<h5 id="-">层级介绍</h5>\n<ul>\n<li>Controller:可以简单理解控制视图的跳转，也控制业务的逻辑，但是不是实现者，只需要调用service层的方法</li>\n<li>Service:业务逻辑层，业务逻辑的具体实现层，接着Controller层，给controller提供接口，调用DAO的接口</li>\n<li>DAO:(Data Access Object)持久层主要与数据库进行交互，数据访问对象。是负责数据访问处理，为service层提供接口。如果查询，则返回对象，如果增删改查，则返回boolean </li>\n<li>Entity层:(domain层)实体层数据库在项目中的类</li>\n<li>View层:与控制层结合比较紧密，需要二者结合起来协同工发</li>\n</ul>\n'},X8DO:function(n,t){n.exports=function(n,t){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:t}}},"XW/L":function(n,t){n.exports='<h4 id="ssh-">SSH基本概念和用途</h4>\n<h5 id="ssh-">SSH是什么</h5>\n<p>简单的说，SSH是一种网络协议，主要用于客户端与远程主机的安全链接和交互。</p>\n<h5 id="-">常见用法</h5>\n<h6 id="-">客户端与远程主机的安全链接命令如下：</h6>\n<pre><code>$ ssh -p 2222 user@host\n-p 2222 ：指定端口号2222\n   user ：登陆用户名\n   host ：远程主机地址</code></pre><h5 id="-">安全链接的过程是（非对称加密）</h5>\n<ul>\n<li>远程主机端收到客户端的登陆请求时先发送自己的公钥给客户端</li>\n<li>客户端用拿到的公钥加密用户名和密码，然后发送给远程主机</li>\n<li>远程主机用自己的密钥解密收到的用户名和密码，然后校验用户名和密码是否正确，如果正确则登陆成功。</li>\n</ul>\n<h5 id="-">在链接的过程中会有如下信息</h5>\n<pre><code>$ ssh user@host\n　　The authenticity of host &#39;host (12.18.429.21)&#39; can&#39;t be established.\n　　RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\n　　Are you sure you want to continue connecting (yes/no)?</code></pre><p>会用一个确认，提醒客户端是否确定链接此远程主机，并打印出了主机的公钥指纹：98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.\n远程主机的公钥指纹可以到远程主机的WEB页面进行人工确认。</p>\n<h5 id="-">客户端免密登陆远程主机</h5>\n<p>如果只是通过第一步，以后的每次登陆都需要输入登陆密码，SSH提供了公钥登陆（免密登陆）\n公钥登录的流程如下：\n1.客户端在自己本地生成一对公钥密钥文件，然后将公钥存储在远程主机上\n2.客户端登陆时，远程主机会随机生成一串字符串发送给客户端\n3.客户端用自己的密钥将收到的字符串加密，并返回给远程主机\n4.远程主机利用公钥解密收到的加密字符串，如果解密成功并且与发送的一致则直接免密登陆。</p>\n'},Xxa5:function(n,t,i){n.exports=i("jyFz")},Xzoj:function(n,t){n.exports='<h2 id="-">进程、线程、多线程</h2>\n<h3 id="-">进程</h3>\n<h5 id="-">狭义定义</h5>\n<p>一段程序的执行过程</p>\n<h5 id="-">广义定义</h5>\n<p>进程是一个具有一定独立功能的程序关于某个数据集合的一次运次活动。是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元、也是基本的执行单元。</p>\n<h6 id="-">进程的主要概念</h6>\n<ul>\n<li>进程是实体，每一个进程都有它自己的地址空间，一般情况，包括文本区域、数据区域、堆栈。文本区域存储处理器执行的代码，数据区域存储变量和进程执行期间的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</li>\n<li>进程是一个&quot;执行中的程序&quot;，程序是一个没有生命的实体，只有处理器赋予程序生命时，才能成为一个活动的实体，我们称其为进程。<h6 id="-">进程的状态</h6>\n</li>\n<li>就绪：获取了除CPU之外的所有资源，只要处理器分配资源就可以马上执行。就绪状态有排队序列。</li>\n<li>运行态：获得处理器分配的资源，程序开始执行。</li>\n<li>阻塞态：当程序条件不足时，等待条件满足时候才执行。<h3 id="-">程序</h3>\n程序是指令与数据的有序集合，其本身没有任何运行意义，是一个静态的概念。而进程则是处理机上的一次执行过程，他是一个动态的概念。进程是包含程序的，进程的执行离不开程序，进程中的文本区就是代码区，也就是程序。</li>\n</ul>\n<h3 id="-">线程</h3>\n<p>通常一个进程包含若干个线程，一个进程至少一个线程。线程线程可以利用进程所拥有的资源，在引入线程的操作系统中，通常都是把进程作为分配资源的基本单位，而把线程作为独立运行和调度的基本单位，由于线程比进程更小，基本上不拥有系统资源，故对它的调度所付出的开销就会小很多，能够高效的提高系统多个程序间并发执行的程度。</p>\n<h3 id="-">多线程</h3>\n<p>在一个程序中，独立运行的代码片段叫做“线程”，利用它编程的概念就叫做“多线程处理”。多线程是为了同步完成多项任务，不是为了提高运行的效率，而是为了提高资源使用率。线程是在同一时间需要完成多项任务的时候实现的</p>\n<h4 id="-">区别</h4>\n<h5 id="-">进程和线程的主要别在于它们是在不同的操作系统资源管理方式。</h5>\n<p>进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但是线程之间没有独立的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率差点。但对于一些要求同时进行并且共享某些变量的并发操作，只能用线程，不能用进程。</p>\n<ul>\n<li>一个程序至少有一个进程，一个进程至少有一个线程</li>\n<li>线程的划分尺度小于进程，是的多线程的并发性高</li>\n<li>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大的提高了程序的运行效率。</li>\n<li>每一个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。线程不能独立执行，必须依存在应用程序中，又应用程序提供多个线程执行控制。</li>\n<li>从逻辑角度看，多线程的意义在于一个应用程序中，有多个执行部分可以执行。但是应用没有将多个线程看做独立的应用，来实现进程的调整以及资源的分配</li>\n</ul>\n<h4 id="-">优缺点</h4>\n<p>线程进行开销小，但不利于资源的管理和维护；进程相反。线程适合在SMP多核处理机机器上运行，进程可以跨机器迁移。</p>\n<h4 id="-">简单介绍</h4>\n<p>进程（process）和线程（thread）是操作系统的基本概念。\n计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。\n进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。\n一个车间里，可以有很多工人。他们协同完成一个任务。\n线程就好比车间里的工人。一个进程可以包括多个线程。\n车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。\n可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。\n一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫&quot;互斥锁&quot;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。\n还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。\n这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做&quot;信号量&quot;（Semaphore），用来保证多个线程不会互相冲突。\n不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。\n操作系统的设计，因此可以归结为三点：\n（1）以多进程形式，允许多个任务同时运行；（2）以多线程形式，允许单个任务分成不同的部分运行；（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。\n总论：进程和线程都是一个时间段的描述，是CPU工作时间段的描述。</p>\n<p>下面细说背景：\nCPU+RAM+各种资源（比如显卡，光驱，键盘，GPS, 等等外设）构成我们的电脑，但是电脑的运行，实际就是CPU和相关寄存器以及RAM之间的事情。\n一个最最基础的事实：CPU太快，太快，太快了，寄存器仅仅能够追的上他的脚步，RAM和别的挂在各总线上的设备完全是望其项背。那当多个任务要执行的时候怎么办呢？轮流着来?或者谁优先级高谁来？不管怎么样的策略，一句话就是在CPU看来就是轮流着来。\n一个必须知道的事实：执行一段程序代码，实现一个功能的过程介绍 ，当得到CPU的时候，相关的资源必须也已经就位，就是显卡啊，GPS啊什么的必须就位，然后CPU开始执行。这里除了CPU以外所有的就构成了这个程序的执行环境，也就是我们所定义的程序上下文。当这个程序执行完了，或者分配给他的CPU执行时间用完了，那它就要被切换出去，等待下一次CPU的临幸。在被切换出去的最后一步工作就是保存程序上下文，因为这个是下次他被CPU临幸的运行环境，必须保存。\n串联起来的事实：前面讲过在CPU看来所有的任务都是一个一个的轮流执行的，具体的轮流方法就是：先加载程序A的上下文，然后开始执行A，保存程序A的上下文，调入下一个要执行的程序B的程序上下文，然后开始执行B,保存程序B的上下文。。。。\n========= 重要的东西出现了========\n进程和线程就是这样的背景出来的，两个名词不过是对应的CPU时间段的描述，名词就是这样的功能。\n进程就是包换上下文切换的程序执行时间总和 = CPU加载上下文+CPU执行+CPU保存上下文\n线程是什么呢？\n进程的颗粒度太大，每次都要有上下的调入，保存，调出。如果我们把进程比喻为一个运行在电脑上的软件，那么一个软件的执行不可能是一条逻辑执行的，必定有多个分支和多个程序段，就好比要实现程序A，实际分成 a，b，c等多个块组合而成。那么这里具体的执行就可能变成：\n程序A得到CPU =》CPU加载上下文，开始执行程序A的a小段，然后执行A的b小段，然后再执行A的c小段，最后CPU保存A的上下文。\n这里a，b，c的执行是共享了A的上下文，CPU在执行的时候没有进行上下文切换的。这里的a，b，c就是线程，也就是说线程是共享了进程的上下文环境，的更为细小的CPU时间段。\n进程和线程都是一个时间段的描述，是CPU工作时间段的描述，不过是颗粒大小不同。</p>\n'},Yobk:function(n,t,i){var e=i("77Pl"),l=i("qio6"),o=i("xnc9"),a=i("ax3d")("IE_PROTO"),r=function(){},p=function(){var n,t=i("ON07")("iframe"),e=o.length;for(t.style.display="none",i("RPLV").appendChild(t),t.src="javascript:",(n=t.contentWindow.document).open(),n.write("<script>document.F=Object<\/script>"),n.close(),p=n.F;e--;)delete p.prototype[o[e]];return p()};n.exports=Object.create||function(n,t){var i;return null!==n?(r.prototype=e(n),i=new r,r.prototype=null,i[a]=n):i=p(),void 0===t?i:l(i,t)}},Z80C:function(n,t){n.exports='<h4 id="-">前端面试</h4>\n<h4 id="-">常见排序算法的时间复杂度，空间复杂度</h4>\n<ul>\n<li>时间复杂度：最好最坏情况</li>\n<li>空间复杂度:临时变量个数</li>\n</ul>\n<p>排序方法|解释|最好情况|最坏情况|空间复杂度| \n---|---|---|---|---|---|\n插入排序|将一新的数据插入一有序数组，并保持有序|O(n)|O(n^2)|O(1)</p>\n<h4 id="seo">SEO</h4>\n<ul>\n<li>合理的title、decription、keywords.搜索对着这三项的权重逐渐减小。关键词不要超过2次。不同页面Title不同，description高度概括。</li>\n<li>标签语义化</li>\n<li>重要HTML代码置前，搜索引擎从上往下，抓取长度有限。</li>\n<li>重要内容不要用JS输出，爬虫不会抓取JS获取内容</li>\n<li>少用Iframe，搜索引擎不会抓取Iframe内容</li>\n<li>非装饰性图片必须加alt</li>\n<li>提高网站速度，网站速度是搜索引擎排序的重要指标</li>\n</ul>\n<h4 id="web-">Web会话跟踪</h4>\n<h5 id="-">什么是会话？</h5>\n<ul>\n<li>客户端打开与服务器的连接发出请求到服务器响应客户端请求的全过程称之为会话 。 <h5 id="-">什么是会话跟踪？</h5>\n</li>\n<li>对同一用户对服务器的连续请求与响应进行监视<h5 id="-">为什么需要会话跟踪</h5>\n</li>\n<li>HTTP是无状态协议</li>\n<li>Web服务器不能记忆客户端的特定用户<h5 id="-">会话跟踪的方式</h5>\n</li>\n<li>cookie Cookie在你浏览网页的时候，网站服务器放在客户端（Client End，就是你的电脑）里面的一个小小的TXT文件。这个文件里面存储了一些与你访问的这个网站有关的一些东西，当你下一次访问这个网站的时候，Cookie就会记住你上次访问时候的一些状态或者设置，让服务器针对性的发送页面的相关内容。Cookie里面包含的信息并没有一个标准的格式，各个网站服务器的规范都可能不同，但一般会包括：所访问网站的域名（domain name），访问开始的时间，访问者的IP地址等客户端信息，访问者关于这个网站的一些设置等等。比如，你设置的诸如Google一个页面要显示几条搜索结果之类的信息，即使你不登录你的Google账号，你下次访问时也能够保存下来，这就是上次你访问时把相关信息放入了Cookie的效果。如果是在线购物网站，还记录了一些你的购物车，储物架以及你的账户名等信息。另外有些网站则会通过Cookie把你的登录账号和密码记下来，这样你下次打开浏览器就会自动登录。\n当然，如果你在系统文件夹中打开Cookie的TXT文件，你并不会看到这些信息而只能看到一串乱七八糟的字符，因为为了安全起见，Cookie的内容一般都是加密的，只有对应的服务器才能读懂。另外，由于Cookie只是TXT文件，而不是程序，更不是病毒，不能自己运行，不会对操作系统和其他任何计算机程序产生影响，也不会通过互联网传播，因此它对互联网安全实际上不构成威胁。</li>\n<li>session</li>\n<li>url重写</li>\n<li>隐藏input</li>\n</ul>\n<p><img>的title、alt作用</p>\n<ul>\n<li>title:advisory iinformation 鼠标滑到显示文本</li>\n<li>alt:图片无法显示时候，提示文本</li>\n</ul>\n<h4 id="doctype">doctype</h4>\n<ul>\n<li><!doctype>声明处于HTML的头部</li>\n<li>告诉浏览器当前的文档版本</li>\n</ul>\n<h4 id="html-global-attribute-">HTML全局属性（Global attribute）</h4>\n<ul>\n<li>accesskey:设置快捷键</li>\n<li>class:为元素设置类标识</li>\n<li>conteneditable：元素是否可以编辑</li>\n<li>contextmenu:自定义鼠标右键弹出内容</li>\n</ul>\n'},ZAS4:function(n,t){n.exports='<h4 id="js-scope-closure">Js作用域 作用域链[scope] 闭包closure</h4>\n<ul>\n<li>“javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句</li>\n<li>javascript除了全局作用域之外，只有函数可以创建作用域</li>\n<li>作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的</li>\n<li>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突</li>\n<li>作用域在函数定义时就已经确定了。而不是在函数调用时确定</li>\n</ul>\n<h5 id="-">例子</h5>\n<pre><code>if(true){\n    let a = 1;\n}\nconsole.log(a)  //1 说明javascript没有块级作用域</code></pre><p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/8.png?raw=true" alt="image">  </p>\n<h5 id="-">自由变量</h5>\n<p>在A作用域中使用的变量x,却没有在A作用域声明，对于A作用域来说，x就是一个自由变量。\n<strong>在fn函数中，取自由变量x的值时，要到哪个作用域中取？要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。</strong></p>\n<pre><code>var x =10;\nfunction fn()\n{\nconsole.log(x);//10\n}\n\nfunction show(f){\nvar x =30;\nf();\n}\nshow(fn);</code></pre><h5 id="-a-">取自由变量时的这个“作用域链”过程：（假设a是自由量）</h5>\n<ul>\n<li>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</li>\n<li>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</li>\n<li>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</li>\n<li>第四步，跳转到第一步。</li>\n</ul>\n<pre><code>var a =1;\nfunction fn(){\n   var b=3;\n   function show(){\n      console.log(a+b); //4\n   };\n   return show;\n}\nvar x =fn();\nvar b=12;\nx();</code></pre><h5 id="-">闭包</h5>\n<p>闭包属于一种特殊的作用域，称为<strong>静态作用域</strong>。它的定义可以理解为: 父函数被销毁 的情况下，返回出的子函数的[[scope]]中仍然保留着父级的单变量对象和作用域链，因此可以继续访问到父级的变量对象，这样的函数称为闭包。\n闭包（closure）就是能够读取其他函数内部变量的函数。\n闭包可以简单理解成“定义在一个函数内部的函数”。</p>\n<p><strong>注意：自由变量跨作用域取值时，要去创建这个函数的作用域取值，而不是“父作用域”。</strong></p>\n<h5 id="-">闭包的好处</h5>\n<ul>\n<li>希望一个变量长期驻扎在内存当中；</li>\n<li>避免全局变量的污染</li>\n<li>私有成员的存在</li>\n</ul>\n<h5 id="-">使用闭包存在问题：</h5>\n<ul>\n<li>局部上下文活动对象，作用域没有及时销毁，增加内存开销</li>\n</ul>\n<h5 id="-">闭包的应用</h5>\n<ol>\n<li>函数作为返回值</li>\n</ol>\n<pre><code>//函数作为返回值\nfunction fn(){\n var max = 10;\n return function bar(x){\n   console.log(max); //10\n }\n}\nvar f1 = fn();\nf1();</code></pre><ol start="2">\n<li>函数作为参数传递<pre><code>//函数作为参数传递\nvar max = 12;\nfunction fn(){\n console.log(max);//12\n}\n(function(f){\n var max =100;\n f();\n})(fn)</code></pre></li>\n<li>模块化代码</li>\n</ol>\n<pre><code>var test = (function(){\n    var a= 1;\n    return function(){\n        a++;\n        console.log(a)\n    }\n})();\n\ntest();//2\ntest();//3\n/*\n  类似var test  = function(){}\n  test指向指向这个匿名函数里面的一个函数，所以这个匿名函数的内存不能得到释放，a的值也会一直存在。\n*/</code></pre><ol start="4">\n<li>循环闭包</li>\n</ol>\n<p>存在问题如下:\n每次for循环，虽然都会有不同的i值，但是因为for循环里面有定时器函数，所以本作用域内存没有被销毁，最终i的值会是4，而当定时器执行时候，会先在本函数找i,找不到i时候，向上一级查找，也就是4。</p>\n<pre><code>//定时器里面的匿名函数要输出i,要会在外层的声明它本身的父作用域找，最后的的i是5。\nfor(var i=0;i&lt;5;i++){\n  setTimeout(()=&gt;{\n    console.log(i)\n   },1000)\n}</code></pre><p>解决方式：</p>\n<p>原理：</p>\n<ol>\n<li>作用域链</li>\n<li>闭包函数的赋值与运行</li>\n</ol>\n<p>利用自执行匿名函数块，可以每次都生成不同的的作用域块，并且将i值传进不同作用域，开辟新的内存存储变量i,执行定时器时候，就会在各自的作用域内获取i值了。</p>\n<pre><code>(function(){\n        // 这里为块级作用域，可以减少闭包的内存占用，因为外部没有对匿名函数进行引用，函数执行完毕，就会被销毁。\n })();\n\n for(var i=0;i&lt;5;i++){\n  (function(i){\n     setTimeout(()=&gt;{\n    console.log(i)\n   },1000)\n  })(i)\n}</code></pre>'},aJAk:function(n,t){n.exports='<h4 id="java-">Java高级</h4>\n<p>Java 数据结构\nJava工具包提供了强大的数据结构。在Java中的数据结构主要包括以下几种接口和类：</p>\n<ul>\n<li>枚举（Enumeration）</li>\n<li>位集合（BitSet）</li>\n<li>向量（Vector）</li>\n<li>栈（Stack）</li>\n<li>字典（Dictionary）</li>\n<li>哈希表（Hashtable）</li>\n<li>属性（Properties）</li>\n</ul>\n<h5 id="-enumeration-">枚举（Enumeration）</h5>\n<p>枚举（Enumeration）接口虽然它本身不属于数据结构,但它在其他数据结构的范畴里应用很广。 枚举（The Enumeration）接口定义了一种从数据结构中取回连续元素的方式。</p>\n<p>例如，枚举定义了一个叫nextElement 的方法，该方法用来得到一个包含多元素的数据结构的下一个元素。</p>\n<h5 id="-bitset-">位集合（BitSet）</h5>\n<p>位集合类实现了一组可以单独设置和清除的位或标志。</p>\n<p>该类在处理一组布尔值的时候非常有用，你只需要给每个值赋值一&quot;位&quot;，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p>\n<h5 id="-vector-">向量（Vector）</h5>\n<p>向量（Vector）类和传统数组非常相似，但是Vector的大小能根据需要动态的变化。</p>\n<p>和数组一样，Vector对象的元素也能通过索引访问。</p>\n<p>使用Vector类最主要的好处就是在创建对象的时候不必给对象指定大小，它的大小会根据需要动态的变化。</p>\n<h5 id="-stack-">栈（Stack）</h5>\n<p>栈（Stack）实现了一个后进先出（LIFO）的数据结构。</p>\n<p>你可以把栈理解为对象的垂直分布的栈，当你添加一个新元素时，就将新元素放在其他元素的顶部。</p>\n<p>当你从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</p>\n<h5 id="-dictionary-">字典（Dictionary）</h5>\n<p>字典（Dictionary） 类是一个抽象类，它定义了键映射到值的数据结构。</p>\n<p>当你想要通过特定的键而不是整数索引来访问数据的时候，这时候应该使用Dictionary。</p>\n<p>由于Dictionary类是抽象类，所以它只提供了键映射到值的数据结构，而没有提供特定的实现。</p>\n<h5 id="-hashtable-">哈希表（Hashtable）</h5>\n<p>Hashtable类提供了一种在用户定义键结构的基础上来组织数据的手段。</p>\n<p>例如，在地址列表的哈希表中，你可以根据邮政编码作为键来存储和排序数据，而不是通过人名。</p>\n<p>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。</p>\n<h5 id="-properties-">属性（Properties）</h5>\n<p>Properties 继承于 Hashtable.Properties 类表示了一个持久的属性集.属性列表中每个键及其对应值都是一个字符串。</p>\n<p>Properties 类被许多Java类使用。例如，在获取环境变量时它就作为System.getProperties()方法的返回值。</p>\n<h5 id="java-">Java 集合框架</h5>\n<p>早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary, Vector, Stack, 和 Properties 这些类用来存储和操作对象组。</p>\n<p>虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。</p>\n<p>集合框架被设计成要满足以下几个目标。</p>\n<p>该框架必须是高性能的。基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</p>\n<p>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</p>\n<p>对一个集合的扩展和适应必须是简单的。</p>\n<p>为此，整个集合框架就围绕一组标准接口而设计。你可以直接使用这些接口的标准实现，诸如： LinkedList, HashSet, 和 TreeSet 等,除此之外你也可以通过这些接口实现自己的集合。</p>\n'},ax3d:function(n,t,i){var e=i("e8AB")("keys"),l=i("3Eo+");n.exports=function(n){return e[n]||(e[n]=l(n))}},bRrM:function(n,t,i){"use strict";var e=i("7KvD"),l=i("FeBl"),o=i("evD5"),a=i("+E39"),r=i("dSzd")("species");n.exports=function(n){var t="function"==typeof l[n]?l[n]:e[n];a&&t&&!t[r]&&o.f(t,r,{configurable:!0,get:function(){return this}})}},dN4I:function(n,t){n.exports='<h4 id="java-annotation-n-te-n-">Java注解Annotation[ænə&#39;teɪʃn]</h4>\n<p>A.Java注解只是为代码的元素（类，方法，方法参数等）提供描述。可以省略不写</p>\n<p>B.注解是为了去注释说明，编译时候进行判断，如果不是我们跟我们注释的预想的，就会报错。</p>\n<p>C.注解的内容：</p>\n<ol>\n<li><p>Java自带注解</p>\n<ol>\n<li>@Override 标记方法是重写的 </li>\n<li>@Deprecated 声明被注解的内容已过时，不建议使用 </li>\n<li>SupressWarning 使用@SupressWarning标注忽略@Deprecated编译错误提示。 </li>\n</ol>\n</li>\n<li><p>自定义注解</p>\n<pre><code>@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface AnimalTrait{\n  int footNum() default 0;\n  boolean bitePeople default false;\n}\n\n*** @Target ***\nElementType.ANNOTATION_TYPE\n可以给一个注解进行注解\nElementType.CONSTRUCTOR\n构造方法\nElementType.FIELD\n类属性\nElementType.LOCAL_VARIABLE\n局部变量\nElementType.METHOD\n方法\nElementType.PACKAGE\n包\nElementType.PARAMETER\n方法参数\nElementType.TYPE\n类、接口、枚举等\n\n*** @Retention ***\nRetentionPolicy.SOURCE        \n只在源码时作用\nRetentionPolicy.CLASS    \n源码及编译期作用\nRetentionPolicy.RUNTIME    \n源码、编译期和运行时都起作用\n\n两个可选元注解\n*** @Documented ***\n表示生成javadoc时也包括当前自定义注解\n\n*** @Inherited ***\n表示当前注解能被继承。但不是指继承自定义注解，是指某个类继承了一个使用了这个注解的类时，这个注解也被继承。</code></pre><ol start="3">\n<li>注解处理器<ul>\n<li>注解处理是使用Java反射来完成的。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ol>\n<p>D.总结</p>\n<ul>\n<li>Java注解只是对代码元素提供描述，它并不影响代码执行；</li>\n<li>影响代码执行的是注解处理器，利用反射机制获取注解属性；</li>\n<li>通过@interface定义注解，通过@Target、@Retention、@Documented和@Inherited元注解来设定注解的类型、生命周期、是否生成到Javadoc和是否被继承；</li>\n<li>注解可以有属性，但属性只能是8种基础类型、String、Class、enum、Annotation和以上的数组形式。</li>\n</ul>\n<h3 id="spring-">Spring注解</h3>\n<h4 id="bean">Bean</h4>\n<ul>\n<li>java面向对象，对象有方法、属性，对象实例化调用方法和属性</li>\n<li>实例化即具象化才能调用类方法和属性</li>\n<li></li>\n</ul>\n'},dNDb:function(n,t){n.exports=function(n){try{return{e:!1,v:n()}}catch(n){return{e:!0,v:n}}}},dSzd:function(n,t,i){var e=i("e8AB")("wks"),l=i("3Eo+"),o=i("7KvD").Symbol,a="function"==typeof o;(n.exports=function(n){return e[n]||(e[n]=a&&o[n]||(a?o:l)("Symbol."+n))}).store=e},dY0y:function(n,t,i){var e=i("dSzd")("iterator"),l=!1;try{var o=[7][e]();o.return=function(){l=!0},Array.from(o,function(){throw 2})}catch(n){}n.exports=function(n,t){if(!t&&!l)return!1;var i=!1;try{var o=[7],a=o[e]();a.next=function(){return{done:i=!0}},o[e]=function(){return a},n(o)}catch(n){}return i}},dybF:function(n,t){n.exports='<h4 id="-">运输层</h4>\n<h5 id="-">概述</h5>\n<p>运输层提供应用层端到端通信服务，通俗的讲，两个主机通讯，也就是应用层上的进程之间的通信，也就是转换为进程和进程之间的通信了，我们之前学到网络层，IP协议能将分组准确的发送到目的主机，但是停留在网络层，并不知道要怎么交给我们的主机应用进程，通过前面的学习，我们学习有mac地址，通过mac地址能找到同一个网络下主机，有IP地址，通过ip地址能找到不同网络下的网络，结合mac地址就能找到对应主机，那么怎么找到主机应用进程呢，肯定也有一个东西来标识它，那就是我们常说的<strong>端口</strong>了。</p>\n<h5 id="-">端口</h5>\n<p>占有16位，其大小也就有65536个，是从0~65535.也就是一台计算机有65535个端口，主机之间的通讯，也就是应用进程之间的通讯，都要依靠端口，一个进程对应一个端口，进程A和进程B通信，进程A分到的端口为60000，进程B分到的端口为60001，进程A通过端口60000发送数据给进程B，就知道要交给60001端口，也就到了进程B中，这样就达到了通信的目的。</p>\n<h5 id="-">熟知端口、登记端口、客户端端口</h5>\n<ul>\n<li>熟知端口：0-1023， 也就是一些固定的端口号，比如http使用的80端口，意思就是在访问网址时，我们访问服务器的端口就是80，然后服务器那边传网页的数据给我们。</li>\n<li>登记端口：1024-49151，比如微软开发了一个系统应用，该应用在通讯或使用时，需要使用到xxx端口，那么就要去登记一下这个端口，以免有别人公司的应用使用同一个端口号，例如，windows系统中的3389端口，就是用来实现远程连接的，就固定了这台计算机如果要使用远程连接服务，就打开3389端口，别人就能使用远程连接连你了，默认是不打开的。</li>\n<li>客户端端口：49152-65535，一般我们使用某个软件，比如QQ，等其他服务，随机拿这个范围内的端口，而不是去拿前面哪些固定的，拿到等通讯结束后，就会释放该端口。</li>\n</ul>\n<p>运输层就是将两个端口连起来通信的介质，不然光知道两个端口有什么用，怎么通信的，还是要靠运输层来做这个事情，其中重要的就是靠两个协议，UDP和TCP协议。</p>\n<h5 id="udp-">UDP协议</h5>\n<p>UDP:(User Datagram Protocol) 用户数据报协议，无连接、不可靠</p>\n<ul>\n<li>无连接：意思就是在通讯之前不需要建立确定连接，直接传输数据。</li>\n<li>不可靠：是将数据报的分组从一台主机发送到另一台主机，但并不保证数据报能够到达另一端，任何必须的可靠性都由应用程序提供。在 UDP情况下，虽然可以确保发送消息的大小，却不能保证消息一定会达到目的端。没有超时和重传功能，当 UDP 数据封装到 IP 数据报传输时，如果丢失，会发送一个 ICMP差错报文给源主机。即使出现网络阻塞情况，UDP也无法进行流量控制。此外，传输途中即使出现丢包，UDP 也不负责重发，甚至当出现包的到达顺序杂乱也没有纠正的功能。</li>\n</ul>\n<h5 id="udp-">UDP首部</h5>\n<ul>\n<li>源端口号：占16位，源主机的应用进程所使用的端口号</li>\n<li>目标端口号：占16位，目标主机的应用进程所使用的端口号，也就是我们需要通信的目标进程</li>\n<li>UDP报长度：UDP用户数据报的长度，数据部分+UDP首部之和为UDP报长度。</li>\n<li>检验和：检验和是为了提供可靠的 UDP首部和数据而设计，这里不要和上面的不可靠传输搞混淆了，这里提供可靠的UDP首部，是因为一个进程可能接受多个进程过来的报文，那么如何区分他们呢，就是通过5个东西来进行区分的， “源IP地址”、“目的IP地址”、“协议号”、“源端口号”、“目标端口号”的，这个检测可靠，是检测接受哪个正确的报文，也就是说是哪个报文要进这个端口，那个不可靠，说的是这个报文可能丢失，可能其中数据损坏了我们不关心，但是这些的前提是，你得传输到正确的目的地去。<h5 id="udp-">UDP伪首部</h5>\n就是拿到IP层的一些数据，因为要进行检验和，就必须要有这些数据。其中检验的算法跟IP层中检验首部的办法是一样的。</li>\n</ul>\n<p>一个目标进程中，其中的报文，目标端口，目标ip地址肯定都一样的，但是源IP地址和源端口就可能不一样，这就说明了不同源而同一目的地的报文会定位到同一队列。这跟接下来我们要讨论的TCP不一样，因为UDP是无连接的，大家都是用这一条通道，所以其队列中就会出现上面所说的这样的情况。</p>\n<h5 id="-udp-">使用UDP协议的例子：</h5>\n<ul>\n<li>应用层协议中DNS，也就是根据域名解析ip地址的一个协议，他使用的就是UDP</li>\n<li>DHCP,这个是给各电脑分配ip地址的协议，其中用的也是UDP协议</li>\n<li>IGMP，我们说的多播，也就是使用的UDP，在多媒体教师，老师拿笔记本讲课，我们在下面通过各自的电脑看到老师的画面，这就是通过UDP传输数据，所以会出现有的同学卡，有的同学很流畅，就是因为其不可靠传输，但是卡一下，对接下来的观看并没有什么影响</li>\n</ul>\n<h4 id="tcp-">TCP协议</h4>\n<p>TCP协议是面向连接的、可靠传输、有流量控制，拥塞控制，面向字节流传输等很多优点的协议。其最终功能和UDP一样，在端和端之间进行通信，但是和UDP的区别还是很大的。</p>\n<h5 id="tcp-">TCP报文的结构</h5>\n<ul>\n<li>源端口号</li>\n<li>目标端口号</li>\n<li>序列号：因为在TCP是面向字节流的，他会将报文度分成一个个字节，给每个字节进行序号编写，比如一个报文有900个字节组成，那么就会编成1-900个序号，然后分几部分来进行传输，比如第一次传，序列号就是1，传了50个字节，那么第二次传，序列号就为51，所以序列号就是传输的数据的第一个字节相对所有的字节的位置。</li>\n<li>确认应答：如刚说的例子，第一次传了50个字节给对方，对方也会回应你，其中带有确认应答，就是告诉你下一次要传第51个字节来了，所以这个确认应答就是告诉对方要传第多少个字节了</li>\n<li>首部长度：就是首部的长度</li>\n<li>保留：给以后有需要在用，这个保留的位置放的东西是跟控制位类似的</li>\n<li>控制位：目前有的控制位为6个</li>\n<li>URG:紧急，当URG为1时，表名紧急指针字段有效，标识该报文是一个紧急报文，传送到目标主机后，不用排队，应该让该报文尽量往下排，让其早点让应用程序给接受。</li>\n<li>ACK:确认，当ACK为1时，确认序号才有效。当ACK为0时，确认序号没用</li>\n<li>PSH：推送，当为1时，当遇到此报文时，会减少数据向上交付，本来想应用进程交付数据是要等到一定的缓存大小才发送的，但是遇到它，就不用在等足够多的数据才向上交付，而是让应用进程早点拿到此报文，这个要和紧急分清楚，紧急是插队，但是提交缓存大小的数据不变，这个推送就要排队，但是遇到他的时候，会减少交付的缓存数据，提前交付。</li>\n<li>RST:复位，报文遇到很严重的差错时，比如TCP连接出错等，会将RST置为1，然后释放连接，全部重新来过。</li>\n<li>SYN：同步，在进行连接的时候，也就是三次握手时用得到，下面会具体讲到，配合ACK一起使用</li>\n<li>FIN：终止，在释放连接时，也就是四次挥手时用的。</li>\n<li>窗口：指发送报文段一方的接受窗口大小，用来控制对方发送的数据量(从确认号开始，允许对方发送的数据量)。也就是后面需要讲的滑动窗口的窗口大小</li>\n<li>检验和：检验首部和数据这两部分，和UDP一样，需要拿到伪首部中的数据来帮助检测</li>\n<li>选项：长度可变，介绍一种选项，最大报文段长度，MSS。能够告诉对方TCP，我的缓存能接受报文段的数据字段的最大长度是MSS个字节。如果没有使用选项，那么首部固定是20个字节</li>\n<li>填充：就是为了让其成为整数个字节</li>\n</ul>\n<h5 id="-">面向连接</h5>\n<p>(三次握手)：在通信之前，会先通过三次握手的机制来确认两端口之间的连接是否可用。而UDP不需要确认是否可用，直接传。</p>\n<h5 id="-">三次握手机制</h5>\n<ol>\n<li>一开始客户端和服务端都市关闭状态，但是在某个时刻，客户端需要和服务端进行通信，此时双方都会各自准备好端口，服务器段的端口会处于监听状态，等待客户端的连接。客户端可会知道自己的端口号，和目的进程的端口号，这样才能发起请求。</li>\n<li>第一次握手：客户端想与服务器进行连接了，所以状态变为主动打开，同时发送一个连接请求报文给服务器段SYN=1，并且会携带x个字节过去。发送完请求连接报文后，客户端的状态就变为了SYN_SENT，可以说这个状态是等待发送确认(为了发送第三次握手时的确认包)</li>\n<li>第二次握手：服务端接收到连接请求报文后，从LSTTEN状态变为被动打开状态，然后给客户端返回一个报文。这个报文有两层意思，一是确认报文，而可以达到告诉客户端，我也打开连接了。发完后，变为SYN_RCVD状态(也可以说是等待接受确认状态，接受客户端发过来的确认包)</li>\n<li>第三次握手：客户端得到服务器端的确认和知道服务器端也已经准备好了连接后，还会发一个确认报文到服务器端，告诉服务器端，我接到了你发送的报文，接下来就让我们两个进行连接了。客户端发送完确认报文后，进入ESTABLISHED，而服务器接到了，也变为ESTABLISHED，进入到ESTABLISHED状态后，连接就已经完成了，可以进行通信了。</li>\n</ol>\n<h5 id="-">问题：为什么需要第三次握手，有前面两次不就已经可以了吗？</h5>\n<p>假设没有第三次握手，客户端发送一个连接请求报文过去，但是因为网络延迟，在等待了一个超时时间后，客户端就会在重新发一个请求连接报文过去，然后正常的进行，服务器端发回一个确认连接报文，然后就开始通讯，通讯结束后，那个第一次因为网络延迟的请求连接报文到了服务器端，服务器端不知道这个报文已经失效，也发回了一个确认连接报文，客户端接收后，发现自己并没有发送连接请求(因为超时了，所以就认为自己没有发)，所以对这个确认连接请求就什么也不做，但是此时客户端不这么认为，他认为i连接已经建立了，就一直打开着等待客户端传数据过来，这就造成了极大的浪费。如果有了第三次握手，那么客户端就可以通知服务器了。所以第三次握手也很重要。</p>\n<h5 id="-">同时打开连接请求</h5>\n<p>正常情况下，通信一方请求建立连接，另一方响应该请求，但是如果出现，通信双方同时请求建立连接时，则连接建立过程并不是三次握手过程，而且这种情况的连接也只有一条，并不会建立两条连接。同时打开连接时，两边几乎同时发送 SYN，并进入 SYN_SENT状态，当每一端收到 SYN 时，状态变为 SYN_RCVD，同时双方都再发 SYN 和 ACK 作为对收到的 SYN 进行确认应答。当双方都收到 SYN 及相应的 ACK 时，状态变为 ESTABLISHED</p>\n<ul>\n<li><p>可靠传输\n通过数据编号和积累确认、以字节为单位的滑动窗口、超时重传时间 、快速重传这四个方面来达到可靠传输的目的。</p>\n<ul>\n<li>数据编号：将每个字节进行编号，有900个字节，就从1到900进行编号</li>\n<li>积累确认：服务器端不是接收到一个字节就发一个确认，那样效率太低，而是当接收到4，5个时，在发送一个确认，那么在之前的确认之前的数据就算发送成功了的。</li>\n<li>滑动窗口：这个跟在数据链路层讲个滑动窗口一样。每次能发送的数据是在此窗口中的，接到了多少数据，就往后滑多少数据</li>\n<li>超时重传时间：这个也在链路层讲过，如果等待一段时间后，还没接收到确认报文，那么就重新传</li>\n<li>快速重传：在滑动窗口中的应用，比如传了12346到服务器端，老办法是在4之后的所有数据度要重新传，而这个快速重传就只需要等待传了5这个序号，就可以继续往下接收数据了。</li>\n</ul>\n</li>\n<li><p>流量控制\n在传输层中，有接受缓存和发送缓存这两个东西的存在，所以每次发送数据过去另一端时，都会把这些数据给带过去，让对方知道自己的这两个缓存的大小，然后来合理的设置自己的发送窗口的大小，如果对方的缓存快满了，对方在传送数据过来的时候，就会告诉自己，少发一点数据过来，自己就设置滑动窗口小一点，让对方有缓冲的机会，而不会导致缓存溢出，不让自己的报文被丢弃。</p>\n</li>\n<li><p>拥塞控制\n其实跟流量控制差不多，但是站的角度更大，此时既考虑了对方接收不过来，缓存太多溢出导致，又考虑在线路中，线路上的传输速率就那么大，但是有很多人同时用，发送的数据太多，就会使线路发现拥塞，也就是路由器可能转发不过来，导致大量数据丢失，这两个问题。所以拥塞控制这个解决方案，大概意思就是当检测到有网络拥塞时，就会让自己的滑动窗口变小，但具体是怎么变化的，就是根据算法来算了，发送窗口的上限值 = Min[rwnd，cwnd]    </p>\n<ul>\n<li>rwnd：接受窗口，根据接受缓存，而定的接受窗口，接收缓存还有很多，那么接收窗口就大</li>\n<li>cwnd：拥塞窗口，根据线路中的拥塞状况来决定，线路中不拥塞，那么此窗口就大，\n发送窗口是取两个中较小值。这个还是可以理解的。慢启动算法、快速恢复算法、结合来达到对拥塞进行控制的</li>\n</ul>\n</li>\n</ul>\n<h5 id="tcp-">TCP释放连接时的四次挥手</h5>\n<ul>\n<li>第一次挥手：从ESTABLISHED变为主动关闭状态，客户端主动发送释放连接请求给服务器端，FIN=1。发送完之后就变为FIN_WAIT_1状态，这个状态可以说是等待确认状态。</li>\n<li>第二次挥手：服务器接收到客户端发来的释放连接请求后，状态变为CLOSE_WAIT，然后发送确认报文给客户端，告诉他我接收到了你的请求。为什么变为CLOSE_WAIT，原因是是客户端发送的释放连接请求，可能自己这端还有数据没有发送完呢，所以这个时候整个TCP连接的状态就变为了半关闭状态。服务器端还能发送数据，并且客户端也能接收数据，但是客户端不能在发送数据了，只能够发送确认报文。客户端接到服务器的确认报文后，就进入了FIN_WAIT_2\n状态。也可以说这是等待服务器释放连接状态。</li>\n<li>第三次挥手：服务器端所有的数据度发送完了，认为可以关闭连接了，状态变为被动关闭，所以向客户端发送释放连接报文，发完之后自己变为LAST_WAIT状态，也就是等待客户端确认状态</li>\n<li>第四次挥手：客户端接到释放连接报文后，发送一个确认报文，然后自己变为TIME_WAIT,而不是立马关闭，因为客户端发送的确认报文可能会丢失，丢失的话服务器就会重传一个FIN，也就是释放连接报文，这个时候客户端必须还没关闭。当服务器接受到确认报文后，服务器就进入CLOSE状态，也就是关闭了。但是由于上面说的这个原因，客户端必须等待一定的时间才能够进入CLOSE状态。</li>\n</ul>\n<h5 id="-">同时关闭连接</h5>\n<p>正常情况下，通信一方请求连接关闭，另一方响应连接关闭请求，并且被动关闭连接。但是若出现同时关闭连接请求时，通信双方均从 ESTABLISHED 状态转换为 FIN_WAIT_1状态。任意一方收到对方发来的 FIN 报文段后，其状态均由 FIN_WAIT_1转变到 CLOSING 状态，并发送最后的 ACK 数据段。当收到最后的ACK数据段后，状态转变化TIME_WAIT，在等待 2MSL 时间后进入到 CLOSED 状态，最终释放整个TCP传输连接。其过程如下\n <img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/61.png?raw=true" alt="image"></p>\n'},e6n0:function(n,t,i){var e=i("evD5").f,l=i("D2L2"),o=i("dSzd")("toStringTag");n.exports=function(n,t,i){n&&!l(n=i?n:n.prototype,o)&&e(n,o,{configurable:!0,value:t})}},e8AB:function(n,t,i){var e=i("FeBl"),l=i("7KvD"),o=l["__core-js_shared__"]||(l["__core-js_shared__"]={});(n.exports=function(n,t){return o[n]||(o[n]=void 0!==t?t:{})})("versions",[]).push({version:e.version,mode:i("O4g8")?"pure":"global",copyright:"© 2018 Denis Pushkarev (zloirock.ru)"})},evD5:function(n,t,i){var e=i("77Pl"),l=i("SfB7"),o=i("MmMw"),a=Object.defineProperty;t.f=i("+E39")?Object.defineProperty:function(n,t,i){if(e(n),t=o(t,!0),e(i),l)try{return a(n,t,i)}catch(n){}if("get"in i||"set"in i)throw TypeError("Accessors not supported!");return"value"in i&&(n[t]=i.value),n}},exGp:function(n,t,i){"use strict";t.__esModule=!0;var e,l=i("//Fk"),o=(e=l)&&e.__esModule?e:{default:e};t.default=function(n){return function(){var t=n.apply(this,arguments);return new o.default(function(n,i){return function e(l,a){try{var r=t[l](a),p=r.value}catch(n){return void i(n)}if(!r.done)return o.default.resolve(p).then(function(n){e("next",n)},function(n){e("throw",n)});n(p)}("next")})}}},fJUb:function(n,t,i){var e=i("77Pl"),l=i("EqjI"),o=i("qARP");n.exports=function(n,t){if(e(n),l(t)&&t.constructor===n)return t;var i=o.f(n);return(0,i.resolve)(t),i.promise}},fbjH:function(n,t){n.exports='<h2 id="-">连接池</h2>\n<h4 id="-">概念：</h4>\n<p>数据库连接池在初始化时，创建一定数量的数据库连接放到连接池中，不管连接是否使用，连接池都保证拥有一定数量的连接数，当应用请求连接数量大于连接池数量时，则请求会被加入等待队列中。</p>\n<h4 id="-">基本思想：</h4>\n<p>系统初始化时，将数据库连接作为对象存储在内存中，当用户需要访问数据库时，并非建立新的连接，而是从池中取出一个已经建立的空闲连接对象。使用完毕后，并非关闭连接，而是把连接放回池中。连接的建立，断开都是连接池自身来管理，连接池可以设置初始连接数、上下限每个连接的最大使用次数，最大空闲时间。也可以管理监视数据库连接的的数量、使用情况。</p>\n<h4 id="-">注意：</h4>\n<ul>\n<li>最小连接数是连接池一直保持的连接数</li>\n<li>连接最大数是可以访问数据库的最大连接数，超过将等待</li>\n<li>最大连接数要不断测试，取平衡值</li>\n</ul>\n'},fkB2:function(n,t,i){var e=i("UuGF"),l=Math.max,o=Math.min;n.exports=function(n,t){return(n=e(n))<0?l(n+t,0):o(n,t)}},fyb8:function(n,t){n.exports='<h4 id="java-">Java基础</h4>\n<h4 id="-">静态导入</h4>\n<pre><code>import static java.lang.System.out;\nimport java.util.Arrays.*;\npublic class demo3 {\n    public static void main(String[] args) {\n        out.println(&quot;22&quot;);\n    }\n}</code></pre><h4 id="-">拆箱装箱</h4>\n<ul>\n<li><p>装箱：基本类型包装成对象</p>\n</li>\n<li><p>拆箱：包装类对象直接赋给基本类型</p>\n<pre><code>  public static void main(String[] args) {\n      // 典型应用\n      List list=new ArrayList();\n      list.add(1);   //装箱，1是对象Integer \n      list.add(2);   //装箱，2是对象Integer\n\n      Iterator it = list.iterator();\n      while(it.hasNext()){\n          int k = (Integer)it.next(); //拆箱\n          System.out.println(k);\n      }\n\n  }\n}</code></pre><h4 id="-for-">增强for循环</h4>\n<p>```\npackage com.itcast.eclipse;</p>\n</li>\n</ul>\n<p>import org.junit.Test;</p>\n<p>import java.util.LinkedHashMap;\nimport java.util.Map;</p>\n<p>//增强for\npublic class demo5 {\n    public static void main(String[] args) {\n        int arr[] = {1, 2, 3};\n        for (int num : arr) {\n            System.out.println(num);\n        }\n    }</p>\n<pre><code>@Test\npublic void test() {\n    Map map = new LinkedHashMap();\n    map.put(&quot;1&quot;, &quot;aaa&quot;);\n    map.put(&quot;2&quot;, &quot;bbb&quot;);\n    for (Object obj : map.keySet()) {\n        String key = (String) obj;\n        String value = (String) map.get(key);\n        System.out.println(key + &#39;=&#39; + value);\n    }\n}\n//使用增强for循环不能改变数组的值\n@Test\npublic void test2() {\n    int arr[] = {1, 2, 3};\n    for (int i : arr) {\n        i = 10;\n    }\n    System.out.println(arr[0]); //1\n    System.out.println(arr[1]); //2\n    System.out.println(arr[2]); //3  赋值不能改变原来叔祖的\n}</code></pre><p>}</p>\n<pre><code>\n#### 可变参数</code></pre><p>public class demo6 {\n    @Test\n    public void testsum() {</p>\n<pre><code>    int arr[] = {1, 2, 3, 4, 5};\n    sum(arr);\n    //sum(1, 2, 3, 4, 5);  //这两种写法是一样的\n}\n\npublic void sum(int... nums) {\n    int sum = 0;\n    for (int i : nums) {\n        sum += i;\n    }\n    System.out.println(sum);\n}\n\n//可变参数需要注意的问题\n//public void aa(int ...num,int x){这样写不行}\n  public void aa(int x,int ...nums){\n}\n@Test\npublic void bb(){\n    List list = Arrays.asList(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);\n    System.out.println(list);\n\n    String arr[] = {&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;};\n    list = Arrays.asList(arr);\n    System.out.println(list);\n\n    int nums[] = {1,2,3,4};  //這個細節yi&#39;ding\n    list = Arrays.asList(nums);\n    System.out.println(list);\n}</code></pre><p>}</p>\n<pre><code>#### 枚举\n##### 枚举类具有以下特性\n* 特殊的java类\n* 每一个枚举值代表一个实例\n* 可以在枚举类声明方法属性，构造函数必须为私有，因为每个枚举值都是在内部声明实例化的\n* 枚举类也可以实现接口，继承抽象类\n* \n##### 为什么需要枚举？\n###### 一些方法运行，需要的数据是一定范围的。\nenum关键字用于定义一个枚举类</code></pre><p>package com.itcast.eclipse;</p>\n<p>import org.junit.Test;</p>\n<p>//抽象方法枚舉\npublic class demo8 {\n    @Test\n    public void test() {\n        print(Grade1.B);\n    }\n    public void print(Grade1 g) {  //A B C\n        System.out.println(g.getValue());\n        System.out.println(g.localValue());\n    }\n}\n//enum Grade {\n//    A, B, C\n//}\n//如何定义枚举的构造构造方法，函数\nenum Grade1{\n    A(&quot;100-90&quot;){\n        public String localValue(){\n            return &quot;优&quot;;\n        }\n    },B(&quot;90-80&quot;){\n        public String localValue(){\n            return &quot;良好&quot;;\n        }\n    };\n    private String value;\n    private  Grade1(String value){\n        this.value=value;\n    }\n    public String getValue(){\n        return this.value;\n    }\n    public abstract String localValue();\n}\n```</p>\n<h3 id="-">反射</h3>\n<ul>\n<li>一个类有多个组成部分，例如成员变量、方法、构造方法。反射就是加载类，并把类解剖出来。<h5 id="-">加载类</h5>\n</li>\n<li>Java 中有一个类用于代表某一个类的字节码。</li>\n<li>forName();</li>\n</ul>\n'},h65t:function(n,t,i){var e=i("UuGF"),l=i("52gC");n.exports=function(n){return function(t,i){var o,a,r=String(l(t)),p=e(i),s=r.length;return p<0||p>=s?n?"":void 0:(o=r.charCodeAt(p))<55296||o>56319||p+1===s||(a=r.charCodeAt(p+1))<56320||a>57343?n?r.charAt(p):o:n?r.slice(p,p+2):a-56320+(o-55296<<10)+65536}}},hJx8:function(n,t,i){var e=i("evD5"),l=i("X8DO");n.exports=i("+E39")?function(n,t,i){return e.f(n,t,l(1,i))}:function(n,t,i){return n[t]=i,n}},iUbK:function(n,t,i){var e=i("7KvD").navigator;n.exports=e&&e.userAgent||""},ieyX:function(n,t){n.exports='<h4 id="-">应用层</h4>\n<h5 id="-">概念</h5>\n<p>位于计算机网络体系结构的最上层，前面四层做的所有事情就是为了他服务，是设计和建立计算机网络的最终目的，通俗的讲，就是开发的应用软件，就处于这一层，比如，QQ，浏览器访问网页，等等应用软件都是在这一层，但是这些软件在运行的过程中，也需要依靠一些特定的协议才能完成相应的功能，比如浏览器通过网址访问网页。</p>\n<h5 id="-p2p-">应用层中的应用软件分两种：客户/服务器和P2P体系结构</h5>\n<ul>\n<li>客户/服务器(client/server)\n客户端，服务器模型，客户端请求服务器，服务器响应客户端这样的一种方式进行“交流”</li>\n<li>P2P\n也称为对等体系结构。P2P相当于每个人的电脑都可以当服务器，也可以当客户端，不单单限制于只能客户端访问服务器，你自己的计算机可以去访问别人的计算机上的内容，别的同样可以访问你计算机上的内容，这样达到一种共享的状态。</li>\n</ul>\n<h5 id="-">应用层协议的举例</h5>\n<ul>\n<li>DNS协议Domain Name System 域名系统。也可以叫做域名解析协议。</li>\n<li>DNS协议工作原理<ul>\n<li>通过域名访问网页</li>\n<li>计算机会先将域名发送到一个解析域名的服务器上，在其服务器上有很多服务器，能解析各种各样的域名，比如有专门解析.org的，解析.com的，解析.net的。等等，最主要的有一个根域名服务器，域名解析(在服务器上查找IP地址)的过程有两种算法，迭代查询，递归查询。一般是两种查询的结合。</li>\n<li>本机计算机找到其中一台解析域名的服务器(可能是.com)，如果没有找到对应的IP地址，那么就会去找根域名服务器，根域名服务器知道所有的子服务器，所以他肯定知道该域名所对应的IP地址在那个子服务器中，所以告诉第一次查询的服务器要他去另一台服务器上找，找到了，就将其返回给计算机，以后在有另一台计算机也通过这个域名访问，那么第一台服务器会有原来的域名IP地址的缓存，就不用去找根服务器了。</li>\n<li>找到了，就能找到我们要访问的服务器了。</li>\n</ul>\n</li>\n</ul>\n<h5 id="-http">超文本传送协议HTTP</h5>\n<p>作用：怎样向服务器请求文档、服务器怎么把文档传送给浏览器。</p>\n<p>URL:统一资源定位符定位资源在服务器上的位置。</p>\n<ul>\n<li>格式：&lt;协议&gt;://&lt;主机&gt;:&lt;端口&gt;/&lt;路径&gt;</li>\n<li>协议：http</li>\n<li>主机：域名/IP地址</li>\n<li>端口: 在传输层需要使用的，访问目的主机的哪个端口号。　</li>\n<li>路径：精准的定位我们所需要的资源位置</li>\n</ul>\n'},"jKW+":function(n,t,i){"use strict";var e=i("kM2E"),l=i("qARP"),o=i("dNDb");e(e.S,"Promise",{try:function(n){var t=l.f(this),i=o(n);return(i.e?t.reject:t.resolve)(i.v),t.promise}})},jVyS:function(n,t){n.exports='<h4 id="-">物理层</h4>\n<h5 id="-">概念</h5>\n<ul>\n<li>传输的数据是通过何种方式，以什么形态传输的</li>\n<li>确定与传输媒体的接口的一些特性，即 机械特性、电气特性、功能特性、过程特性　　　　<ul>\n<li>机械特性：接口形状、大小、引线数量等，通俗讲也就是网线的水晶头的设计等一些规定</li>\n<li>电气特性：规定电压范围（-5V~+5V）等在网线中传输时所用的电压范围。</li>\n<li>功能特性：例 规定-5V代表0 +5V代表1，用电压的大小来表示 0 和 1</li>\n<li>过程特性：也称规程特性，规定建立连接时各个相关部件的工作步骤。</li>\n</ul>\n</li>\n</ul>\n<h5 id="-">数据通信的基础知识</h5>\n<ul>\n<li>数据通信模型 </li>\n</ul>\n<p>源点、发送器、接受器、终点和  源系统、传输系统、目的系统 的对应关系。</p>\n<p>PC机要发的数据会转换为010101，数字比特流就代表着010101传给调制解调器，调制解调器将数字比特流转换为模拟信号，通过公用电话网传到很远的目的地去。然后逆过来解析成原数据就行了。</p>\n<h5 id="-">术语</h5>\n<ul>\n<li>通信的目的是传输信息</li>\n<li>数据：运送数据的实体</li>\n<li>信号：数据的表现形式，例如电磁或者电气</li>\n<li>数字信号：代表消息的参数的取值是离散的，不连续。</li>\n<li>模拟信号：代表信息的参数的取值是连续的，有高有低，是连续的波。</li>\n<li>码元：在使用时间域的波形表示数字信号时，则代表不同离散数值的基本波形就成为码元。在数字信号中，带着0或者1的波形就是一个码元。</li>\n<li>码元长度：每一个码元都是通过一段时间间隔来表示，这个时间间隔就是码元长度。\n注意：1码元可以携带nbit（位）的信息量，并不是1码元就只能代表1bit的信息量，可以是nbit，也就是说上面1码元就代表0或1这样1bit的信息量。</li>\n</ul>\n<h5 id="-">信道和传输方式</h5>\n<ul>\n<li>信道：一般表示向一个方向传送信息的媒体，所以平常说的通信线路往往包含一条发送信息的信道和一条接受信息的信道</li>\n<li>单工通信：也就是单向通信，只能有一个方向的通信而没有反方向的交互</li>\n<li>半双工通信：也就是能双向通信，但是不能同时通信，一方在发送数据，另一方必须接受数据，等待对方发完，然后自己才能发。</li>\n<li>全双工通信：相对于半双工通信来讲，就是能同时通信且双向，例如，电话。</li>\n</ul>\n<h5 id="-">基带信号和带通信号</h5>\n<ul>\n<li>基带信号：即基本频带信号，来自信源的信号，像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号，基带信号就是发出的直接表达了要传输的信息的信号，\n例如，我们说话的声波就是基带信号</li>\n<li>带通信号：把基带信号经过载波调制后，把信号的频率范围移到较高的频段以便在信道中传输</li>\n</ul>\n<h5 id="-">编码和调制</h5>\n<p>编码：人们将<strong>数字数</strong>据转换为<strong>数字信号</strong>的过程称为<strong>编码</strong>\n调制：将<strong>数字数据</strong>转换为<strong>模拟信号</strong>的过程称为<strong>调制</strong>\n编码方式</p>\n<ul>\n<li>单级性不归零码：只使用一个电压值，用高电压表示1，没电压表示0</li>\n<li>双极性不归零码：用正电平和负电平分别表示二进制数据的1和0，正负幅值相等</li>\n<li>单极性归零码：单极性归零码（RZ）即是以高电平和零电平分别表示二进制码1和0，而且在发送码1时高电平在整个码元期间T只持续一段时间τ，其余时间返回零电平</li>\n<li>双极性归零码：正负零三个电平，信号本身携带同步信息</li>\n</ul>\n<ul>\n<li>曼彻斯特编码：由高变低为1、由低变高为0 它可以表示没有数据传输的状态。</li>\n<li>差分曼彻斯特编码：bit与bit之间有信号变化(不管是从高变低还是低变高)为0，没信号变化为1. 优点：和曼彻斯特编码一样，但是抗干扰性强于曼彻斯特编码</li>\n</ul>\n<h5 id="-">调制方式</h5>\n<ul>\n<li>调幅：载波的振幅随基带数字信号而变化</li>\n<li>调频：载波的频率随基带数字信号而变化</li>\n<li>调相：载波的初始相位随基带数字信号而变化</li>\n</ul>\n<h5 id="-">信道极限容量：</h5>\n<p>就是在信道中传输信号时，会有杂质干扰，所以有一个信道极限容量来衡量在信道中最多的容量为多少时，能抵御干扰，正确的到达目的。</p>\n<h5 id="-">奈氏准则</h5>\n<p>在假定的条件下，为了避免码(码元)间串扰，码元的传输速率的上限值\n注意：Baud(波特) 和 Bit 的区别\nBaud：码元传输的速率单位 码元传输速率 也称为调制速率，波形速率或符号速率\n1Baud  = 1 码元/秒 = n Bit/s 就是这个关系。</p>\n<h5 id="-">在排除外界干扰的情况下，为什么码元传输速率还有上限值？</h5>\n<p>分析：如果速率没有上限值，则接收器在速率太高的情况下，来不及分别信号的强弱，这样就不能清楚的分析出01010了。就好比，一个人说话很快很快，你的听力分析能力跟不上人家说的话，就导致无法听清别人说的话，如果说的比较慢，我们就有时间来分析人家说的是什么，就是这个意思。</p>\n<h5 id="-">信噪比和香农公式</h5>\n<ul>\n<li>信噪比： S/N  </li>\n<li>S：信道内所传信号的平均功率；N为信道内部的高斯噪声功率。</li>\n<li>香农公式： C = W log2 (1+S/N) bit/s</li>\n<li>C：信道的极限信息传输速率； W：信道的宽带</li>\n<li>香农公式表明：<ul>\n<li>信道的带宽(W)或信道中的信噪比越大(S/N)，则信息的极限传输速率就越高。</li>\n<li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输</li>\n<li>若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。</li>\n<li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 </li>\n<li><h5 id="-">物理层传输媒体</h5>\n</li>\n</ul>\n</li>\n<li>导向传输媒体</li>\n<li>非导向传输媒体</li>\n</ul>\n<h5 id="-">导向传输媒体</h5>\n<ul>\n<li>双绞线<ul>\n<li>屏蔽双绞线STP</li>\n<li>无屏蔽双绞线UTP</li>\n</ul>\n</li>\n</ul>\n<h5 id="-">同轴电缆</h5>\n<ul>\n<li>50Ω同轴电缆，用于数字传输，由于多用于基带传输，也叫基带同轴电缆</li>\n<li>75Ω同轴电缆，用于模拟传输，即宽带同轴电缆\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/23.png?raw=true" alt="image">  \n　</li>\n</ul>\n<p>网线：直通线和交叉线</p>\n<ul>\n<li>直通线：具体的线序制作方法是：双绞线夹线顺序是两边一致，统一都是：1：白橙、2：橙、3：白绿、4：蓝、5：白蓝、6：绿、7：白棕、8：棕。\n注意两端都是同样的线,序且一一对应。这就是100M网线的做线标准，即568B标准，也就是我们平常所说的正线或标准线、直通线,直通线应用最广泛，这种类型的以太网电缆用来实现下列连接:<ul>\n<li>主机到交换机或集线器</li>\n<li>路由器到交换机或集线器</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p>交叉线：就相当于直通线是一一对应，而交叉线就不一样，1对3,2对4等。</p>\n</li>\n<li><p>光缆(光纤)</p>\n</li>\n</ul>\n<p>工作原理：就是通过<strong>光的折射</strong>，在里面传播，直到光出来。</p>\n<ul>\n<li>光纤分多模光纤和单模光纤\n区别：单模光纤指只能传输一种电磁波模式，多模光纤只可以传输多个电磁波模式，实际上单模光纤和多模光纤之分，也就是纤芯的直径之分。单模光纤细，多模光纤粗。在有线电视网络中使用的光纤全是单模光纤，其传播特性好，带宽可达10GHZ，可以在一根光纤中传输60套PAL—D电视节目。</li>\n</ul>\n<h5 id="-">非导向传输媒体</h5>\n<p>非导向传输媒体就是指自由空间，其中的电磁波传输被称为无线传输。通俗来讲，就是通过无线，不用那种固态的媒体，在空气中自由传播，在空气中传播的波很多，如何分别呢，就是通过每个波的频率不一样，</p>\n<h3 id="-">信道复用技术</h3>\n<p>复用：公用一条信道来进行传输信息。</p>\n<h4 id="-">四种信道复用技术</h4>\n<ul>\n<li><p>频分复用</p>\n</li>\n<li><p>时分复用</p>\n</li>\n<li><p>统计时分复用</p>\n</li>\n<li><p>波分复用</p>\n<ul>\n<li>频分复用：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带，所有用户在同样的时间占用不同的带宽资源（请注意，这里的“带宽”是频率带宽而不是数据的发送速率）。</li>\n<li>具体分析<ul>\n<li>发数据</li>\n<li>接受数据</li>\n</ul>\n</li>\n<li>时分复用\n按时间轮流分配带宽资源给不同的用户，每个用户只在分配的时间里使用线路传输数据。通俗来讲：就是每个用户都有自己的时间段来传输数据，没到自己时间就需要等待，直到属于自己的传输时间段的到来，周期性的周转。\n特点：在信道中，每个资源都有先后顺序，并且不会乱，一直是按照一定的顺序传输数据。 \n缺点：计算机数据的突发性质，用户对分配的子信道的利用率不高，因为不知道什么时候通道就会发送数据，可能别的通道都不发数据，就一个通道需要发送，但也还是要等待一定的时间，即使信道是空的。</li>\n<li>统计时分复用，是对时分复用的一种改进，它能完善时分复用是对信道的利用率不高这个缺点，\n原理：就是在每个要发送的数据上面做一个特殊的标记，而不是通过一个多路复用器，周期性的发送数据，给每个要发送的数据放入STDM帧中，让STDM帧带着数据发送过去，而接受的话，只需要分析STDM帧就行了。 注意：时分复用 又称同步时分复用，统计十分复用 称为异布时分复用。因为某一个用户所占用的时间间隙并不是周期性的出现</li>\n<li>波分复用，光的频分复用。</li>\n</ul>\n</li>\n</ul>\n<h4 id="-">数字传输系统</h4>\n<p>PCM(脉冲编码调制)技术：将模拟电话信号转换为数字信号的一种技术。<br>有两种PCM技术：北美的24路PCM(T1)  1.544M/s、 欧洲的30路PCM(E1) 我国采用的是E1 2.048M/S</p>\n<h4 id="-">宽带接入技术</h4>\n<ul>\n<li>电话网拨号接入　\n这是老式的拨号联网方式，因为速度最高只能达到56kb/s。\n工作原理：通过将计算机发出的信号转换为音频信号，因为要通过电话网线来传播数据，所以* 数字用户线接入　<ul>\n<li>DSL：数字用户线  　</li>\n<li>xDSL：用数字技术对现有的模拟电话用户线进行改造，在DSL上加了x表示不同的数字用户线技术。\n工作原理：xDSL 技术就把 0~4 kHz低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。这样一来，就互不干扰了。通过频率的高低来区分是电话还是网络数据。</li>\n</ul>\n</li>\n</ul>\n<h4 id="-hfc">光纤同轴混合网接入HFC</h4>\n<p>CATV：树形拓扑结构的同轴电缆网络，采用模拟技术的频分复用对电视节目的单向传输，HFC对CATV的基础上进行改造，从而开发出的一种居民宽带接入网。\n特点：</p>\n<ul>\n<li>HFC网的主干线路采用光纤，将原CATV网中的同轴电缆主干部分该换位光纤，并且使用的是模拟光纤技术</li>\n<li>每个家庭都要安装一个用户接口盒</li>\n<li>HFC 网具有比 CATV 网更宽的频谱，且具有双向传输功能</li>\n</ul>\n<h4 id="-">光纤接入　　　　　　　　</h4>\n<p>FTTx（光纤到...）：实现宽带居民接入网的方案，这里字母x可代表不同的意思</p>\n<ul>\n<li>FTTH：光纤到家，光纤一直铺设到用户家庭可能是居民接入网最后的解决方法(155Mb/s)</li>\n<li>FTTB：光纤到大楼，光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。</li>\n<li>FTTC：从路边到各用户可使用星形结构双绞线作为传输媒体(155Mb/s)</li>\n</ul>\n<h4 id="-">以太网接入</h4>\n<p>局域网，大学校园、大型企业、各种政府通过内部的局域网，然后再让局域网接入到因特网。</p>\n<h4 id="-">无线接入</h4>\n<ul>\n<li>1G：蜂窝移动通信只能够模拟话音通信，跟那个电话网拨号接入类似，网速很慢很慢</li>\n<li>2G：以数字话音通信为主，也能提供短信，收发邮件，浏览网页的数据通信功能</li>\n<li>3G：3G时代，记得以前用的网页版QQ</li>\n<li>4G：网速很快，能达到1M~2M之间的速度。</li>\n</ul>\n'},jyFz:function(n,t,i){var e=function(){return this}()||Function("return this")(),l=e.regeneratorRuntime&&Object.getOwnPropertyNames(e).indexOf("regeneratorRuntime")>=0,o=l&&e.regeneratorRuntime;if(e.regeneratorRuntime=void 0,n.exports=i("SldL"),l)e.regeneratorRuntime=o;else try{delete e.regeneratorRuntime}catch(n){e.regeneratorRuntime=void 0}},kM2E:function(n,t,i){var e=i("7KvD"),l=i("FeBl"),o=i("+ZMJ"),a=i("hJx8"),r=i("D2L2"),p=function(n,t,i){var s,c,u,h=n&p.F,d=n&p.G,g=n&p.S,m=n&p.P,v=n&p.B,f=n&p.W,b=d?l:l[t]||(l[t]={}),S=b.prototype,y=d?e:g?e[t]:(e[t]||{}).prototype;for(s in d&&(i=t),i)(c=!h&&y&&void 0!==y[s])&&r(b,s)||(u=c?y[s]:i[s],b[s]=d&&"function"!=typeof y[s]?i[s]:v&&c?o(u,e):f&&y[s]==u?function(n){var t=function(t,i,e){if(this instanceof n){switch(arguments.length){case 0:return new n;case 1:return new n(t);case 2:return new n(t,i)}return new n(t,i,e)}return n.apply(this,arguments)};return t.prototype=n.prototype,t}(u):m&&"function"==typeof u?o(Function.call,u):u,m&&((b.virtual||(b.virtual={}))[s]=u,n&p.R&&S&&!S[s]&&a(S,s,u)))};p.F=1,p.G=2,p.S=4,p.P=8,p.B=16,p.W=32,p.U=64,p.R=128,n.exports=p},kaAU:function(n,t){n.exports='<h2 id="springboot-">SpringBoot注解</h2>\n<ul>\n<li>@SpringBootApplication：包含了@ComponentScan、@Configuration和@EnableAutoConfiguration注解。其中@ComponentScan让spring Boot扫描到Configuration类并把它加入到程序上下文。</li>\n<li>@Configuration 等同于spring的XML配置文件；使用Java代码可以检查类型安全</li>\n<li>@EnableAutoConfiguration 自动配置</li>\n<li>@ComponentScan 组件扫描，可自动发现和装配一些Bean</li>\n<li>@Component可配合CommandLineRunner使用，在程序启动后执行一些基础任务</li>\n<li>@RestController注解是@Controller和@ResponseBody的合集,表示这是个控制器bean,并且是将函数的返回值直接填入HTTP响应体中,是REST风格的控制器</li>\n<li>@Autowired自动导入</li>\n<li>@PathVariable获取参数</li>\n<li>@JsonBackReference解决嵌套外链问题</li>\n<li>@RepositoryRestResourcepublic配合spring-boot-starter-data-rest使用</li>\n<li>@ResponseBody:表示该方法的返回结果直接写入HTTP response body中，一般在异步获取数据时使用，用于构建RESTful的api。在使用@RequestMapping后，返回值通常解析为跳转路径，加上@responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP response body中。比如异步获取json数据，加上@responsebody后，会直接返回json数据。该注解一般会配合@RequestMapping一起使用</li>\n<li>@Controller：用于定义控制器类，在spring 项目中由控制器负责将用户发来的URL请求转发到对应的服务接口（service层），一般这个注解在类中，通常方法需要配合注解@RequestMapping。</li>\n<li>@RestController：用于标注控制层组件(如struts中的action)，@ResponseBody和@Controller的合集</li>\n<li>@RequestMapping：提供路由信息，负责URL到Controller中的具体函数的映射</li>\n<li>@EnableAutoConfiguration：Spring Boot自动配置（auto-configuration）：尝试根据你添加的jar依赖自动配置你的Spring应用。例如，如果你的classpath下存在HSQLDB，并且你没有手动配置任何数据库连接beans，那么我们将自动配置一个内存型（in-memory）数据库”。你可以将@EnableAutoConfiguration或者@SpringBootApplication注解添加到一个@Configuration类上来选择自动配置。如果发现应用了你不想要的特定自动配置类，你可以使用@EnableAutoConfiguration注解的排除属性来禁用它们。</li>\n<li>@ComponentScan：表示将该类自动发现扫描组件。个人理解相当于，如果扫描到有@Component、@Controller、@Service等这些注解的类，并注册为Bean，可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。可以自动收集所有的Spring组件，包括@Configuration类。我们经常使用@ComponentScan注解搜索beans，并结合@Autowired注解导入。如果没有配置的话，Spring Boot会扫描启动类所在包下以及子包下的使用了@Service,@Repository等注解的类</li>\n<li>@Configuration：相当于传统的xml配置文件，如果有些第三方库需要用到xml文件，建议仍然通过@Configuration类作为项目的配置主类——可以使用@ImportResource注解加载xml配置文件。</li>\n<li>@Import：用来导入其他配置类</li>\n<li>@ImportResource：用来加载xml配置文件</li>\n<li>@Autowired：自动导入依赖的bean</li>\n<li>@Service：一般用于修饰service层的组件</li>\n<li>@Repository：使用@Repository注解可以确保DAO或者repositories提供异常转译，这个注解修饰的DAO或者repositories类会被ComponetScan发现并配置，同时也不需要为它们提供XML配置项。</li>\n<li>@Bean：用@Bean标注方法等价于XML中配置的bean。</li>\n<li>@Value：注入Spring boot application.properties配置的属性的值</li>\n<li>JPA:Java Persistence API,是一组用于将数据存入数据库的类和方法的集合</li>\n<li>@Entity：@Table(name=”“)：表明这是一个实体类。一般用于jpa这两个注解一般一块使用，但是如果表名和实体类名相同的话，@Table可以省略</li>\n<li>@MappedSuperClass:用在确定是父类的entity上。父类的属性子类可以继承。</li>\n<li>@NoRepositoryBean:一般用作父类的repository，有这个注解，spring不会去实例化该repository。</li>\n<li>@Column：如果字段名与列名相同，则可以省略。</li>\n<li>@Id：表示该属性为主键。</li>\n<li>@GeneratedValue(strategy = GenerationType.SEQUENCE,generator = “repair_seq”)：表示主键生成策略是sequence（可以为Auto、IDENTITY、native等，Auto表示可在多个数据库间切换），指定sequence的名字是repair_seq。</li>\n<li>@SequenceGeneretor(name = “repair_seq”, sequenceName = “seq_repair”, allocationSize = 1)：name为sequence的名称，以便使用，sequenceName为数据库的sequence名称，两个名称可以一致。</li>\n<li>@Transient：表示该属性并非一个到数据库表的字段的映射,ORM框架将忽略该属性。如果一个属性并非数据库表的字段映射,就务必将其标示为@Transient,否则,ORM框架默认其注解为@Basic。@Basic(fetch=FetchType.LAZY)：标记可以指定实体属性的加载方式</li>\n<li>@JsonIgnore：作用是json序列化时将Java bean中的一些属性忽略掉,序列化和反序列化都受影响。</li>\n<li>@JoinColumn（name=”loginId”）:一对一：本表中指向另一个表的外键。一对多：另一个表指向本表的外键。</li>\n<li>@OneToOne、@OneToMany、@ManyToOne：对应hibernate配置文件中的一对一，一对多，多对一。</li>\n<li>@RequestMapping：@RequestMapping(“/path”)表示该控制器处理所有“/path”的UR L请求。RequestMapping是一个用来处理请求地址映射的注解，可用于类或方法上。 \n用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。该注解有六个属性： <ul>\n<li>params:指定request中必须包含某些参数值是，才让该方法处理。 </li>\n<li>headers:指定request中必须包含某些指定的header值，才能让该方法处理请求。 </li>\n<li>value:指定请求的实际地址，指定的地址可以是URI Template 模式 </li>\n<li>method:指定请求的method类型， GET、POST、PUT、DELETE等 </li>\n<li>consumes:指定处理请求的提交内容类型（Content-Type），如application/json,text/html; </li>\n<li>produces:指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回</li>\n</ul>\n</li>\n</ul>\n'},knuC:function(n,t){n.exports=function(n,t,i){var e=void 0===i;switch(t.length){case 0:return e?n():n.call(i);case 1:return e?n(t[0]):n.call(i,t[0]);case 2:return e?n(t[0],t[1]):n.call(i,t[0],t[1]);case 3:return e?n(t[0],t[1],t[2]):n.call(i,t[0],t[1],t[2]);case 4:return e?n(t[0],t[1],t[2],t[3]):n.call(i,t[0],t[1],t[2],t[3])}return n.apply(i,t)}},kxdT:function(n,t){n.exports='<h4 id="js-execution-context-">JS Execution Context 执行上下文</h4>\n<p>执行上下文是一个比喻的词，用于描述Javascript代码运行的环境。</p>\n<h5 id="-">相关概念：</h5>\n<ul>\n<li>Js引擎(JS Engine)</li>\n<li>全局存储器(Global Memory)：全局作用域或全局变量环境</li>\n<li>调用栈（call stack)</li>\n<li>全局上下文(Global Context)</li>\n<li>局部上下文(Local Execution Context)</li>\n</ul>\n<h5 id="-javascript-">主流Javascript引擎</h5>\n<ul>\n<li>Google V8：V8是Google开源的Javascript引擎，在Google Chrome和Nodejs中使用</li>\n<li>SpiderMonkey：SpiderMonkey是Mozilla的JavaScript引擎，用于Firefox</li>\n</ul>\n<h5 id="-">调用栈</h5>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/7.png?raw=true" alt="image">   </p>\n<ul>\n<li>调用栈是一个数据结构：堆栈。</li>\n<li>调用栈有两种方法：运行函数push进栈和函数执行完毕pop出栈。</li>\n<li>每个函数调用都被push到调用栈中。push的第一件事是main()（或global()），它是Javascript程序执行的主要线程。</li>\n</ul>\n<h5 id="-">局部上下文</h5>\n<p>在全局上下文执行某个函数，会在全局作用域（全局存储器）声明一个变量var res，初始值为undefined等待函数的返回保存局部变量，同时也会生成一个局部上下文。</p>\n<h5 id="-">执行规则：</h5>\n<ul>\n<li>JavaScript引擎创建执行上下文、全局存储器和调用栈，变量提升，实际上变量和函数声明在代码里的位置是不会动的，而是在编译阶段被放入内存中。一旦调用函数，就是创建一个局部上下文</li>\n<li>当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。处于活动状态的执行上下文环境只有一个。</li>\n</ul>\n<h6 id="-">特别注意：</h6>\n<ul>\n<li>变量提升，一般变量会用undefined占空，函数是会赋值的。</li>\n<li>函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域，在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。<pre><code>console.log(a) //undefined\nvar a =2;  \nconsole.log(fun);//ƒ (){}//输出变量的值\nvar fun = function(){};</code></pre></li>\n</ul>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/3.png?raw=true" alt="image"><br><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/4.png?raw=true" alt="image"><br><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/5.png?raw=true" alt="image"><br><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/js/6.png?raw=true" alt="image">  </p>\n'},lOnJ:function(n,t){n.exports=function(n){if("function"!=typeof n)throw TypeError(n+" is not a function!");return n}},lktj:function(n,t,i){var e=i("Ibhu"),l=i("xnc9");n.exports=Object.keys||function(n){return e(n,l)}},meAt:function(n,t){n.exports='<h4 id="-">元素居中</h4>\n<h5 id="-">水平居中</h5>\n<ul>\n<li><p>行内元素: text-align: center</p>\n</li>\n<li><p>块级元素: margin: 0 auto</p>\n</li>\n<li><p>absolute + transform</p>\n</li>\n<li><p>flex + justify-content: center</p>\n</li>\n<li><h5 id="-">垂直居中</h5>\n</li>\n<li><p>line-height:height(移动端会有1-2像素差)</p>\n</li>\n<li><p>absolute + transform</p>\n</li>\n<li><p>flex + align-items: center</p>\n</li>\n<li><p>table</p>\n</li>\n</ul>\n<h5 id="-">水平垂直居中</h5>\n<ul>\n<li>absolute + transform</li>\n<li>flex + justify-content + align-items（space-evenly有兼容性问题）</li>\n</ul>\n'},msXi:function(n,t,i){var e=i("77Pl");n.exports=function(n,t,i,l){try{return l?t(e(i)[0],i[1]):t(i)}catch(t){var o=n.return;throw void 0!==o&&e(o.call(n)),t}}},nM7a:function(n,t){n.exports='<h2 id="java-">Java单态设计模式核心</h2>\n<ul>\n<li>采取一定的方法保证在整个软件系统中,对某个类只能产生一个对象实例,并且该类只提供一个取得其对象的实例方法.</li>\n<li>在类的内部把构造器私有化,同时在内部产生对象,并通过类.静态方法(static)返回实例化对象的引用</li>\n</ul>\n<h4 id="-">设计模式</h4>\n<p>设计模式是在大量的实践总结和理论化之后优选的代码结果,编程风格,以及解决问题的思考方式.设计模式就像是经典的棋谱,不同的棋局我们用不同的棋谱.</p>\n<h4 id="-java-">在java中实现单态模式只需要执行以下三步：</h4>\n<ol>\n<li>将类的构造方法的访问权限声明为private.这样就不能用new操作符在类的外部产生类的对象了,但在类内部仍可以产生该类的对象</li>\n<li>在类内部生成一个静态的实例</li>\n<li>提供一个静态的方法用于外部取得该类的实例.\n因为在类的外部无法得到类的对象,所以只能调用该类的某个静态方法以返回类内部创建的对象,又因为静态方法只能访问类中的静态成员变量,所以,指向类内部产生该类对象的变量也必须定义成静态的.<pre><code>class Chinese{\n static Chinese objRef = new Chinese();\n private Chinese(){}\n public static Chinese getInstance(){\n     return objRef;\n }\n}\nclass Chinese_opt{\n static Chinese_opt objRef = null;\n private Chinese_opt(){}\n public static Chinese_opt getInstance(){\n     if(objRef == null)\n         objRef = new Chinese_opt();\n     return objRef;\n }\n}\nclass TestChinese{\n public static void main(String[] args){\n     Chinese chinese1 = Chinese.getInstance();\n     Chinese chinese2 = Chinese.getInstance();\n     System.out.println(chinese1 == chinese2);\n }\n}</code></pre><h4 id="-">单态设计模式的意义</h4>\n</li>\n</ol>\n<p>实际上这种模式非常常用，我们大家使用的windows操作系统中就使用了此设计模式，windows中用一个回车站： ，除了桌面以外，其他的每个硬盘中都有一个回车站，其他的回车站和其他硬盘的每个回车站都是同一个，也就是所整个操作系统中有且只有一个回车站，各个地方只是引用此实例。</p>\n<h4 id="-">总结</h4>\n<p>单态设计模式的核心就是将类的构造函数私有化，在类的内部产生实例对象，并通过类的静态方法返回类的实例对象。</p>\n<h2 id="ioc-inversion-of-control-">Ioc—Inversion of Control 控制反转设计模式</h2>\n<ul>\n<li>谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）</li>\n<li>为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了</li>\n</ul>\n<h4 id="ioc-">IOC作用</h4>\n<ul>\n<li>IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了</li>\n<li>IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找</li>\n</ul>\n'},noGn:function(n,t){n.exports='<h4 id="java-">Java反射机制</h4>\n<pre><code>package com;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.TypeVariable;\n\npublic class Main {\n    /**\n     * 为了看清楚Java反射部分代码，所有异常我都最后抛出来给虚拟机处理！\n     * @param args\n     * @throws ClassNotFoundException\n     * @throws InstantiationException\n     * @throws IllegalAccessException\n     * @throws InvocationTargetException\n     * @throws IllegalArgumentException\n     * @throws NoSuchFieldException\n     * @throws SecurityException\n     * @throws NoSuchMethodException\n     */\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, SecurityException, NoSuchFieldException, NoSuchMethodException {\n        // TODO Auto-generated method stub\n\n        //Demo1.  通过Java反射机制得到类的包名和类名\n        Demo1();\n        System.out.println(&quot;===============================================&quot;);\n\n        //Demo2.  验证所有的类都是Class类的实例对象\n        Demo2();\n        System.out.println(&quot;===============================================&quot;);\n\n        //Demo3.  通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]，无参构造\n        Demo3();\n        System.out.println(&quot;===============================================&quot;);\n\n        //Demo4:  通过Java反射机制得到一个类的构造函数，并实现构造带参实例对象\n        Demo4();\n        System.out.println(&quot;===============================================&quot;);\n\n        //Demo5:  通过Java反射机制操作成员变量, set 和 get\n        Demo5();\n        System.out.println(&quot;===============================================&quot;);\n\n        //Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等\n        Demo6();\n        System.out.println(&quot;===============================================&quot;);\n\n        //Demo7: 通过Java反射机制调用类中方法\n        Demo7();\n        System.out.println(&quot;===============================================&quot;);\n\n        //Demo8: 通过Java反射机制获得类加载器\n        Demo8();\n        System.out.println(&quot;===============================================&quot;);\n\n    }\n\n    /**\n     * Demo1: 通过Java反射机制得到类的包名和类名\n     */\n    public static void Demo1()\n    {\n        Person person = new Person();\n        System.out.println(&quot;Demo1: 包名: &quot; + person.getClass().getPackage().getName() + &quot;，&quot;\n                + &quot;完整类名: &quot; + person.getClass().getName());\n    }\n\n    /**\n     * Demo2: 验证所有的类都是Class类的实例对象\n     * @throws ClassNotFoundException\n     */\n    public static void Demo2() throws ClassNotFoundException\n    {\n        //定义两个类型都未知的Class , 设置初值为null, 看看如何给它们赋值成Person类\n        Class&lt;?&gt; class1 = null;\n        Class&lt;?&gt; class2 = null;\n\n        //写法1, 可能抛出 ClassNotFoundException [多用这个写法]\n        class1 = Class.forName(&quot;com.Person&quot;);\n        System.out.println(&quot;Demo2:(写法1) 包名: &quot; + class1.getPackage().getName() + &quot;，&quot;\n                + &quot;完整类名: &quot; + class1.getName());\n\n        //写法2\n        class2 = Person.class;\n        System.out.println(&quot;Demo2:(写法2) 包名: &quot; + class2.getPackage().getName() + &quot;，&quot;\n                + &quot;完整类名: &quot; + class2.getName());\n    }\n\n    /**\n     * Demo3: 通过Java反射机制，用Class 创建类对象[这也就是反射存在的意义所在]\n     * @throws ClassNotFoundException\n     * @throws IllegalAccessException\n     * @throws InstantiationException\n     */\n    public static void Demo3() throws ClassNotFoundException, InstantiationException, IllegalAccessException\n    {\n        Class&lt;?&gt; class1 = null;\n        class1 = Class.forName(&quot;com.Person&quot;);\n        //由于这里不能带参数，所以你要实例化的这个类Person，一定要有无参构造函数哈～\n        Person person = (Person) class1.newInstance();\n        person.setAge(20);\n        person.setName(&quot;LeeFeng&quot;);\n        System.out.println(&quot;Demo3: &quot; + person.getName() + &quot; : &quot; + person.getAge());\n    }\n\n    /**\n     * Demo4: 通过Java反射机制得到一个类的构造函数，并实现创建带参实例对象\n     * @throws ClassNotFoundException\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws InstantiationException\n     * @throws IllegalArgumentException\n     */\n    public static void Demo4() throws ClassNotFoundException, IllegalArgumentException, InstantiationException, IllegalAccessException, InvocationTargetException\n    {\n        Class&lt;?&gt; class1 = null;\n        Person person1 = null;\n        Person person2 = null;\n\n        class1 = Class.forName(&quot;com.Person&quot;);\n        //得到一系列构造函数集合\n        Constructor&lt;?&gt;[] constructors = class1.getConstructors();\n\n        person1 = (Person) constructors[0].newInstance();\n        person1.setAge(30);\n        person1.setName(&quot;leeFeng&quot;);\n\n        person2 = (Person) constructors[1].newInstance(20,&quot;leeFeng&quot;);\n\n        System.out.println(&quot;Demo4: &quot; + person1.getName() + &quot; : &quot; + person1.getAge()\n                + &quot;  ,   &quot; + person2.getName() + &quot; : &quot; + person2.getAge()\n        );\n\n    }\n\n    /**\n     * Demo5: 通过Java反射机制操作成员变量, set 和 get\n     *\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws NoSuchFieldException\n     * @throws SecurityException\n     * @throws InstantiationException\n     * @throws ClassNotFoundException\n     */\n    public static void Demo5() throws IllegalArgumentException, IllegalAccessException, SecurityException, NoSuchFieldException, InstantiationException, ClassNotFoundException\n    {\n        Class&lt;?&gt; class1 = null;\n        class1 = Class.forName(&quot;com.Person&quot;);\n        Object obj = class1.newInstance();\n\n        Field personNameField = class1.getDeclaredField(&quot;name&quot;);\n        personNameField.setAccessible(true);\n        personNameField.set(obj, &quot;胖虎先森&quot;);\n\n\n        System.out.println(&quot;Demo5: 修改属性之后得到属性变量的值：&quot; + personNameField.get(obj));\n\n    }\n\n\n    /**\n     * Demo6: 通过Java反射机制得到类的一些属性： 继承的接口，父类，函数信息，成员信息，类型等\n     * @throws ClassNotFoundException\n     */\n    public static void Demo6() throws ClassNotFoundException\n    {\n        Class&lt;?&gt; class1 = null;\n        class1 = Class.forName(&quot;com.SuperMan&quot;);\n\n        //取得父类名称\n        Class&lt;?&gt;  superClass = class1.getSuperclass();\n        System.out.println(&quot;Demo6:  SuperMan类的父类名: &quot; + superClass.getName());\n\n        System.out.println(&quot;===============================================&quot;);\n\n\n        Field[] fields = class1.getDeclaredFields();\n        for (int i = 0; i &lt; fields.length; i++) {\n            System.out.println(&quot;类中的成员: &quot; + fields[i]);\n        }\n        System.out.println(&quot;===============================================&quot;);\n\n\n        //取得类方法\n        Method[] methods = class1.getDeclaredMethods();\n        for (int i = 0; i &lt; methods.length; i++) {\n            System.out.println(&quot;Demo6,取得SuperMan类的方法：&quot;);\n            System.out.println(&quot;函数名：&quot; + methods[i].getName());\n            System.out.println(&quot;函数返回类型：&quot; + methods[i].getReturnType());\n            System.out.println(&quot;函数访问修饰符：&quot; + Modifier.toString(methods[i].getModifiers()));\n            System.out.println(&quot;函数代码写法： &quot; + methods[i]);\n        }\n\n        System.out.println(&quot;===============================================&quot;);\n\n        //取得类实现的接口,因为接口类也属于Class,所以得到接口中的方法也是一样的方法得到哈\n        Class&lt;?&gt; interfaces[] = class1.getInterfaces();\n        for (int i = 0; i &lt; interfaces.length; i++) {\n            System.out.println(&quot;实现的接口类名: &quot; + interfaces[i].getName() );\n        }\n\n    }\n\n    /**\n     * Demo7: 通过Java反射机制调用类方法\n     * @throws ClassNotFoundException\n     * @throws NoSuchMethodException\n     * @throws SecurityException\n     * @throws InvocationTargetException\n     * @throws IllegalAccessException\n     * @throws IllegalArgumentException\n     * @throws InstantiationException\n     */\n    public static void Demo7() throws ClassNotFoundException, SecurityException, NoSuchMethodException, IllegalArgumentException, IllegalAccessException, InvocationTargetException, InstantiationException\n    {\n        Class&lt;?&gt; class1 = null;\n        class1 = Class.forName(&quot;com.SuperMan&quot;);\n\n        System.out.println(&quot;Demo7: \\n调用无参方法fly()：&quot;);\n        Method method = class1.getMethod(&quot;fly&quot;);\n        method.invoke(class1.newInstance());\n\n        System.out.println(&quot;调用有参方法walk(int m)：&quot;);\n        method = class1.getMethod(&quot;walk&quot;,int.class);\n        method.invoke(class1.newInstance(),100);\n    }\n\n    /**\n     * Demo8: 通过Java反射机制得到类加载器信息\n     *\n     * 在java中有三种类类加载器。[这段资料网上截取]\n     1）Bootstrap ClassLoader 此加载器采用c++编写，一般开发中很少见。\n     2）Extension ClassLoader 用来进行扩展类的加载，一般对应的是jre\\lib\\ext目录中的类\n     3）AppClassLoader 加载classpath指定的类，是最常用的加载器。同时也是java中默认的加载器。\n     *\n     * @throws ClassNotFoundException\n     */\n    public static void Demo8() throws ClassNotFoundException\n    {\n        Class&lt;?&gt; class1 = null;\n        class1 = Class.forName(&quot;com.SuperMan&quot;);\n        String nameString = class1.getClassLoader().getClass().getName();\n\n        System.out.println(&quot;Demo8: 类加载器类名: &quot; + nameString);\n    }\n\n\n\n}\n/**\n *\n * @author xiaoyaomeng\n *\n */\nclass  Person{\n    private int age;\n    private String name;\n    public Person(){\n\n    }\n    public Person(int age, String name){\n        this.age = age;\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n    public void setAge(int age) {\n        this.age = age;\n    }\n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n\nclass SuperMan extends Person implements ActionInterface\n{\n    private boolean BlueBriefs;\n\n    public void fly()\n    {\n        System.out.println(&quot;超人会飞耶～～&quot;);\n    }\n\n    public boolean isBlueBriefs() {\n        return BlueBriefs;\n    }\n    public void setBlueBriefs(boolean blueBriefs) {\n        BlueBriefs = blueBriefs;\n    }\n\n    @Override\n    public void walk(int m) {\n        // TODO Auto-generated method stub\n        System.out.println(&quot;超人会走耶～～走了&quot; + m + &quot;米就走不动了！&quot;);\n    }\n}\ninterface ActionInterface{\n    public void walk(int m);\n}\n</code></pre>'},p2BM:function(n,t){n.exports='<h4 id="-">网络层</h4>\n<p>TCP/IP协议栈：物理层、链路层、网络层、传输层、应用层（会话层+表示层+应用层）</p>\n<ul>\n<li>物理层：通过比特流在线路中传输来完成我们传输数据的目的，传输的方式很多种，传输的介质也很多中，光纤等</li>\n<li>链路层：数据帧，在数据包(报)上加<strong>mac地址</strong>形成数据帧，其中的CRC检测原理用来检测数据的完整性，这一层用到的协议有PPP（点到点协议）、例如家中的拨号上网，CSMA/CD协议(广播协议)，在局域网中用的很多。其中会发生一系列的问题，和解决问题的办法。</li>\n<li>网络层：数据包(报)，加上源ip地址和目标ip地址了。这一层的协议有四种，ARP（地址解析协议）、RARP(逆地址解析协议)、ICMP(网际控制报文协议)、IGMP(网际组管理协议)。这四种协议只是和IP协议配套使用</li>\n<li>传输层：这里会讲解到端口。常见的80端口，我们学习javaWeb时，使用Tomcat中，看到的是8080端口，浏览器使用的是80端口</li>\n</ul>\n<h4 id="-">基础知识</h4>\n<h5 id="-ip-">什么是ip地址？</h5>\n<p>ip地址实际是32位，也就是4个字节组成，因为32位太长了，不好识别，所以每次将其分为8位一组，分成4组，然后在根据每组换算成10进制数组，组与组之间用.分隔开来，举个例子，11111111，11111111，11111111，11111111就可以用255，255，255，255来表示了，所以每一组都是从0到255之间。现在在来看192.168.1.1这个ip地址，也能将其换成2进制来表示，只不过那样太麻烦，让人不易于看懂，所以就将其用10进制来表示。</p>\n<h5 id="ip-">ip地址的意义在哪里呢？</h5>\n<p>要上网就需要一个ip地址，这个ip地址不能和别人一样，独一无二，因为在网络上通信就是通过ip地址来找到你这台主机的，但是这个ip地址不是固定的，比如你在家拨号上网，是A这个ip地址，下一次拨号，可能就不是A，变成B了，这要看你所在的网络给你分配了什么ip地址。如何通过ip查找到你</p>\n<h5 id="ip-">ip地址的分类？</h5>\n<p>既然每个人的ip地址度不一样，那一台主机怎么通过ip地址找到另一台主机的呢，茫茫人海，不可能一个个查找把，所以就有专门的人来管理和分配这个ip地址\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/49.png?raw=true" alt="image"> </p>\n<ul>\n<li>A类地址：网络号有8位，第一位固定为0，127种，主机号有24位，那么就能给该类地址划分16777215个ip地址，也就1千多万个地址，意思就是比如你需要组建一个有1千多万台主机的网络，那么你就要去分配一个A类地址，要求给你一个网络号，然后其中1千多万的ip地址就由你自己分配了，最多也就只能分配127个这样的网络</li>\n<li>B类：网络号、主机号16位，就能有65535个网络号和65535个主机号了。</li>\n<li>C类：网络号有24位，也就能够分配1000多万个网络，但是主机号只有8位，也就是只能够自己分配254台主机最多\nD类：用于多播\nE类：留着以后用</li>\n</ul>\n<p>这就是我们老早以前所使用的ip地址，就是这样分的，这样看起来很合理啊，你看B类中，有那么多种，肯定够分了把，但是会暴露出一个问题就是，C类地址只能分配254台主机，现在中小型网络那么多，度超过了254台电脑，如果A公司有1000台电脑，那他肯定要去分配B类地址，就造成了几万个的ip地址浪费了。这显然不是很合理。</p>\n<h4 id="-">划分子网 = &lt;网络号&gt;+&lt;子网号&gt;+&lt;主机号&gt;</h4>\n<p>这是ip地址分类的第二大步，中间加了一个子网号，这样就加大了对上面的A类和B类地址的使用率。也就减少了A类和B类地址的浪费，但是也有问题就是C类地址不管怎么划分，他所容纳的主机太小了，随着网路的扩增，人人都使用电脑，那么A类和B类迟早度会用光，所以就用到了我们现在的IP地址</p>\n<h5 id="-ip-">无分类编址 = &lt;网路前缀&gt;+&lt;主机号&gt;   这个就是我们现在用的ip地址的算法。</h5>\n<p>不同就在于分类编址的网络号不能变，是固定长度，而无分类编址通过网络前缀可变化，就能根据你需要多少个主机号来自由给你分配网络前缀了。\n网络前缀：也就是用不定长的一连串1来表示ip地址的网络号。\n网络前缀：255.0.0.0  ip地址：192.168.1.1  那么该ip地址的前8位就属于网络号。\n网络前缀：255.224.0.0 ip地址：192.255.1.1 因为255是11111111，224是11100000，所以前11位表示网络号，也就是这个ip地址是处于192.224.0.0这个网络中，在这个网络中，能包含21个1转换为10进制这么多的主机。\n这个网络前缀我们也称子网掩码</p>\n<p>例如：已知ip地址141.14.72.24，所在网络的子网掩码是255.255.192.0，试求其网络地址？</p>\n<p>子网掩码：255.255.192.0      11111111，11111111，11000000，00000000\nip地址：141.14.72.24           10001101，00001110，01001000，00011000\n所以根据子网掩码知道ip地址的前18位为网络号，网络地址就为：10001101.00001110.01000000.00000000 转换为10进制就是141.14.64.0， 能够存纳14位1也就是16383台主机。</p>\n<h5 id="ip-mac-">ip地址和MAC地址的区别？</h5>\n<p>mac地址：物理地址\nip地址：网络中的地址\n在网络中我们通过主机的ip地址，先找到他的网络地址，到达了网络地址后，然后通过该网络中的老大(路由器)来分析一下这个ip地址是你网路中的哪个主机，这时，老大(路由器)就通过该目标ip地址改到对应主机的mac地址，既然知道了mac地址，就能找到该计算机了。就好比什么呢。路由器是每次分配给你的ip地址不一样，但是你的mac地址肯定不会变，所以就根据ip地址找到你的mac地址。但是怎么找到的呢？就要通过网络层中的ARP(地址解析协议)协议了。</p>\n<h5 id="arp-">ARP协议</h5>\n<p>地址解析协议：通过ip地址来解析主机的mac地址，是怎么个过程呢，拿局域网来说，一个局域网中有很多主机，主机A想和局域网中的主机B通话，但是只知道对方的ip地址，所以他就通过发广播，给局域网中所有的主机，问这个ip地址是谁，主机B收到了这个信息，通过网络适配器(网卡)就发现自己是这个ip地址，然后就把自己的mac地址发给源主机，这样就知道了mac地址，就能够通信了。\n类似的，在跨网络中就不是直接发广播了，先通过ip地址找到对应的网络地址，如何找到的对应的网络地址呢，通过路由器，每个路由器度有三层。网络层、链路层、物理层，也就是说最高能够识别网络层中的东西来，那么<strong>路由器也就有ARP协议</strong>了，每个路由器度能识别出目标ip地址在哪个路由器上，这其中涉及到了很多算法，我们这里不做更多的解释，简单来说，路由器能根据目标ip地址找到下一跳路由器的mac地址，然后一步一步跳下去，直到找到目标ip地址的网络地址的路由器，然后通过该路由器来找到目标ip地址的mac地址，这样就能够找到目标主机了。这就是ARP协议。</p>\n<ul>\n<li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP找到目的主机的硬件地址。 </li>\n<li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li>\n<li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。 </li>\n<li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。　　</li>\n</ul>\n<h5 id="ip-">IP协议</h5>\n<p>IP协议就是来规定数据报的格式，以及定义的功能\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/51.png?raw=true" alt="image">  </p>\n<ul>\n<li>固定部分：20个字节，一行是4个字节，有5行<ul>\n<li>版本：占4位，IP协议的版本，通信双方的IP协议版本要一致，普遍用IPv4，以后可能会用IPv6.</li>\n<li>首部长度：占4位，可表示的最大十进制为15，单位是32位字(4个字节)，表示首部最长为60个字节，也就是说除去固定部分的20个字节，可选字段和填充最多能是40个字节。</li>\n<li>区分服务：占8位，1个字节。有些要传输的数据要立马传达到对面，比如视频，语音这样的，不能跟邮件慢慢吞吞的达到对方一样，需要立马送达，这就是为什么需要这个区分服务了</li>\n<li>总长度：占16位，2个字节。占首部+数据部分的总长度是多少。数据帧最长不能超过1500个字节，数据包就不能一次性发太大，如果发的太大就要选择分片处理了。</li>\n<li>标识：占16位，2个字节，一个计数器，每产生一个数据包，计数器就加1，当数据包被分片时，下面将会说到分片问题，所有分片后的数据包的标识度一样。这样相同的标识的数据包片就能够重新组合到一起</li>\n<li>标志：占3位，第一位暂时没意义，第二位DF：不能分片的意思，为1时，不能分片，为0就可以分片,第三位MF,有分片的意思，为0代表这是若干数据包中的最后一片</li>\n<li>片偏移：占13位，在较长的分组在分片后，某片在原分组中的相对位置，几个例子，1111，1111，1111，1111这16位，分成4个数据包分片来发，第一个数据包分片的片偏移为1，第二个为5，第三个为9，第四个为13，就是这个意思，片偏移以8个字节为偏移单位，也就是说，每个分片的长度一定是8字节的整数倍，上面是以位来举例说明问题，实际上单位是8个字节为单位。</li>\n<li>生存时间：也就是ping命令中显示的TTL字段，跳数限制，每经过一个路由器，就减1，当跳到0后，就丢弃该数据包。window系统的起始TTL为32、Linux64、xp：128</li>\n<li>协议：占8位，数据包中数据部分使用的是什么协议，方便目的主机的IP层知道讲数据部分上交给哪个处理。</li>\n<li>首部检验和：占16位。这个字段只检验数据报的首部，但不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（一些字段，如生存时间、标志、片偏移等都可能发生变化）。不检验数据部分可减少计算的工作量。</li>\n<li>源地址：占32为，也就是源IP地址</li>\n<li>目标地址：占32位，也是IP地址</li>\n<li>可选部分：为了使整个数据包为整数个字节而设置的。　　　　　　　</li>\n<li></li>\n</ul>\n</li>\n</ul>\n<h5 id="icmp-">ICMP协议</h5>\n<p>ICMP差错报告报文、ICMP询问报文   比如我们经常用来测试网络连接畅通的ping命令等</p>\n<ul>\n<li>ICMP差错报告报文：检测在传送数据的过程中，发生的错误，如果发生了错误，会通过该协议返回给源主机一个带有错误原因的数据包<ul>\n<li>终点不可达：发送数据后，路由器或主机不能完成交付数据报时，就会往源主机发送终点不可达报文</li>\n<li>源点抑制：当路由器或主机由于网络拥塞而丢弃数据报时，返回一个源点抑制报文</li>\n<li>超时：参数问题，在ip数据包中的首部有的字段不正确时，丢弃该报，返回参数问题报文</li>\n<li>改变路由(重定向)：路由器把改变路由报文发送给主机，让主机下次直接经过改变后的路由器。</li>\n</ul>\n</li>\n</ul>\n<p>ICMP询问报文：回送请求和回答：主机向特定目标发出询问，收到此报文必须返回一个ICMP回送回答报文。用于测试目的站是否可达。</p>\n<ul>\n<li>时间戳请求和回答：请某个路由器或主机回答当前的日期和时间，用于进行时钟的同步和测量时间。</li>\n</ul>\n<h5 id="igmp-">IGMP协议</h5>\n<p>用于多播</p>\n<ul>\n<li>广播：老师在台上讲课，你们能随时看到老师的电脑屏幕，因为采用的广播，每个人度能接受到老师屏幕上所有的数据包</li>\n<li>多播：在一个局域网中，有三个多播组，A、B、C，A在放java视频，B在放C++视频，C在放娱乐视频，如果你想看Java视频，那么你就调到A这个多播组中学习java视频，学习累了，你就可以换到C这个多播组中看看娱乐节目，这就是多播的意思，相对广播来说，自己需要什么就调什么，而不是跟广播一样，被动接受，他播到哪，就只能看到哪，多播能自由控制速度。</li>\n<li>单播：50个人想看视频，就得发送50个数据包。多播的话就发一个，然后通过路由器转发50分给不同的人，</li>\n</ul>\n<p>注意：每个路由器度有一个路由表，并且主机也有记录ip地址和对应mac地址的功能。并不是每次通信度需要发广播询问。</p>\n<ul>\n<li><p>问题一：分析从主机A找到主机B的过程？\n1、A先在自己的网络中发送广播，通过ARP协议。问所有的主机，谁知道10.0.0.3这个ip地址的主机是谁，同时把自己的主机ip地址和mac地址一起发送，主机B发现自己是10.0.03这个ip地址，就把自己的mac地址发回去\n2、主机A发现有人回应，就知道在自己本网络中，然后就找到了目标主机，开始通讯。</p>\n</li>\n<li><p>问题二：分析从主机A找到主机E的过程\n1、主机A先发广播看自己本网络没有该主机，没有，然后就给ip地址为10.0.0.1这个路由器F1发信号获得路由器的mac地址，然后给他发信号叫该路由器F1帮我们查找ip地址为12.0.0.3的主机。这个路由器的ip地址就网关，所以每台计算机上度要有三个东西，ip地址，子网掩码，网关。 2、路由器因为知道所有的网络在哪里，通过子网掩码和ip地址，就能够算出该ip地址在哪一个网段中，路由器就一跳一跳的经过路由器，知道找到对应网段的路由器F2。3、找到F2后，F2就以同样的方式通过ip地址找到对应的mac地址，就这样找到了。</p>\n</li>\n<li><p>问题三：分析从主机A到主机E数据的形式。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/internet/54.png?raw=true" alt="image">  　</p>\n</li>\n</ul>\n'},qARP:function(n,t,i){"use strict";var e=i("lOnJ");n.exports.f=function(n){return new function(n){var t,i;this.promise=new n(function(n,e){if(void 0!==t||void 0!==i)throw TypeError("Bad Promise constructor");t=n,i=e}),this.resolve=e(t),this.reject=e(i)}(n)}},qahb:function(n,t){},qio6:function(n,t,i){var e=i("evD5"),l=i("77Pl"),o=i("lktj");n.exports=i("+E39")?Object.defineProperties:function(n,t){l(n);for(var i,a=o(t),r=a.length,p=0;r>p;)e.f(n,i=a[p++],t[i]);return n}},qug8:function(n,t,i){n.exports=i.p+"static/img/qoute.1e11a83.png"},rOXT:function(n,t){n.exports='<h4 id="-internet">局域网、广域网、Internet</h4>\n<ul>\n<li><p>局域网：覆盖范围较小、小型网络，宽带固定例如校园网、企业网；宽带固定：范围小，网络不拥堵，趋于稳定</p>\n</li>\n<li><p>广域网：距离远 花钱租带宽ISP(Internet Service Provider)因特网服务提供商，电信、联通、移动等，  它们在各个地方埋网线，有自己的主机、 然后我们出钱连入他们的网络，就能访问上网了。有一些网站站点放在电信机房中，我们电信网去访问，就会比较快，因为通往主机那边的地址的方式很多，如果电信网访问放在联通主机房中的网址，则相对会受到影响。</p>\n</li>\n<li><p><strong>Internet</strong></p>\n</li>\n</ul>\n<h5 id="-">计算机数据通信</h5>\n<h5 id="-">路由器的功能：转发收到的分组。</h5>\n<ol>\n<li><p>什么是分组？发送一段数据，将该段数据进行分组发送，而不是一次性全发送完。</p>\n</li>\n<li><p>什么是分组交换？在网路中，路由器跟路由器之间有一定的距离，我们计算机要发送一段数据出去，首先将数据分成n个分组，在每个分组前特定的头部，就成了数据包。然后将数据包发送到路由器，通过路由器来接受这些数据包，然后一部分一部分的发送，接受，在发送其中一个数据包的过程中，占用了其中的道路，发送完这一个，就释放，并不是一直占用该资源，直到传输结束，在其接受或发送数据时，也可以接受或发送别的数据，看先接受谁，就先发送谁，其实就是一个队列</p>\n</li>\n<li><p>分组交换、电路交换、报文交换的区别？</p>\n</li>\n<li><p>电路交换：就是电话线，A打给B，AB之间的电话线就接通了，那么不管他两说没说话，说多久，直到挂断之前，该线都是在占用之中。</p>\n</li>\n<li><p>报文交换：一次性发送完整的数据，那么该段路就被占用，传完就释放，然后接下一步的传送。直到到达目的地</p>\n</li>\n<li><p>分组交换：高效、灵活、迅速、可靠。</p>\n</li>\n</ol>\n<h5 id="ip-mac-">ip地址跟MAC地址</h5>\n<ul>\n<li>ip地址：每个计算机都有自己独特的ip地址，全球独一无二，跟电话一样，有些电话是 031-开头 有些地区是079开头， 这是分地区的，ip地址也是一样，</li>\n<li>mac地址：每台计算机上都有一个物理地址，也是独有的。在网卡上面，路由器也有mac地址。</li>\n</ul>\n<h5 id="-">主机如何将网页数据发回请求的计算机？</h5>\n<ol>\n<li>将要返回的数据分成N份</li>\n<li>每次将发送几份到缓存中，缓存就相当于队列，先进先出，缓存中发一份发回请求的计算机</li>\n<li>计算机接到第一份，返回一个数据，让主机发送下一份，然后将缓存中刚才发送的那一份删除</li>\n<li>如果中途数据丢包，则从缓存中继续发送刚才不成功那一份，直到接收到请求的计算机发回的确认数据。</li>\n</ol>\n<h5 id="osi-">OSI参考模型</h5>\n<h6 id="osi-open-systems-interconnection-reference-model-osi-rm">OSI（Open Systems Interconnection Reference Model）OSI/RM</h6>\n<p>简称 OSI 开放系统互连参考模型，通俗讲就是7层协议的体系结构</p>\n<h5 id="-">应用层、表示层、会话层、传输层、网络层、链路层、物理层</h5>\n<p><strong>这七层是在发送数据到网线之前，在计算机中内部就已经经过了这7层，不是在传输过程中才慢慢经过这7层的。</strong></p>\n<ul>\n<li>应用层：所有产生网络流量的程序</li>\n<li>表示层：在传输数据之前进行的一些操作(加密，压缩，发送数据使用的编码等)\n例如：发送数据使用的是UTF-8来编码，而在浏览器用别的编码来解码，就会出现乱码，这就是表示层出现了问题</li>\n<li>会话层：在传输数据时，需要通道，就需要创建会话，以防请求方和目标方不知道谁是谁。\n例如：访问百度， 则会与主机上存放百度网页的地址创建了会话，请求接收到了全部数据，则会话结束</li>\n<li>传输层：就是传输数据的过程，因为有了前面表示层和会话层做的一些事情，已经传输数据的条件了,<ul>\n<li>可靠传输：通过网址访问主机之间，进行的传输是一来一往，而且进行多次交流，多个数据包</li>\n<li>不可靠传输：通过网址到DNS解析器解析域名真实地址的过程，就是不可靠传输，只需要一个数据包，去一个，回一个就完成了。</li>\n</ul>\n</li>\n<li>网络层：规划最佳路径，规划ip地址，\n传输数据到目标地址的过程中，经过哪些路由器，也就是走什么路径，就是网络层做的事情</li>\n<li>数据链路层：对数据帧的开始与结束,差错校验。\n发送数据是分组发送的，不是一次性发送，每次发送一组数据，如何知道这一组数据就是我们发的呢，就需要在数据的开始和结束定义一个特殊的东西，让路由器或交换机知道该数据什么时候开始，什么时候结束\n差错校验，在接受完一组数据后，校验数据是否完整，如果有问题，则丢掉，让计算机重新发一次。</li>\n<li>物理层：定义网络接口标准\n网线的水晶头，里面都是8根线，0101如果定义，用1V代表1，0V代表0，类似这样规定。</li>\n</ul>\n<h4 id="-">计算机上的各种性能指标解释</h4>\n<h5 id="-">速率、带宽、吞吐量、时延、时延带宽积、往返时间、利用率</h5>\n<ul>\n<li>速率：在计算机与计算机之间通信时传输数据<strong>位数</strong>的速率   </li>\n<li>单位  bit/s   1bit也就是1位 <ul>\n<li>byte 与 bit 的区别和换算</li>\n</ul>\n</li>\n</ul>\n<pre><code>byte：字节 bit：位\n1byte = 8bit\n按字节换算\n1k = 1024byte　M与byte之间的换算是1024 \n1M = 1024K　　　\n按位换算\n1kb = 1000bit\n1Mb = 1000Kb\n1Gb = 1000Mb</code></pre><h5 id="-8m-1m-s-">常说的我的网络是8M 为什么下载速度只有1M/S呢？</h5>\n<p>这里的8M，单位是Mb，也就是按位来算的，而下载速度是按字节算的 8M = 8000Kb = 8000，000bit = 1000，000 byte ≈1000kb ≈1M</p>\n<p>所以一般都市直接除以8，8M的网络下载速度就是1M/s 100M的网下载速度也就10M/s</p>\n<ul>\n<li>带宽：接口支持最高的传输速率， 也就是我们的带宽是8M， 带宽是100M. </li>\n<li>吞吐量：单位时间内通过某个网络的数据量\n简单的说，就是通过一根网线一次性传输的多少个位，最高位就是带宽，但不是每次传输都达到了带宽值，有可能通过的只有3M，5M，都不一定，通过的量就是我们说的吞吐量</li>\n<li>时延：发送时延、传播时延、处理时延、排队时延</li>\n<li>发送时延 = 数据块长度(bit)/信道宽度(bit/s)</li>\n</ul>\n<pre><code>通过一个特定情景来讲解\nA----------------路由器---------------------B\nA发送0101010101(10bit)数据到B,带宽是10bit/s,A距离B100米,信号在信道上的传播速率是10米/s，当从开始发送1到最后一个0从A的网卡中出来结束，发送时延 = 10bit/10bit/s = 1s</code></pre><ol start="2">\n<li>传播时延 = 信道长度（米）/信号在信道上传播速率(米/秒)</li>\n</ol>\n<pre><code>从A发送1开始，到路由器，接受最后一个0结束，这一段也算是传播时延，路由器到B之间也是  100/10 = 10秒。在电线上花费的时间是10秒</code></pre><ol start="3">\n<li>排队时延：路由器接受数据，有一个缓冲区，相当于队列，数据到路由器，先到缓冲区排队等待路由器一个个接受数据，直到路由器开始接受第一个位，这就是排队时延，从路由器出来也需要排队时延</li>\n<li>处理时延：路由器开始接受第一个位，这就开始处理数据了，到最后一个位接受完，这之间就是处理时延</li>\n<li>时延带宽积： 其实也就是在信道中有多少位数据在其中，用的是带宽，也就是最高的数据。</li>\n<li>传播时延 * 带宽  </li>\n<li>往返时间：从A到B，在B返回数据到A，之间用了多少时间、利用率</li>\n<li>利用率：\n信道利用率：有数据通过时间/(有+无)数据通过时间\n网络利用率：信道利用率相加就是网络利用率</li>\n</ol>\n'},rX3V:function(n,t){n.exports='<h4 id="bit-byte-kbyte-kb-mb-gb-tb-">bit Byte KByte KB MB GB TB 单位换算</h4>\n<p>bit:[bɪt] (binary digit) 二进制数字,比特，&quot;位(bit)&quot;是电子计算机中最小的数据单位。每一位的状态只能是0或1。  </p>\n<p>Byte:[baɪt] 字节,1个字节可以储存1个英文字母或者半个汉字。</p>\n<p>1Byte＝8bit,1KB=1024B,1MB=1024KB,1GB=1024MB,1TB=1024GB</p>\n<p>“带宽”使用的单位是bit（位），“网速”使用的单位是Byte（字节），计算机存储单位也是字节。</p>\n'},rkWq:function(n,t){n.exports='<h4 id="-">冯·诺依曼结构计算机工作原理及层次分析</h4>\n<p>提出“离散变量自动电子计算机方案”---计算机之父--美国科学院院士</p>\n<h5 id="-">冯诺依曼计算机工作原理</h5>\n<ul>\n<li>存储程序：将程序存放到计算机的存储器中；</li>\n<li>程序控制：按照指令访问存储器并取出指令，经过译码依次产生指令指令执行所需的控制信号，实现对计算机的控制，完成指令的功能。<h5 id="-">冯诺依曼计算机的组成（硬件+软件）</h5>\n<h6 id="-">硬件系统（总体图）</h6>\n</li>\n</ul>\n<ul>\n<li>主机：CPU(运算器+控制器)、内存</li>\n<li>外设：输入设备、输出设备、外存储器</li>\n<li>总线：地址线、数据线、控制线</li>\n</ul>\n<h6 id="-">运算器</h6>\n<ul>\n<li>算术运算（加减乘除）</li>\n<li>逻辑运算（与或非）</li>\n<li>基本结构（ALU:Arithmetic Logical Unit、寄存器、连接通路）</li>\n</ul>\n<h6 id="-">控制器</h6>\n<ul>\n<li>基本功能：产生指令执行过程所需要的的所有控制信号，控制相关功能部件执行的相关操作</li>\n<li>控制信号的形式：电平信号、脉冲信号</li>\n<li>产生控制信号的依据：指令、状态、时序</li>\n<li>控制信号的产生方式：微程序、硬布线</li>\n</ul>\n<h6 id="-">存储器</h6>\n<ul>\n<li>功能：存储源程序、原数据、运算中间结果</li>\n<li>工作模式：读/写</li>\n</ul>\n<h6 id="-">输入输出设备（键盘、鼠标）</h6>\n'},sB3e:function(n,t,i){var e=i("52gC");n.exports=function(n){return Object(e(n))}},sV8p:function(n,t){n.exports='<h2 id="-symmetric-cryptography-">对称加密（Symmetric Cryptography）</h2>\n<ul>\n<li>最快、最简单的一种加密方式，加密（encryption）与解密（decryption）用同样密钥（secret key）。</li>\n<li>多种算法，因效率高，被广泛使用在很多加密协议的核心当中。</li>\n<li>通常使用的是相对较大的密钥，一般大于256 bit。因为密钥越大，加密越强，但加密与解密的过程越慢。如果你只用1 bit来做这个密钥，可以先试着用0来解密，不行的话就再用1解。</li>\n<li>对称加密的一大缺点是密钥的管理与分配，换句话说，如何把密钥发送到需要解密你的消息的人的手里是一个问题。在发送密钥的过程中，密钥有很大的风险会被黑客们拦截。现实中通常的做法是将对称加密的密钥进行非对称加密，然后传送给需要它的人。</li>\n</ul>\n<h2 id="-asymmetric-cryptography-">非对称加密（Asymmetric Cryptography）</h2>\n<ul>\n<li>使用了一对密钥，公钥（public key）和私钥（private key）。私钥只能由一方安全保管，不能外泄，而公钥则可以发给任何请求它的人。非对称加密使用这对密钥中的一个进行加密，而解密则需要另一个密钥。</li>\n<li>比如，你向银行请求公钥，银行将公钥发给你，你使用公钥对消息加密，那么只有私钥的持有人--银行才能对你的消息解密。与对称加密不同的是，银行不需要<strong>将私钥通过网络发送出去</strong>，因此安全性大大提高。</li>\n</ul>\n<h2 id="-">两者结合使用</h2>\n<p>（1） Alice需要在银行的网站做一笔交易，她的浏览器首先生成了一个随机数作为对称密钥。</p>\n<p>（2） Alice的浏览器向银行的网站请求公钥。</p>\n<p>（3） 银行将公钥发送给Alice。</p>\n<p>（4） Alice的浏览器使用银行的公钥将自己的对称密钥加密。</p>\n<p>（5） Alice的浏览器将加密后的对称密钥发送给银行。</p>\n<p>（6） 银行使用私钥解密得到Alice浏览器的对称密钥。</p>\n<p>（7） Alice与银行可以使用对称密钥来对沟通的内容进行加密与解密了。\n<img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/encryption/1.png?raw=true" alt="image"></p>\n<h2 id="-">总结</h2>\n<ul>\n<li>对称加密加密与解密使用的是同样的密钥，所以速度快，但由于需要将密钥在网络传输，所以安全性不高。</li>\n<li>非对称加密使用了一对密钥，公钥与私钥，所以安全性高，但加密与解密速度慢。</li>\n<li>解决的办法是将对称加密的密钥使用非对称加密的公钥进行加密，然后发送出去，接收方使用私钥进行解密得到对称加密的密钥，然后双方可以使用对称加密来进行沟通。</li>\n</ul>\n'},t8x9:function(n,t,i){var e=i("77Pl"),l=i("lOnJ"),o=i("dSzd")("species");n.exports=function(n,t){var i,a=e(n).constructor;return void 0===a||void 0==(i=e(a)[o])?t:l(i)}},u2Ox:function(n,t){n.exports='<h2 id="-">数据库事务</h2>\n<p>数据库中操作中的一系列原子操作（从数据库角度，就是一组SQL语句，要么全部成功，要么撤销不执行）</p>\n<h4 id="-acid">四大原则ACID</h4>\n<ul>\n<li>原子性(Atomicity)：指事务包含的所有操作要么全部成功，要么全部失败回滚，</li>\n<li>一致性(Consistency):一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态</li>\n<li>隔离性(Isolation):隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>\n<li>持久性(Durability):持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>\n</ul>\n<h4 id="-">隔离性解读</h4>\n<h5 id="-">没有隔离存在的问题</h5>\n<ul>\n<li>脏读：指在一个事务处理过程里读取了另一个已经修改了数据库，但是未提交的事务中的数据。</li>\n<li>不可重复读：指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li>\n<li>虚读(幻读)：事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</li>\n</ul>\n<h5 id="-">四种隔离级别：</h5>\n<ul>\n<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>\n<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>\n<li>Read committed (读已提交)：可避免脏读的发生。</li>\n<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>\n</ul>\n'},uBZ9:function(n,t){n.exports='<h4 id="-">清除浮动</h4>\n<pre><code>&lt;body&gt;\n    &lt;style type=&quot;text/css&quot;&gt;\n        .div1 {\n            background: #000080;\n            border: 1px solid red;\n        }\n\n        .div2 {\n            background: #800080;\n            border: 1px solid red;\n            height: 100px;\n            margin-top: 10px\n        }\n\n        .left {\n            float: left;\n            width: 20%;\n            height: 200px;\n            background: #DDD\n        }\n\n        .right {\n            float: right;\n            width: 30%;\n            height: 80px;\n            background: #DDD\n        }\n        /*清除浮动代码*/\n\n        .clearfloat:after {\n            display: block;\n            clear: both;\n            content: &quot;&quot;;\n            visibility: hidden;\n            height: 0\n        }\n\n        .clearfloat {\n            zoom: 1\n        }\n    &lt;/style&gt;\n    &lt;div class=&quot;div1 clearfloat&quot;&gt;\n        &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt;\n        &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;\n    &lt;/div&gt;\n    &lt;div class=&quot;div2&quot;&gt;\n        div2\n    &lt;/div&gt;\n&lt;/body&gt;</code></pre><ul>\n<li>zoom：1 兼容ie6,ie7</li>\n<li>clearfloat:after:添加伪元素，content为空，内容高度为0</li>\n</ul>\n<p><img src="https://github.com/caihaihong/caihaihong.github.io/blob/master/imgs/css/8.png?raw=true" alt="image"></p>\n'},uckV:function(n,t,i){n.exports=i.p+"static/img/headImg.8ffd7ef.jpg"},"uvu+":function(n,t){n.exports='<h4 id="localhost-127-0-0-1-ip-">localhost、127.0.0.1 和 本机IP 三者的区别?</h4>\n<ul>\n<li>localhost <ul>\n<li>本地主机的域名，只有自己主机可以访问，定义放在hosts文件</li>\n<li>不是地址，它可以被配置为任意的 IP 地址</li>\n</ul>\n</li>\n<li>127.0.0.1 环回地址<ul>\n<li>该地址通常分配给loopback接口</li>\n<li>loopback 是一个特殊的网络接口(可理解成虚拟网卡)，用于本机中各个应用之间  的网络交互。其他主机不能访问</li>\n</ul>\n</li>\n<li>网络IP地址（192.168.20.34）<ul>\n<li>本机物理网卡所绑定的网络协议地址</li>\n<li>不同局域网有不同IP</li>\n</ul>\n</li>\n</ul>\n'},vC40:function(n,t){n.exports='<h4 id="js-defer-async">JS加载 defer async</h4>\n<h5 id="-">脚本阻塞问题实际有两种解决方案</h5>\n<pre><code>&lt;script async src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt;</code></pre><ul>\n<li>浏览器遇到 async 脚本时不会阻塞页面渲染，而是直接下载然后运行。脚本的执行时间就无法控制，只是脚本不会阻止剩余页面的显示。</li>\n</ul>\n<pre><code>&lt;script defer src=&quot;js/vendor/jquery.js&quot;&gt;&lt;/script&gt;</code></pre><ul>\n<li>添加 defer（延时） 属性的脚本将按照在页面中出现的顺序加载，将脚本代码放置在页面底部可以替代defer所提供的功能。</li>\n</ul>\n<h6 id="-defer-async-async-async-async-">注意：如果元素同时定义了defer和async特性，则按async来处理，对于不支持async的浏览器会直接忽略async特性。</h6>\n'},"vFc/":function(n,t,i){var e=i("TcQ7"),l=i("QRG4"),o=i("fkB2");n.exports=function(n){return function(t,i,a){var r,p=e(t),s=l(p.length),c=o(a,s);if(n&&i!=i){for(;s>c;)if((r=p[c++])!=r)return!0}else for(;s>c;c++)if((n||c in p)&&p[c]===i)return n||c||0;return!n&&-1}}},"vIB/":function(n,t,i){"use strict";var e=i("O4g8"),l=i("kM2E"),o=i("880/"),a=i("hJx8"),r=i("/bQp"),p=i("94VQ"),s=i("e6n0"),c=i("PzxK"),u=i("dSzd")("iterator"),h=!([].keys&&"next"in[].keys()),d=function(){return this};n.exports=function(n,t,i,g,m,v,f){p(i,t,g);var b,S,y,E=function(n){if(!h&&n in w)return w[n];switch(n){case"keys":case"values":return function(){return new i(this,n)}}return function(){return new i(this,n)}},x=t+" Iterator",C="values"==m,q=!1,w=n.prototype,A=w[u]||w["@@iterator"]||m&&w[m],T=A||E(m),P=m?C?E("entries"):T:void 0,J="Array"==t&&w.entries||A;if(J&&(y=c(J.call(new n)))!==Object.prototype&&y.next&&(s(y,x,!0),e||"function"==typeof y[u]||a(y,u,d)),C&&A&&"values"!==A.name&&(q=!0,T=function(){return A.call(this)}),e&&!f||!h&&!q&&w[u]||a(w,u,T),r[t]=T,r[x]=d,m)if(b={values:C?T:E("values"),keys:v?T:E("keys"),entries:P},f)for(S in b)S in w||o(w,S,b[S]);else l(l.P+l.F*(h||q),t,b);return b}},xGkn:function(n,t,i){"use strict";var e=i("4mcu"),l=i("EGZi"),o=i("/bQp"),a=i("TcQ7");n.exports=i("vIB/")(Array,"Array",function(n,t){this._t=a(n),this._i=0,this._k=t},function(){var n=this._t,t=this._k,i=this._i++;return!n||i>=n.length?(this._t=void 0,l(1)):l(0,"keys"==t?i:"values"==t?n[i]:[i,n[i]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},"xH/j":function(n,t,i){var e=i("hJx8");n.exports=function(n,t,i){for(var l in t)i&&n[l]?n[l]=t[l]:e(n,l,t[l]);return n}},xnc9:function(n,t){n.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},zQR9:function(n,t,i){"use strict";var e=i("h65t")(!0);i("vIB/")(String,"String",function(n){this._t=String(n),this._i=0},function(){var n,t=this._t,i=this._i;return i>=t.length?{value:void 0,done:!0}:(n=e(t,i),this._i+=n.length,{value:n,done:!1})})},"zw+M":function(n,t){n.exports='<h4 id="-">数据包解析</h4>\n<p>当数据在Web上传输时，是以成千上万的小数据块的形式传输的。大量不同的用户都可以在同时下载同一个网页。如果网页以单个大的数据块形式传输，一次就只有一个用户下载。</p>\n'}});
//# sourceMappingURL=0.eceb20d9d9ff573a652c.js.map